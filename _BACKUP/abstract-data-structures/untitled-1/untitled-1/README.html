<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>README</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
    <style type="text/css">
      a.sourceLine {
        display: inline-block;
        line-height: 1.25;
      }
      a.sourceLine {
        pointer-events: none;
        color: inherit;
        text-decoration: inherit;
      }
      a.sourceLine:empty {
        height: 1.2em;
      }
      .sourceCode {
        overflow: visible;
      }
      code.sourceCode {
        white-space: pre;
        position: relative;
      }
      div.sourceCode {
        margin: 1em 0;
      }
      pre.sourceCode {
        margin: 0;
      }
      @media screen {
        div.sourceCode {
          overflow: auto;
        }
      }
      @media print {
        code.sourceCode {
          white-space: pre-wrap;
        }
        a.sourceLine {
          text-indent: -1em;
          padding-left: 1em;
        }
      }
      pre.numberSource a.sourceLine {
        position: relative;
        left: -4em;
      }
      pre.numberSource a.sourceLine::before {
        content: attr(title);
        position: relative;
        left: -1em;
        text-align: right;
        vertical-align: baseline;
        border: none;
        pointer-events: all;
        display: inline-block;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        padding: 0 4px;
        width: 4em;
        color: #aaaaaa;
      }
      pre.numberSource {
        margin-left: 3em;
        border-left: 1px solid #aaaaaa;
        padding-left: 4px;
      }
      div.sourceCode {
      }
      @media screen {
        a.sourceLine::before {
          text-decoration: underline;
        }
      }
      code span.al {
        color: #ff0000;
        font-weight: bold;
      } /* Alert */
      code span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Annotation */
      code span.at {
        color: #7d9029;
      } /* Attribute */
      code span.bn {
        color: #40a070;
      } /* BaseN */
      code span.bu {
      } /* BuiltIn */
      code span.cf {
        color: #007020;
        font-weight: bold;
      } /* ControlFlow */
      code span.ch {
        color: #4070a0;
      } /* Char */
      code span.cn {
        color: #880000;
      } /* Constant */
      code span.co {
        color: #60a0b0;
        font-style: italic;
      } /* Comment */
      code span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* CommentVar */
      code span.do {
        color: #ba2121;
        font-style: italic;
      } /* Documentation */
      code span.dt {
        color: #902000;
      } /* DataType */
      code span.dv {
        color: #40a070;
      } /* DecVal */
      code span.er {
        color: #ff0000;
        font-weight: bold;
      } /* Error */
      code span.ex {
      } /* Extension */
      code span.fl {
        color: #40a070;
      } /* Float */
      code span.fu {
        color: #06287e;
      } /* Function */
      code span.im {
      } /* Import */
      code span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Information */
      code span.kw {
        color: #007020;
        font-weight: bold;
      } /* Keyword */
      code span.op {
        color: #666666;
      } /* Operator */
      code span.ot {
        color: #007020;
      } /* Other */
      code span.pp {
        color: #bc7a00;
      } /* Preprocessor */
      code span.sc {
        color: #4070a0;
      } /* SpecialChar */
      code span.ss {
        color: #bb6688;
      } /* SpecialString */
      code span.st {
        color: #4070a0;
      } /* String */
      code span.va {
        color: #19177c;
      } /* Variable */
      code span.vs {
        color: #4070a0;
      } /* VerbatimString */
      code span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Warning */
    </style>
  </head>
  <body>
    <h1 id="graphs">Graphs</h1>
    <p>Projects:</p>
    <p>{% file src=“../../../.gitbook/assets/projects.zip” %}</p>
    <p>{% tabs %} {% tab title=“Adjacency List” %}</p>
    <div class="sourceCode" id="cb1">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="im">from</span> queue <span class="im">import</span> Queue</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="im">from</span> stack <span class="im">import</span> Stack</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co"># lets do a graph adjacency list</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">class</span> Graph:</a>
<a class="sourceLine" id="cb1-5" title="5">    <span class="co">&quot;&quot;&quot;Represent a graph as a dictionary of vertices mapping labels to edges.&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb1-7" title="7">        <span class="va">self</span>.vertices <span class="op">=</span> {}</a>
<a class="sourceLine" id="cb1-8" title="8"></a>
<a class="sourceLine" id="cb1-9" title="9">    <span class="kw">def</span> add_vertex(<span class="va">self</span>, vertex_id):</a>
<a class="sourceLine" id="cb1-10" title="10">        <span class="va">self</span>.vertices[vertex_id] <span class="op">=</span> <span class="bu">set</span>()</a>
<a class="sourceLine" id="cb1-11" title="11"></a>
<a class="sourceLine" id="cb1-12" title="12">    <span class="kw">def</span> add_edge(<span class="va">self</span>, v1, v2):</a>
<a class="sourceLine" id="cb1-13" title="13">        <span class="cf">if</span> v1 <span class="kw">in</span> <span class="va">self</span>.vertices <span class="kw">and</span> v2 <span class="kw">in</span> <span class="va">self</span>.vertices:</a>
<a class="sourceLine" id="cb1-14" title="14">            <span class="va">self</span>.vertices[v1].add(v2)</a>
<a class="sourceLine" id="cb1-15" title="15">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb1-16" title="16">            <span class="cf">raise</span> <span class="pp">IndexError</span>(<span class="st">&quot;Vertex Does not exist!&quot;</span>)</a>
<a class="sourceLine" id="cb1-17" title="17"></a>
<a class="sourceLine" id="cb1-18" title="18">    <span class="kw">def</span> get_neighbors(<span class="va">self</span>, vertex_id):</a>
<a class="sourceLine" id="cb1-19" title="19">        <span class="cf">return</span> <span class="va">self</span>.vertices[vertex_id]</a>
<a class="sourceLine" id="cb1-20" title="20"></a>
<a class="sourceLine" id="cb1-21" title="21">    <span class="kw">def</span> bft(<span class="va">self</span>, starting_vertex_id):</a>
<a class="sourceLine" id="cb1-22" title="22">        <span class="co"># create an empty queue and enqueue a starting vertex</span></a>
<a class="sourceLine" id="cb1-23" title="23">        q <span class="op">=</span> Queue()</a>
<a class="sourceLine" id="cb1-24" title="24">        q.enqueue(starting_vertex_id)</a>
<a class="sourceLine" id="cb1-25" title="25"></a>
<a class="sourceLine" id="cb1-26" title="26">        <span class="co"># create a set to store the visited vertices</span></a>
<a class="sourceLine" id="cb1-27" title="27">        visited <span class="op">=</span> <span class="bu">set</span>()</a>
<a class="sourceLine" id="cb1-28" title="28"></a>
<a class="sourceLine" id="cb1-29" title="29">        <span class="co"># while the queue is not empty</span></a>
<a class="sourceLine" id="cb1-30" title="30">        <span class="cf">while</span> q.size <span class="op">&gt;</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb1-31" title="31">            <span class="co"># dequeue the first vertex</span></a>
<a class="sourceLine" id="cb1-32" title="32">            v <span class="op">=</span> q.dequeue()</a>
<a class="sourceLine" id="cb1-33" title="33"></a>
<a class="sourceLine" id="cb1-34" title="34">            <span class="co"># if vertex has not been visited</span></a>
<a class="sourceLine" id="cb1-35" title="35">            <span class="cf">if</span> v <span class="kw">not</span> <span class="kw">in</span> visited:</a>
<a class="sourceLine" id="cb1-36" title="36">                <span class="co"># mark the vertex as visited</span></a>
<a class="sourceLine" id="cb1-37" title="37">                visited.add(v)</a>
<a class="sourceLine" id="cb1-38" title="38">                <span class="co"># print it for debug</span></a>
<a class="sourceLine" id="cb1-39" title="39">                <span class="bu">print</span>(v)</a>
<a class="sourceLine" id="cb1-40" title="40"></a>
<a class="sourceLine" id="cb1-41" title="41">                <span class="co"># add all of it&#39;s neighbors to the back of the queue</span></a>
<a class="sourceLine" id="cb1-42" title="42">                <span class="cf">for</span> next_vertex <span class="kw">in</span> <span class="va">self</span>.get_neighbors(v):</a>
<a class="sourceLine" id="cb1-43" title="43">                    q.enqueue(next_vertex)</a>
<a class="sourceLine" id="cb1-44" title="44"></a>
<a class="sourceLine" id="cb1-45" title="45">    <span class="kw">def</span> dft(<span class="va">self</span>, starting_vertex_id):</a>
<a class="sourceLine" id="cb1-46" title="46">        <span class="co"># create an empty stack and push a starting vertex</span></a>
<a class="sourceLine" id="cb1-47" title="47">        s <span class="op">=</span> Stack()</a>
<a class="sourceLine" id="cb1-48" title="48">        s.push(starting_vertex_id)</a>
<a class="sourceLine" id="cb1-49" title="49"></a>
<a class="sourceLine" id="cb1-50" title="50">        <span class="co"># create a set to store the visited vertices</span></a>
<a class="sourceLine" id="cb1-51" title="51">        visited <span class="op">=</span> <span class="bu">set</span>()</a>
<a class="sourceLine" id="cb1-52" title="52"></a>
<a class="sourceLine" id="cb1-53" title="53">        <span class="co"># while the stack is not empty</span></a>
<a class="sourceLine" id="cb1-54" title="54">        <span class="cf">while</span> s.size <span class="op">&gt;</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb1-55" title="55">            <span class="co"># pop the first vertex</span></a>
<a class="sourceLine" id="cb1-56" title="56">            v <span class="op">=</span> s.pop()</a>
<a class="sourceLine" id="cb1-57" title="57"></a>
<a class="sourceLine" id="cb1-58" title="58">            <span class="co"># if vertex has not been visited</span></a>
<a class="sourceLine" id="cb1-59" title="59">            <span class="cf">if</span> v <span class="kw">not</span> <span class="kw">in</span> visited:</a>
<a class="sourceLine" id="cb1-60" title="60">                <span class="co"># mark the vertex as visited</span></a>
<a class="sourceLine" id="cb1-61" title="61">                visited.add(v)</a>
<a class="sourceLine" id="cb1-62" title="62">                <span class="co"># print it for debug</span></a>
<a class="sourceLine" id="cb1-63" title="63">                <span class="bu">print</span>(v)</a>
<a class="sourceLine" id="cb1-64" title="64"></a>
<a class="sourceLine" id="cb1-65" title="65">                <span class="co"># add all of it&#39;s neighbors to the top of the stack</span></a>
<a class="sourceLine" id="cb1-66" title="66">                <span class="cf">for</span> next_vertex <span class="kw">in</span> <span class="va">self</span>.get_neighbors(v):</a>
<a class="sourceLine" id="cb1-67" title="67">                    s.push(next_vertex)</a>
<a class="sourceLine" id="cb1-68" title="68"></a>
<a class="sourceLine" id="cb1-69" title="69"></a>
<a class="sourceLine" id="cb1-70" title="70">    <span class="kw">def</span> dft_recursive(<span class="va">self</span>, starting_vertex, visited<span class="op">=</span><span class="va">None</span>):</a>
<a class="sourceLine" id="cb1-71" title="71">            <span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-72" title="72"><span class="co">            Print each vertex in depth-first order</span></a>
<a class="sourceLine" id="cb1-73" title="73"><span class="co">            beginning from starting_vertex.</span></a>
<a class="sourceLine" id="cb1-74" title="74"><span class="co">            This should be done using recursion.</span></a>
<a class="sourceLine" id="cb1-75" title="75"><span class="co">            &quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-76" title="76">            <span class="cf">if</span> visited <span class="kw">is</span> <span class="va">None</span>:</a>
<a class="sourceLine" id="cb1-77" title="77">                visited <span class="op">=</span> <span class="bu">set</span>()</a>
<a class="sourceLine" id="cb1-78" title="78">            visited.add(starting_vertex)</a>
<a class="sourceLine" id="cb1-79" title="79">            <span class="bu">print</span>(starting_vertex)</a>
<a class="sourceLine" id="cb1-80" title="80"></a>
<a class="sourceLine" id="cb1-81" title="81">            <span class="cf">for</span> v <span class="kw">in</span> <span class="va">self</span>.get_neighbors(starting_vertex):</a>
<a class="sourceLine" id="cb1-82" title="82">                <span class="cf">if</span> v <span class="kw">not</span> <span class="kw">in</span> visited:</a>
<a class="sourceLine" id="cb1-83" title="83">                    <span class="va">self</span>.dft_recursive(v, visited)</a>
<a class="sourceLine" id="cb1-84" title="84"></a>
<a class="sourceLine" id="cb1-85" title="85">    <span class="kw">def</span> bfs(<span class="va">self</span>, starting_vertex_id, target_vertex_id):</a>
<a class="sourceLine" id="cb1-86" title="86">        <span class="co"># create an empty queue and enqueue PATH To the Starting Vertex ID</span></a>
<a class="sourceLine" id="cb1-87" title="87">        q <span class="op">=</span> Queue()</a>
<a class="sourceLine" id="cb1-88" title="88">        q.enqueue([starting_vertex_id])</a>
<a class="sourceLine" id="cb1-89" title="89">        <span class="co"># create a set to store visited vertices</span></a>
<a class="sourceLine" id="cb1-90" title="90">        visited <span class="op">=</span> <span class="bu">set</span>()</a>
<a class="sourceLine" id="cb1-91" title="91"></a>
<a class="sourceLine" id="cb1-92" title="92">        <span class="co"># while the queue is not empty</span></a>
<a class="sourceLine" id="cb1-93" title="93">        <span class="cf">while</span> q.size() <span class="op">&gt;</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb1-94" title="94">            <span class="co"># dequeue the first PATH</span></a>
<a class="sourceLine" id="cb1-95" title="95">            path <span class="op">=</span> q.dequeue()</a>
<a class="sourceLine" id="cb1-96" title="96">            <span class="co"># grab the last vertex from the Path</span></a>
<a class="sourceLine" id="cb1-97" title="97">            v <span class="op">=</span> path[<span class="op">-</span><span class="dv">1</span>]</a>
<a class="sourceLine" id="cb1-98" title="98"></a>
<a class="sourceLine" id="cb1-99" title="99">            <span class="co"># check if the vertex has not been visited</span></a>
<a class="sourceLine" id="cb1-100" title="100">            <span class="cf">if</span> v <span class="kw">not</span> <span class="kw">in</span> visited:</a>
<a class="sourceLine" id="cb1-101" title="101">                <span class="co"># is this vertex the target?</span></a>
<a class="sourceLine" id="cb1-102" title="102">                <span class="cf">if</span> v <span class="op">==</span> target_vertex_id:</a>
<a class="sourceLine" id="cb1-103" title="103">                    <span class="co"># return the path</span></a>
<a class="sourceLine" id="cb1-104" title="104">                    <span class="cf">return</span> path</a>
<a class="sourceLine" id="cb1-105" title="105">                <span class="co"># mark it as visited</span></a>
<a class="sourceLine" id="cb1-106" title="106">                visited.add(v)</a>
<a class="sourceLine" id="cb1-107" title="107"></a>
<a class="sourceLine" id="cb1-108" title="108">                <span class="co"># then add A Path to its neighbors to the back of the queue</span></a>
<a class="sourceLine" id="cb1-109" title="109">                <span class="cf">for</span> next_v <span class="kw">in</span> <span class="va">self</span>.get_neighbors(v):</a>
<a class="sourceLine" id="cb1-110" title="110">                    <span class="co"># make a copy of the path</span></a>
<a class="sourceLine" id="cb1-111" title="111">                    path_copy <span class="op">=</span> <span class="bu">list</span>(path)</a>
<a class="sourceLine" id="cb1-112" title="112">                    <span class="co"># append the neighbor to the back of the path</span></a>
<a class="sourceLine" id="cb1-113" title="113">                    path_copy.append(next_v)</a>
<a class="sourceLine" id="cb1-114" title="114">                    <span class="co"># enqueue out new path</span></a>
<a class="sourceLine" id="cb1-115" title="115">                    q.enqueue(path_copy)</a>
<a class="sourceLine" id="cb1-116" title="116"></a>
<a class="sourceLine" id="cb1-117" title="117"></a>
<a class="sourceLine" id="cb1-118" title="118">        <span class="co"># return none</span></a>
<a class="sourceLine" id="cb1-119" title="119">        <span class="cf">return</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb1-120" title="120"></a>
<a class="sourceLine" id="cb1-121" title="121">    <span class="kw">def</span> dfs(<span class="va">self</span>, starting_vertex_id, target_vertex_id):</a>
<a class="sourceLine" id="cb1-122" title="122">        <span class="co"># create an empty stack and push PATH To the Starting Vertex ID</span></a>
<a class="sourceLine" id="cb1-123" title="123">        s <span class="op">=</span> Stack()</a>
<a class="sourceLine" id="cb1-124" title="124">        s.push([starting_vertex_id])</a>
<a class="sourceLine" id="cb1-125" title="125">        <span class="co"># create a set to store visited vertices</span></a>
<a class="sourceLine" id="cb1-126" title="126">        visited <span class="op">=</span> <span class="bu">set</span>()</a>
<a class="sourceLine" id="cb1-127" title="127"></a>
<a class="sourceLine" id="cb1-128" title="128">        <span class="co"># while the stack is not empty</span></a>
<a class="sourceLine" id="cb1-129" title="129">        <span class="cf">while</span> s.size() <span class="op">&gt;</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb1-130" title="130">            <span class="co"># pop the first PATH</span></a>
<a class="sourceLine" id="cb1-131" title="131">            path <span class="op">=</span> s.pop()</a>
<a class="sourceLine" id="cb1-132" title="132">            <span class="co"># grab the last vertex from the Path</span></a>
<a class="sourceLine" id="cb1-133" title="133">            v <span class="op">=</span> path[<span class="op">-</span><span class="dv">1</span>]</a>
<a class="sourceLine" id="cb1-134" title="134"></a>
<a class="sourceLine" id="cb1-135" title="135">            <span class="co"># check if the vertex has not been visited</span></a>
<a class="sourceLine" id="cb1-136" title="136">            <span class="cf">if</span> v <span class="kw">not</span> <span class="kw">in</span> visited:</a>
<a class="sourceLine" id="cb1-137" title="137">                <span class="co"># is this vertex the target?</span></a>
<a class="sourceLine" id="cb1-138" title="138">                <span class="cf">if</span> v <span class="op">==</span> target_vertex_id:</a>
<a class="sourceLine" id="cb1-139" title="139">                    <span class="co"># return the path</span></a>
<a class="sourceLine" id="cb1-140" title="140">                    <span class="cf">return</span> path</a>
<a class="sourceLine" id="cb1-141" title="141">                <span class="co"># mark it as visited</span></a>
<a class="sourceLine" id="cb1-142" title="142">                visited.add(v)</a>
<a class="sourceLine" id="cb1-143" title="143"></a>
<a class="sourceLine" id="cb1-144" title="144">                <span class="co"># then add A Path to its neighbors to the back of the queue</span></a>
<a class="sourceLine" id="cb1-145" title="145">                <span class="cf">for</span> next_v <span class="kw">in</span> <span class="va">self</span>.get_neighbors(v):</a>
<a class="sourceLine" id="cb1-146" title="146">                    <span class="co"># make a copy of the path</span></a>
<a class="sourceLine" id="cb1-147" title="147">                    path_copy <span class="op">=</span> <span class="bu">list</span>(path)</a>
<a class="sourceLine" id="cb1-148" title="148">                    <span class="co"># append the neighbor to the back of the path</span></a>
<a class="sourceLine" id="cb1-149" title="149">                    path_copy.append(next_v)</a>
<a class="sourceLine" id="cb1-150" title="150">                    <span class="co"># push out new path</span></a>
<a class="sourceLine" id="cb1-151" title="151">                    s.push(path_copy)</a>
<a class="sourceLine" id="cb1-152" title="152"></a>
<a class="sourceLine" id="cb1-153" title="153"></a>
<a class="sourceLine" id="cb1-154" title="154">        <span class="co"># return none</span></a>
<a class="sourceLine" id="cb1-155" title="155">        <span class="cf">return</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb1-156" title="156"></a>
<a class="sourceLine" id="cb1-157" title="157"></a>
<a class="sourceLine" id="cb1-158" title="158"></a>
<a class="sourceLine" id="cb1-159" title="159"></a>
<a class="sourceLine" id="cb1-160" title="160"><span class="co"># if __name__ == &#39;__main__&#39;:</span></a>
<a class="sourceLine" id="cb1-161" title="161"><span class="co">#     graph = Graph()  # Instantiate your graph</span></a>
<a class="sourceLine" id="cb1-162" title="162"><span class="co">#     # https://github.com/LambdaSchool/Graphs/blob/master/objectives/breadth-first-search/img/bfs-visit-order.png</span></a>
<a class="sourceLine" id="cb1-163" title="163"><span class="co">#     graph.add_vertex(1)</span></a>
<a class="sourceLine" id="cb1-164" title="164"><span class="co">#     graph.add_vertex(2)</span></a>
<a class="sourceLine" id="cb1-165" title="165"><span class="co">#     graph.add_vertex(3)</span></a>
<a class="sourceLine" id="cb1-166" title="166"><span class="co">#     graph.add_vertex(4)</span></a>
<a class="sourceLine" id="cb1-167" title="167"><span class="co">#     graph.add_vertex(5)</span></a>
<a class="sourceLine" id="cb1-168" title="168"><span class="co">#     graph.add_vertex(6)</span></a>
<a class="sourceLine" id="cb1-169" title="169"><span class="co">#     graph.add_vertex(7)</span></a>
<a class="sourceLine" id="cb1-170" title="170"><span class="co">#     graph.add_edge(5, 3)</span></a>
<a class="sourceLine" id="cb1-171" title="171"><span class="co">#     graph.add_edge(6, 3)</span></a>
<a class="sourceLine" id="cb1-172" title="172"><span class="co">#     graph.add_edge(7, 1)</span></a>
<a class="sourceLine" id="cb1-173" title="173"><span class="co">#     graph.add_edge(4, 7)</span></a>
<a class="sourceLine" id="cb1-174" title="174"><span class="co">#     graph.add_edge(1, 2)</span></a>
<a class="sourceLine" id="cb1-175" title="175"><span class="co">#     graph.add_edge(7, 6)</span></a>
<a class="sourceLine" id="cb1-176" title="176"><span class="co">#     graph.add_edge(2, 4)</span></a>
<a class="sourceLine" id="cb1-177" title="177"><span class="co">#     graph.add_edge(3, 5)</span></a>
<a class="sourceLine" id="cb1-178" title="178"><span class="co">#     graph.add_edge(2, 3)</span></a>
<a class="sourceLine" id="cb1-179" title="179"><span class="co">#     graph.add_edge(4, 6)</span></a>
<a class="sourceLine" id="cb1-180" title="180"></a>
<a class="sourceLine" id="cb1-181" title="181"><span class="co">#     &#39;&#39;&#39;</span></a>
<a class="sourceLine" id="cb1-182" title="182"><span class="co">#     Should print:</span></a>
<a class="sourceLine" id="cb1-183" title="183"><span class="co">#         {1: {2}, 2: {3, 4}, 3: {5}, 4: {6, 7}, 5: {3}, 6: {3}, 7: {1, 6}}</span></a>
<a class="sourceLine" id="cb1-184" title="184"><span class="co">#     &#39;&#39;&#39;</span></a>
<a class="sourceLine" id="cb1-185" title="185"><span class="co">#     print(graph.vertices)</span></a>
<a class="sourceLine" id="cb1-186" title="186"></a>
<a class="sourceLine" id="cb1-187" title="187"><span class="co">#     &#39;&#39;&#39;</span></a>
<a class="sourceLine" id="cb1-188" title="188"><span class="co">#     Valid BFT paths:</span></a>
<a class="sourceLine" id="cb1-189" title="189"><span class="co">#         1, 2, 3, 4, 5, 6, 7</span></a>
<a class="sourceLine" id="cb1-190" title="190"><span class="co">#         1, 2, 3, 4, 5, 7, 6</span></a>
<a class="sourceLine" id="cb1-191" title="191"><span class="co">#         1, 2, 3, 4, 6, 7, 5</span></a>
<a class="sourceLine" id="cb1-192" title="192"><span class="co">#         1, 2, 3, 4, 6, 5, 7</span></a>
<a class="sourceLine" id="cb1-193" title="193"><span class="co">#         1, 2, 3, 4, 7, 6, 5</span></a>
<a class="sourceLine" id="cb1-194" title="194"><span class="co">#         1, 2, 3, 4, 7, 5, 6</span></a>
<a class="sourceLine" id="cb1-195" title="195"><span class="co">#         1, 2, 4, 3, 5, 6, 7</span></a>
<a class="sourceLine" id="cb1-196" title="196"><span class="co">#         1, 2, 4, 3, 5, 7, 6</span></a>
<a class="sourceLine" id="cb1-197" title="197"><span class="co">#         1, 2, 4, 3, 6, 7, 5</span></a>
<a class="sourceLine" id="cb1-198" title="198"><span class="co">#         1, 2, 4, 3, 6, 5, 7</span></a>
<a class="sourceLine" id="cb1-199" title="199"><span class="co">#         1, 2, 4, 3, 7, 6, 5</span></a>
<a class="sourceLine" id="cb1-200" title="200"><span class="co">#         1, 2, 4, 3, 7, 5, 6</span></a>
<a class="sourceLine" id="cb1-201" title="201"><span class="co">#     &#39;&#39;&#39;</span></a>
<a class="sourceLine" id="cb1-202" title="202"><span class="co">#     graph.bft(1)</span></a>
<a class="sourceLine" id="cb1-203" title="203"></a>
<a class="sourceLine" id="cb1-204" title="204"><span class="co">#     &#39;&#39;&#39;</span></a>
<a class="sourceLine" id="cb1-205" title="205"><span class="co">#     Valid DFT paths:</span></a>
<a class="sourceLine" id="cb1-206" title="206"><span class="co">#         1, 2, 3, 5, 4, 6, 7</span></a>
<a class="sourceLine" id="cb1-207" title="207"><span class="co">#         1, 2, 3, 5, 4, 7, 6</span></a>
<a class="sourceLine" id="cb1-208" title="208"><span class="co">#         1, 2, 4, 7, 6, 3, 5</span></a>
<a class="sourceLine" id="cb1-209" title="209"><span class="co">#         1, 2, 4, 6, 3, 5, 7</span></a>
<a class="sourceLine" id="cb1-210" title="210"><span class="co">#     &#39;&#39;&#39;</span></a>
<a class="sourceLine" id="cb1-211" title="211"><span class="co">#     graph.dft(1)</span></a>
<a class="sourceLine" id="cb1-212" title="212"><span class="co">#     graph.dft_recursive(1)</span></a>
<a class="sourceLine" id="cb1-213" title="213"></a>
<a class="sourceLine" id="cb1-214" title="214"><span class="co">#     &#39;&#39;&#39;</span></a>
<a class="sourceLine" id="cb1-215" title="215"><span class="co">#     Valid BFS path:</span></a>
<a class="sourceLine" id="cb1-216" title="216"><span class="co">#         [1, 2, 4, 6]</span></a>
<a class="sourceLine" id="cb1-217" title="217"><span class="co">#     &#39;&#39;&#39;</span></a>
<a class="sourceLine" id="cb1-218" title="218"><span class="co">#     print(graph.bfs(1, 6))</span></a>
<a class="sourceLine" id="cb1-219" title="219"></a>
<a class="sourceLine" id="cb1-220" title="220"><span class="co">#     &#39;&#39;&#39;</span></a>
<a class="sourceLine" id="cb1-221" title="221"><span class="co">#     Valid DFS paths:</span></a>
<a class="sourceLine" id="cb1-222" title="222"><span class="co">#         [1, 2, 4, 6]</span></a>
<a class="sourceLine" id="cb1-223" title="223"><span class="co">#         [1, 2, 4, 7, 6]</span></a>
<a class="sourceLine" id="cb1-224" title="224"><span class="co">#     &#39;&#39;&#39;</span></a>
<a class="sourceLine" id="cb1-225" title="225"><span class="co">#     print(graph.dfs(1, 6))</span></a>
<a class="sourceLine" id="cb1-226" title="226"><span class="co">#     print(graph.dfs_recursive(1, 6))</span></a></code></pre>
    </div>
    <p>{% endtab %}</p>
    <p>{% tab title=“Graph.js” %}</p>
    <div class="sourceCode" id="cb2">
      <pre
        class="sourceCode javascript"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">class</span> Graph <span class="op">{</span></a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="at">constructor</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="kw">this</span>.<span class="at">adjacencyMap</span> <span class="op">=</span> <span class="op">{};</span></a>
<a class="sourceLine" id="cb2-4" title="4">  <span class="op">}</span></a>
<a class="sourceLine" id="cb2-5" title="5"></a>
<a class="sourceLine" id="cb2-6" title="6">  <span class="at">addVertex</span>(v) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-7" title="7">    <span class="kw">this</span>.<span class="at">adjacencyMap</span>[v] <span class="op">=</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb2-8" title="8">  <span class="op">}</span></a>
<a class="sourceLine" id="cb2-9" title="9"></a>
<a class="sourceLine" id="cb2-10" title="10">  <span class="at">containsVertex</span>(vertex) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-11" title="11">    <span class="cf">return</span> <span class="kw">typeof</span> <span class="kw">this</span>.<span class="at">adjacencyMap</span>[vertex] <span class="op">!==</span> <span class="st">&#39;undefined&#39;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-12" title="12">  <span class="op">}</span></a>
<a class="sourceLine" id="cb2-13" title="13"></a>
<a class="sourceLine" id="cb2-14" title="14">  <span class="at">addEdge</span>(v<span class="op">,</span> w) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-15" title="15">    <span class="kw">let</span> result <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-16" title="16">    <span class="cf">if</span> (<span class="kw">this</span>.<span class="at">containsVertex</span>(v) <span class="op">&amp;&amp;</span> <span class="kw">this</span>.<span class="at">containsVertex</span>(w)) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-17" title="17">      <span class="kw">this</span>.<span class="at">adjacencyMap</span>[v].<span class="at">push</span>(w)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-18" title="18">      <span class="kw">this</span>.<span class="at">adjacencyMap</span>[w].<span class="at">push</span>(v)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-19" title="19">      result <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-20" title="20">    <span class="op">}</span></a>
<a class="sourceLine" id="cb2-21" title="21">    <span class="cf">return</span> result<span class="op">;</span></a>
<a class="sourceLine" id="cb2-22" title="22">  <span class="op">}</span></a>
<a class="sourceLine" id="cb2-23" title="23"></a>
<a class="sourceLine" id="cb2-24" title="24">  <span class="at">printGraph</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb2-25" title="25">    <span class="kw">const</span> keys <span class="op">=</span> <span class="va">Object</span>.<span class="at">keys</span>(<span class="kw">this</span>.<span class="at">adjacencyMap</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-26" title="26">    <span class="cf">for</span> (<span class="kw">const</span> i <span class="kw">of</span> keys) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-27" title="27">      <span class="kw">const</span> values <span class="op">=</span> <span class="kw">this</span>.<span class="at">adjacencyMap</span>[i]<span class="op">;</span></a>
<a class="sourceLine" id="cb2-28" title="28">      <span class="kw">let</span> vertex <span class="op">=</span> <span class="st">&#39;&#39;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-29" title="29">      <span class="cf">for</span> (<span class="kw">const</span> j <span class="kw">of</span> values) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-30" title="30">        vertex <span class="op">+=</span> j <span class="op">+</span> <span class="st">&#39; &#39;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-31" title="31">      <span class="op">}</span></a>
<a class="sourceLine" id="cb2-32" title="32">      <span class="va">console</span>.<span class="at">log</span>(i <span class="op">+</span> <span class="st">&#39; -&gt; &#39;</span> <span class="op">+</span> vertex)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-33" title="33">    <span class="op">}</span></a>
<a class="sourceLine" id="cb2-34" title="34">  <span class="op">}</span></a>
<a class="sourceLine" id="cb2-35" title="35"></a>
<a class="sourceLine" id="cb2-36" title="36">  <span class="co">/**</span></a>
<a class="sourceLine" id="cb2-37" title="37"><span class="co">   * Prints the Breadth first traversal of the graph from source.</span></a>
<a class="sourceLine" id="cb2-38" title="38"><span class="co">   *</span></a>
<a class="sourceLine" id="cb2-39" title="39"><span class="co">   * </span><span class="an">@param</span><span class="co"> </span><span class="cv">{number}</span><span class="co"> source The source vertex to start BFS.</span></a>
<a class="sourceLine" id="cb2-40" title="40"><span class="co">   */</span></a>
<a class="sourceLine" id="cb2-41" title="41">  <span class="at">bfs</span>(source) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-42" title="42">    <span class="kw">const</span> queue <span class="op">=</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb2-43" title="43">    <span class="kw">const</span> visited <span class="op">=</span> <span class="kw">new</span> <span class="at">Set</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb2-44" title="44">    <span class="va">queue</span>.<span class="at">unshift</span>([source<span class="op">,</span> <span class="dv">0</span>])<span class="op">;</span> <span class="co">// level of source is 0</span></a>
<a class="sourceLine" id="cb2-45" title="45">    <span class="va">visited</span>.<span class="at">add</span>(source)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-46" title="46">    <span class="cf">while</span> (<span class="va">queue</span>.<span class="at">length</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-47" title="47">      <span class="kw">const</span> front <span class="op">=</span> queue[<span class="dv">0</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb2-48" title="48">      <span class="kw">const</span> node <span class="op">=</span> front[<span class="dv">0</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb2-49" title="49">      <span class="kw">const</span> level <span class="op">=</span> front[<span class="dv">1</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb2-50" title="50">      <span class="va">queue</span>.<span class="at">shift</span>()<span class="op">;</span> <span class="co">// remove the front of the queue</span></a>
<a class="sourceLine" id="cb2-51" title="51">      <span class="va">console</span>.<span class="at">log</span>(<span class="vs">`Visited node </span><span class="sc">${</span>node<span class="sc">}</span><span class="vs"> at level </span><span class="sc">${</span>level<span class="sc">}</span><span class="vs">.`</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-52" title="52">      <span class="cf">for</span> (<span class="kw">const</span> next <span class="kw">of</span> <span class="kw">this</span>.<span class="at">adjacencyMap</span>[node]) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-53" title="53">        <span class="cf">if</span> (<span class="op">!</span><span class="va">visited</span>.<span class="at">has</span>(next)) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-54" title="54">          <span class="co">// not visited</span></a>
<a class="sourceLine" id="cb2-55" title="55">          <span class="va">queue</span>.<span class="at">unshift</span>([next<span class="op">,</span> level <span class="op">+</span> <span class="dv">1</span>])<span class="op">;</span> <span class="co">// level 1 more than current</span></a>
<a class="sourceLine" id="cb2-56" title="56">          <span class="va">visited</span>.<span class="at">add</span>(next)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-57" title="57">        <span class="op">}</span></a>
<a class="sourceLine" id="cb2-58" title="58">      <span class="op">}</span></a>
<a class="sourceLine" id="cb2-59" title="59">    <span class="op">}</span></a>
<a class="sourceLine" id="cb2-60" title="60">  <span class="op">}</span></a>
<a class="sourceLine" id="cb2-61" title="61"><span class="op">}</span></a>
<a class="sourceLine" id="cb2-62" title="62"></a>
<a class="sourceLine" id="cb2-63" title="63"><span class="kw">const</span> example <span class="op">=</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-64" title="64">  <span class="kw">const</span> g <span class="op">=</span> <span class="kw">new</span> <span class="at">Graph</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb2-65" title="65">  <span class="va">g</span>.<span class="at">addVertex</span>(<span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-66" title="66">  <span class="va">g</span>.<span class="at">addVertex</span>(<span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-67" title="67">  <span class="va">g</span>.<span class="at">addVertex</span>(<span class="dv">3</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-68" title="68">  <span class="va">g</span>.<span class="at">addVertex</span>(<span class="dv">4</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-69" title="69">  <span class="va">g</span>.<span class="at">addVertex</span>(<span class="dv">5</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-70" title="70">  <span class="va">g</span>.<span class="at">addEdge</span>(<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-71" title="71">  <span class="va">g</span>.<span class="at">addEdge</span>(<span class="dv">1</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-72" title="72">  <span class="va">g</span>.<span class="at">addEdge</span>(<span class="dv">2</span><span class="op">,</span> <span class="dv">4</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-73" title="73">  <span class="va">g</span>.<span class="at">addEdge</span>(<span class="dv">2</span><span class="op">,</span> <span class="dv">5</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-74" title="74">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Printing the adjacency list:</span><span class="sc">\n</span><span class="st">&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-75" title="75">  <span class="va">g</span>.<span class="at">printGraph</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb2-76" title="76"></a>
<a class="sourceLine" id="cb2-77" title="77">  <span class="co">// perform a breadth first search</span></a>
<a class="sourceLine" id="cb2-78" title="78">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;</span><span class="sc">\n</span><span class="st">Breadth first search at node 1:</span><span class="sc">\n</span><span class="st">&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-79" title="79">  <span class="va">g</span>.<span class="at">bfs</span>(<span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-80" title="80"><span class="op">};</span></a>
<a class="sourceLine" id="cb2-81" title="81"><span class="at">example</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb2-82" title="82"></a>
<a class="sourceLine" id="cb2-83" title="83"><span class="co">//OUTPUT:</span></a>
<a class="sourceLine" id="cb2-84" title="84"><span class="co">/*</span></a>
<a class="sourceLine" id="cb2-85" title="85"></a>
<a class="sourceLine" id="cb2-86" title="86"></a>
<a class="sourceLine" id="cb2-87" title="87"></a>
<a class="sourceLine" id="cb2-88" title="88"><span class="co">[Running] node &quot;c:\Users\bryan\Downloads\TOM_L\Javascript\Data-Structures\Graph\tempCodeRunnerFile.js&quot;</span></a>
<a class="sourceLine" id="cb2-89" title="89"><span class="co">Printing the adjacency list:</span></a>
<a class="sourceLine" id="cb2-90" title="90"></a>
<a class="sourceLine" id="cb2-91" title="91"><span class="co">1 -&gt; 2 3 </span></a>
<a class="sourceLine" id="cb2-92" title="92"><span class="co">2 -&gt; 1 4 5 </span></a>
<a class="sourceLine" id="cb2-93" title="93"><span class="co">3 -&gt; 1 </span></a>
<a class="sourceLine" id="cb2-94" title="94"><span class="co">4 -&gt; 2 </span></a>
<a class="sourceLine" id="cb2-95" title="95"><span class="co">5 -&gt; 2 </span></a>
<a class="sourceLine" id="cb2-96" title="96"></a>
<a class="sourceLine" id="cb2-97" title="97"><span class="co">Breadth first search at node 1:</span></a>
<a class="sourceLine" id="cb2-98" title="98"></a>
<a class="sourceLine" id="cb2-99" title="99"><span class="co">Visited node 1 at level 0.</span></a>
<a class="sourceLine" id="cb2-100" title="100"><span class="co">Visited node 3 at level 1.</span></a>
<a class="sourceLine" id="cb2-101" title="101"><span class="co">Visited node 2 at level 1.</span></a>
<a class="sourceLine" id="cb2-102" title="102"><span class="co">Visited node 5 at level 2.</span></a>
<a class="sourceLine" id="cb2-103" title="103"><span class="co">Visited node 4 at level 2.</span></a>
<a class="sourceLine" id="cb2-104" title="104"></a>
<a class="sourceLine" id="cb2-105" title="105"><span class="co">*/</span></a></code></pre>
    </div>
    <p>{% endtab %}</p>
    <p>{% tab title=“Graph2.js” %}</p>
    <div class="sourceCode" id="cb3">
      <pre
        class="sourceCode javascript"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="co">// create a graph class</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">class</span> Graph <span class="op">{</span></a>
<a class="sourceLine" id="cb3-3" title="3">  <span class="co">// defining vertex array and</span></a>
<a class="sourceLine" id="cb3-4" title="4">  <span class="co">// adjacent list</span></a>
<a class="sourceLine" id="cb3-5" title="5">  <span class="at">constructor</span>(noOfVertices) <span class="op">{</span></a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="kw">this</span>.<span class="at">noOfVertices</span> <span class="op">=</span> noOfVertices<span class="op">;</span></a>
<a class="sourceLine" id="cb3-7" title="7">    <span class="kw">this</span>.<span class="at">AdjList</span> <span class="op">=</span> <span class="kw">new</span> <span class="at">Map</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb3-8" title="8">  <span class="op">}</span></a>
<a class="sourceLine" id="cb3-9" title="9"></a>
<a class="sourceLine" id="cb3-10" title="10">  <span class="co">// functions to be implemented</span></a>
<a class="sourceLine" id="cb3-11" title="11"></a>
<a class="sourceLine" id="cb3-12" title="12">  <span class="co">// addVertex(v)</span></a>
<a class="sourceLine" id="cb3-13" title="13">  <span class="co">// addEdge(v, w)</span></a>
<a class="sourceLine" id="cb3-14" title="14">  <span class="co">// printGraph()</span></a>
<a class="sourceLine" id="cb3-15" title="15"></a>
<a class="sourceLine" id="cb3-16" title="16">  <span class="co">// bfs(v)</span></a>
<a class="sourceLine" id="cb3-17" title="17">  <span class="co">// dfs(v)</span></a>
<a class="sourceLine" id="cb3-18" title="18"></a>
<a class="sourceLine" id="cb3-19" title="19">  <span class="co">// add vertex to the graph</span></a>
<a class="sourceLine" id="cb3-20" title="20">  <span class="at">addVertex</span>(v) <span class="op">{</span></a>
<a class="sourceLine" id="cb3-21" title="21">    <span class="co">// initialize the adjacent list with a</span></a>
<a class="sourceLine" id="cb3-22" title="22">    <span class="co">// null array</span></a>
<a class="sourceLine" id="cb3-23" title="23"></a>
<a class="sourceLine" id="cb3-24" title="24">    <span class="kw">this</span>.<span class="va">AdjList</span>.<span class="at">set</span>(v<span class="op">,</span> [])<span class="op">;</span></a>
<a class="sourceLine" id="cb3-25" title="25">  <span class="op">}</span></a>
<a class="sourceLine" id="cb3-26" title="26"></a>
<a class="sourceLine" id="cb3-27" title="27">  <span class="co">// add edge to the graph</span></a>
<a class="sourceLine" id="cb3-28" title="28">  <span class="at">addEdge</span>(v<span class="op">,</span> w) <span class="op">{</span></a>
<a class="sourceLine" id="cb3-29" title="29">    <span class="co">// get the list for vertex v and put the</span></a>
<a class="sourceLine" id="cb3-30" title="30">    <span class="co">// vertex w denoting edge between v and w</span></a>
<a class="sourceLine" id="cb3-31" title="31">    <span class="kw">this</span>.<span class="va">AdjList</span>.<span class="at">get</span>(v).<span class="at">push</span>(w)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-32" title="32"></a>
<a class="sourceLine" id="cb3-33" title="33">    <span class="co">// Since graph is undirected,</span></a>
<a class="sourceLine" id="cb3-34" title="34">    <span class="co">// add an edge from w to v also</span></a>
<a class="sourceLine" id="cb3-35" title="35">    <span class="kw">this</span>.<span class="va">AdjList</span>.<span class="at">get</span>(w).<span class="at">push</span>(v)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-36" title="36">  <span class="op">}</span></a>
<a class="sourceLine" id="cb3-37" title="37"></a>
<a class="sourceLine" id="cb3-38" title="38">  <span class="co">// Prints the vertex and adjacency list</span></a>
<a class="sourceLine" id="cb3-39" title="39">  <span class="at">printGraph</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb3-40" title="40">    <span class="co">// get all the vertices</span></a>
<a class="sourceLine" id="cb3-41" title="41">    <span class="kw">const</span> getKeys <span class="op">=</span> <span class="kw">this</span>.<span class="va">AdjList</span>.<span class="at">keys</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb3-42" title="42"></a>
<a class="sourceLine" id="cb3-43" title="43">    <span class="co">// iterate over the vertices</span></a>
<a class="sourceLine" id="cb3-44" title="44">    <span class="cf">for</span> (<span class="kw">const</span> i <span class="kw">of</span> getKeys) <span class="op">{</span></a>
<a class="sourceLine" id="cb3-45" title="45">      <span class="co">// great the corresponding adjacency list</span></a>
<a class="sourceLine" id="cb3-46" title="46">      <span class="co">// for the vertex</span></a>
<a class="sourceLine" id="cb3-47" title="47">      <span class="kw">const</span> getValues <span class="op">=</span> <span class="kw">this</span>.<span class="va">AdjList</span>.<span class="at">get</span>(i)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-48" title="48">      <span class="kw">let</span> conc <span class="op">=</span> <span class="st">&#39;&#39;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb3-49" title="49"></a>
<a class="sourceLine" id="cb3-50" title="50">      <span class="co">// iterate over the adjacency list</span></a>
<a class="sourceLine" id="cb3-51" title="51">      <span class="co">// concatenate the values into a string</span></a>
<a class="sourceLine" id="cb3-52" title="52">      <span class="cf">for</span> (<span class="kw">const</span> j <span class="kw">of</span> getValues) <span class="op">{</span></a>
<a class="sourceLine" id="cb3-53" title="53">        conc <span class="op">+=</span> j <span class="op">+</span> <span class="st">&#39; &#39;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb3-54" title="54">      <span class="op">}</span></a>
<a class="sourceLine" id="cb3-55" title="55"></a>
<a class="sourceLine" id="cb3-56" title="56">      <span class="co">// print the vertex and its adjacency list</span></a>
<a class="sourceLine" id="cb3-57" title="57">      <span class="va">console</span>.<span class="at">log</span>(i <span class="op">+</span> <span class="st">&#39; -&gt; &#39;</span> <span class="op">+</span> conc)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-58" title="58">    <span class="op">}</span></a>
<a class="sourceLine" id="cb3-59" title="59">  <span class="op">}</span></a>
<a class="sourceLine" id="cb3-60" title="60"><span class="op">}</span></a>
<a class="sourceLine" id="cb3-61" title="61"><span class="co">// Example</span></a>
<a class="sourceLine" id="cb3-62" title="62"><span class="kw">const</span> graph <span class="op">=</span> <span class="kw">new</span> <span class="at">Graph</span>(<span class="dv">6</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-63" title="63"><span class="kw">const</span> vertices <span class="op">=</span> [<span class="st">&#39;A&#39;</span><span class="op">,</span> <span class="st">&#39;B&#39;</span><span class="op">,</span> <span class="st">&#39;C&#39;</span><span class="op">,</span> <span class="st">&#39;D&#39;</span><span class="op">,</span> <span class="st">&#39;E&#39;</span><span class="op">,</span> <span class="st">&#39;F&#39;</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb3-64" title="64"></a>
<a class="sourceLine" id="cb3-65" title="65"><span class="co">// adding vertices</span></a>
<a class="sourceLine" id="cb3-66" title="66"><span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">vertices</span>.<span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb3-67" title="67">  <span class="va">graph</span>.<span class="at">addVertex</span>(vertices[i])<span class="op">;</span></a>
<a class="sourceLine" id="cb3-68" title="68"><span class="op">}</span></a>
<a class="sourceLine" id="cb3-69" title="69"></a>
<a class="sourceLine" id="cb3-70" title="70"><span class="co">// adding edges</span></a>
<a class="sourceLine" id="cb3-71" title="71"><span class="va">graph</span>.<span class="at">addEdge</span>(<span class="st">&#39;A&#39;</span><span class="op">,</span> <span class="st">&#39;B&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-72" title="72"><span class="va">graph</span>.<span class="at">addEdge</span>(<span class="st">&#39;A&#39;</span><span class="op">,</span> <span class="st">&#39;D&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-73" title="73"><span class="va">graph</span>.<span class="at">addEdge</span>(<span class="st">&#39;A&#39;</span><span class="op">,</span> <span class="st">&#39;E&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-74" title="74"><span class="va">graph</span>.<span class="at">addEdge</span>(<span class="st">&#39;B&#39;</span><span class="op">,</span> <span class="st">&#39;C&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-75" title="75"><span class="va">graph</span>.<span class="at">addEdge</span>(<span class="st">&#39;D&#39;</span><span class="op">,</span> <span class="st">&#39;E&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-76" title="76"><span class="va">graph</span>.<span class="at">addEdge</span>(<span class="st">&#39;E&#39;</span><span class="op">,</span> <span class="st">&#39;F&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-77" title="77"><span class="va">graph</span>.<span class="at">addEdge</span>(<span class="st">&#39;E&#39;</span><span class="op">,</span> <span class="st">&#39;C&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-78" title="78"><span class="va">graph</span>.<span class="at">addEdge</span>(<span class="st">&#39;C&#39;</span><span class="op">,</span> <span class="st">&#39;F&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-79" title="79"></a>
<a class="sourceLine" id="cb3-80" title="80"><span class="co">// prints all vertex and</span></a>
<a class="sourceLine" id="cb3-81" title="81"><span class="co">// its adjacency list</span></a>
<a class="sourceLine" id="cb3-82" title="82"><span class="co">// A -&gt; B D E</span></a>
<a class="sourceLine" id="cb3-83" title="83"><span class="co">// B -&gt; A C</span></a>
<a class="sourceLine" id="cb3-84" title="84"><span class="co">// C -&gt; B E F</span></a>
<a class="sourceLine" id="cb3-85" title="85"><span class="co">// D -&gt; A E</span></a>
<a class="sourceLine" id="cb3-86" title="86"><span class="co">// E -&gt; A D F C</span></a>
<a class="sourceLine" id="cb3-87" title="87"><span class="co">// F -&gt; E C</span></a>
<a class="sourceLine" id="cb3-88" title="88"><span class="va">graph</span>.<span class="at">printGraph</span>()<span class="op">;</span></a></code></pre>
    </div>
    <p>{% endtab %} {% endtabs %}</p>
    <h2 id="graph">Graph</h2>
    <ul>
      <li>
        Given a list of sorted words from an alien dictionary, find the order of
        the alphabet.
        <ul>
          <li>Alien Dictionary Topological Sort question.</li>
        </ul>
      </li>
      <li>
        Find if a given string matches any path in a labeled graph. A path may
        contain cycles.
      </li>
      <li>Given a bipartite graph, separate the vertices into two sets.</li>
      <li>
        You are a thief trying to sneak across a rectangular 100 x 100m field.
        There are alarms placed on the fields and they each have a circular
        sensing radius which will trigger if anyone steps into it. Each alarm
        has its own radius. Determine if you can get from one end of the field
        to the other end.
      </li>
      <li>
        Given a graph and two nodes, determine if there exists a path between
        them.
      </li>
      <li>Determine if a cycle exists in the graph.</li>
    </ul>
    <p>{% tabs %} {% tab title=“Directed Graph:” %}</p>
    <h2 id="directed-graph">Directed Graph:</h2>
    <div class="sourceCode" id="cb4">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">class</span> Node(<span class="bu">object</span>):</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, value):</a>
<a class="sourceLine" id="cb4-3" title="3">        <span class="va">self</span>.value <span class="op">=</span> value</a>
<a class="sourceLine" id="cb4-4" title="4">        <span class="va">self</span>.edges <span class="op">=</span> []</a>
<a class="sourceLine" id="cb4-5" title="5"></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="kw">class</span> Edge(<span class="bu">object</span>):</a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, value, node_from, node_to):</a>
<a class="sourceLine" id="cb4-8" title="8">        <span class="va">self</span>.value <span class="op">=</span> value</a>
<a class="sourceLine" id="cb4-9" title="9">        <span class="va">self</span>.node_from <span class="op">=</span> node_from</a>
<a class="sourceLine" id="cb4-10" title="10">        <span class="va">self</span>.node_to <span class="op">=</span> node_to</a>
<a class="sourceLine" id="cb4-11" title="11"></a>
<a class="sourceLine" id="cb4-12" title="12"><span class="kw">class</span> Graph(<span class="bu">object</span>):</a>
<a class="sourceLine" id="cb4-13" title="13">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, nodes<span class="op">=</span>[], edges<span class="op">=</span>[]):</a>
<a class="sourceLine" id="cb4-14" title="14">        <span class="va">self</span>.nodes <span class="op">=</span> nodes</a>
<a class="sourceLine" id="cb4-15" title="15">        <span class="va">self</span>.edges <span class="op">=</span> edges</a>
<a class="sourceLine" id="cb4-16" title="16"></a>
<a class="sourceLine" id="cb4-17" title="17">    <span class="kw">def</span> insert_node(<span class="va">self</span>, new_node_val):</a>
<a class="sourceLine" id="cb4-18" title="18">        new_node <span class="op">=</span> Node(new_node_val)</a>
<a class="sourceLine" id="cb4-19" title="19">        <span class="va">self</span>.nodes.append(new_node)</a>
<a class="sourceLine" id="cb4-20" title="20"></a>
<a class="sourceLine" id="cb4-21" title="21">    <span class="kw">def</span> insert_edge(<span class="va">self</span>, new_edge_val, node_from_val, node_to_val):</a>
<a class="sourceLine" id="cb4-22" title="22">        from_found <span class="op">=</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb4-23" title="23">        to_found <span class="op">=</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb4-24" title="24">        <span class="cf">for</span> node <span class="kw">in</span> <span class="va">self</span>.nodes:</a>
<a class="sourceLine" id="cb4-25" title="25">            <span class="cf">if</span> node_from_val <span class="op">==</span> node.value:</a>
<a class="sourceLine" id="cb4-26" title="26">                from_found <span class="op">=</span> node</a>
<a class="sourceLine" id="cb4-27" title="27">            <span class="cf">if</span> node_to_val <span class="op">==</span> node.value:</a>
<a class="sourceLine" id="cb4-28" title="28">                to_found <span class="op">=</span> node</a>
<a class="sourceLine" id="cb4-29" title="29">        <span class="cf">if</span> from_found <span class="op">==</span> <span class="va">None</span>:</a>
<a class="sourceLine" id="cb4-30" title="30">            from_found <span class="op">=</span> Node(node_from_val)</a>
<a class="sourceLine" id="cb4-31" title="31">            <span class="va">self</span>.nodes.append(from_found)</a>
<a class="sourceLine" id="cb4-32" title="32">        <span class="cf">if</span> to_found <span class="op">==</span> <span class="va">None</span>:</a>
<a class="sourceLine" id="cb4-33" title="33">            to_found <span class="op">=</span> Node(node_to_val)</a>
<a class="sourceLine" id="cb4-34" title="34">            <span class="va">self</span>.nodes.append(to_found)</a>
<a class="sourceLine" id="cb4-35" title="35">        new_edge <span class="op">=</span> Edge(new_edge_val, from_found, to_found)</a>
<a class="sourceLine" id="cb4-36" title="36">        from_found.edges.append(new_edge)</a>
<a class="sourceLine" id="cb4-37" title="37">        to_found.edges.append(new_edge)</a>
<a class="sourceLine" id="cb4-38" title="38">        <span class="va">self</span>.edges.append(new_edge)</a>
<a class="sourceLine" id="cb4-39" title="39"></a>
<a class="sourceLine" id="cb4-40" title="40">    <span class="kw">def</span> get_edge_list(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb4-41" title="41">        <span class="co">&quot;&quot;&quot;Don&#39;t return a list of edge objects!</span></a>
<a class="sourceLine" id="cb4-42" title="42"><span class="co">        Return a list of triples that looks like this:</span></a>
<a class="sourceLine" id="cb4-43" title="43"><span class="co">        (Edge Value, From Node Value, To Node Value)&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb4-44" title="44">        edge_list <span class="op">=</span> []</a>
<a class="sourceLine" id="cb4-45" title="45">        <span class="cf">for</span> item <span class="kw">in</span> <span class="va">self</span>.nodes:</a>
<a class="sourceLine" id="cb4-46" title="46">            <span class="cf">for</span> each_edge <span class="kw">in</span> item.edges:</a>
<a class="sourceLine" id="cb4-47" title="47">                edge_tuple <span class="op">=</span> (each_edge.value, each_edge.node_from.value, each_edge.node_to.value)</a>
<a class="sourceLine" id="cb4-48" title="48">                <span class="cf">if</span> edge_tuple <span class="kw">not</span> <span class="kw">in</span> edge_list:</a>
<a class="sourceLine" id="cb4-49" title="49">                    edge_list.append(edge_tuple)</a>
<a class="sourceLine" id="cb4-50" title="50">        <span class="cf">return</span> edge_list</a>
<a class="sourceLine" id="cb4-51" title="51"></a>
<a class="sourceLine" id="cb4-52" title="52">    <span class="kw">def</span> get_adjacency_list(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb4-53" title="53">        <span class="co">&quot;&quot;&quot;Don&#39;t return any Node or Edge objects!</span></a>
<a class="sourceLine" id="cb4-54" title="54"><span class="co">        You&#39;ll return a list of lists.</span></a>
<a class="sourceLine" id="cb4-55" title="55"><span class="co">        The indices of the outer list represent</span></a>
<a class="sourceLine" id="cb4-56" title="56"><span class="co">        &quot;from&quot; nodes.</span></a>
<a class="sourceLine" id="cb4-57" title="57"><span class="co">        Each section in the list will store a list</span></a>
<a class="sourceLine" id="cb4-58" title="58"><span class="co">        of tuples that looks like this:</span></a>
<a class="sourceLine" id="cb4-59" title="59"><span class="co">        (To Node, Edge Value)&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb4-60" title="60">        adjacency_list <span class="op">=</span> []</a>
<a class="sourceLine" id="cb4-61" title="61">        edge_list <span class="op">=</span> <span class="va">self</span>.get_edge_list()</a>
<a class="sourceLine" id="cb4-62" title="62">        max_node_val <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb4-63" title="63">        <span class="cf">for</span> <span class="bu">tuple</span> <span class="kw">in</span> edge_list:</a>
<a class="sourceLine" id="cb4-64" title="64">            <span class="cf">if</span>(max_node_val<span class="op">&lt;</span><span class="bu">tuple</span>[<span class="dv">1</span>]):</a>
<a class="sourceLine" id="cb4-65" title="65">                max_node_val <span class="op">=</span> <span class="bu">tuple</span>[<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb4-66" title="66">            <span class="cf">if</span>(max_node_val<span class="op">&lt;</span><span class="bu">tuple</span>[<span class="dv">2</span>]):</a>
<a class="sourceLine" id="cb4-67" title="67">                max_node_val <span class="op">=</span> <span class="bu">tuple</span>[<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb4-68" title="68"></a>
<a class="sourceLine" id="cb4-69" title="69">        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(max_node_val<span class="op">+</span><span class="dv">1</span>):</a>
<a class="sourceLine" id="cb4-70" title="70">            node_list <span class="op">=</span> []</a>
<a class="sourceLine" id="cb4-71" title="71">            <span class="cf">for</span> item <span class="kw">in</span> edge_list:</a>
<a class="sourceLine" id="cb4-72" title="72">                <span class="cf">if</span>(i<span class="op">==</span>item[<span class="dv">1</span>]):</a>
<a class="sourceLine" id="cb4-73" title="73">                    new_tuple <span class="op">=</span> (item[<span class="dv">2</span>], item[<span class="dv">0</span>])</a>
<a class="sourceLine" id="cb4-74" title="74">                    node_list.append(new_tuple)</a>
<a class="sourceLine" id="cb4-75" title="75">            <span class="cf">if</span>(node_list<span class="op">!=</span>[]):</a>
<a class="sourceLine" id="cb4-76" title="76">                adjacency_list.append(node_list)</a>
<a class="sourceLine" id="cb4-77" title="77">            <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb4-78" title="78">                adjacency_list.append(<span class="va">None</span>)</a>
<a class="sourceLine" id="cb4-79" title="79"></a>
<a class="sourceLine" id="cb4-80" title="80">        <span class="cf">return</span> adjacency_list</a>
<a class="sourceLine" id="cb4-81" title="81"></a>
<a class="sourceLine" id="cb4-82" title="82">    <span class="kw">def</span> get_adjacency_matrix(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb4-83" title="83">        <span class="co">&quot;&quot;&quot;Return a matrix, or 2D list.</span></a>
<a class="sourceLine" id="cb4-84" title="84"><span class="co">        Row numbers represent from nodes,</span></a>
<a class="sourceLine" id="cb4-85" title="85"><span class="co">        column numbers represent to nodes.</span></a>
<a class="sourceLine" id="cb4-86" title="86"><span class="co">        Store the edge values in each spot,</span></a>
<a class="sourceLine" id="cb4-87" title="87"><span class="co">        and a 0 if no edge exists.&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb4-88" title="88">        adjacency_matrix <span class="op">=</span> []</a>
<a class="sourceLine" id="cb4-89" title="89">        adjacency_list <span class="op">=</span> <span class="va">self</span>.get_adjacency_list()</a>
<a class="sourceLine" id="cb4-90" title="90">        max_node_val <span class="op">=</span> <span class="bu">len</span>(adjacency_list)</a>
<a class="sourceLine" id="cb4-91" title="91"></a>
<a class="sourceLine" id="cb4-92" title="92">        <span class="cf">for</span> item <span class="kw">in</span> adjacency_list:</a>
<a class="sourceLine" id="cb4-93" title="93">            node_list <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>(max_node_val)</a>
<a class="sourceLine" id="cb4-94" title="94">            <span class="cf">if</span>(item<span class="op">!=</span><span class="va">None</span>):</a>
<a class="sourceLine" id="cb4-95" title="95">                <span class="cf">for</span> <span class="bu">tuple</span> <span class="kw">in</span> item:</a>
<a class="sourceLine" id="cb4-96" title="96">                    node_list[<span class="bu">tuple</span>[<span class="dv">0</span>]]<span class="op">=</span><span class="bu">tuple</span>[<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb4-97" title="97">            adjacency_matrix.append(node_list)</a>
<a class="sourceLine" id="cb4-98" title="98">        <span class="cf">return</span> adjacency_matrix</a>
<a class="sourceLine" id="cb4-99" title="99"></a>
<a class="sourceLine" id="cb4-100" title="100">graph <span class="op">=</span> Graph()</a>
<a class="sourceLine" id="cb4-101" title="101">graph.insert_edge(<span class="dv">100</span>, <span class="dv">1</span>, <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb4-102" title="102">graph.insert_edge(<span class="dv">101</span>, <span class="dv">1</span>, <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb4-103" title="103">graph.insert_edge(<span class="dv">102</span>, <span class="dv">1</span>, <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb4-104" title="104">graph.insert_edge(<span class="dv">103</span>, <span class="dv">3</span>, <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb4-105" title="105"><span class="co"># Should be [(100, 1, 2), (101, 1, 3), (102, 1, 4), (103, 3, 4)]</span></a>
<a class="sourceLine" id="cb4-106" title="106"><span class="bu">print</span>(graph.get_edge_list())</a>
<a class="sourceLine" id="cb4-107" title="107"><span class="co"># Should be [None, [(2, 100), (3, 101), (4, 102)], None, [(4, 103)], None]</span></a>
<a class="sourceLine" id="cb4-108" title="108"><span class="bu">print</span>(graph.get_adjacency_list())</a>
<a class="sourceLine" id="cb4-109" title="109"><span class="co"># Should be [[0, 0, 0, 0, 0], [0, 0, 100, 101, 102], [0, 0, 0, 0, 0], [0, 0, 0, 0, 103], [0, 0, 0, 0, 0]]</span></a>
<a class="sourceLine" id="cb4-110" title="110"><span class="bu">print</span>(graph.get_adjacency_matrix())</a></code></pre>
    </div>
    <p>{% endtab %}</p>
    <p>{% tab title=“Graph Traversal” %}</p>
    <div class="sourceCode" id="cb5">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">class</span> Node(<span class="bu">object</span>):</a>
<a class="sourceLine" id="cb5-2" title="2">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, value):</a>
<a class="sourceLine" id="cb5-3" title="3">        <span class="va">self</span>.value <span class="op">=</span> value</a>
<a class="sourceLine" id="cb5-4" title="4">        <span class="va">self</span>.edges <span class="op">=</span> []</a>
<a class="sourceLine" id="cb5-5" title="5">        <span class="va">self</span>.visited <span class="op">=</span> <span class="va">False</span></a>
<a class="sourceLine" id="cb5-6" title="6"></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="kw">class</span> Edge(<span class="bu">object</span>):</a>
<a class="sourceLine" id="cb5-8" title="8">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, value, node_from, node_to):</a>
<a class="sourceLine" id="cb5-9" title="9">        <span class="va">self</span>.value <span class="op">=</span> value</a>
<a class="sourceLine" id="cb5-10" title="10">        <span class="va">self</span>.node_from <span class="op">=</span> node_from</a>
<a class="sourceLine" id="cb5-11" title="11">        <span class="va">self</span>.node_to <span class="op">=</span> node_to</a>
<a class="sourceLine" id="cb5-12" title="12"></a>
<a class="sourceLine" id="cb5-13" title="13"><span class="co"># You only need to change code with docs strings that have </span><span class="al">TODO</span><span class="co">.</span></a>
<a class="sourceLine" id="cb5-14" title="14"><span class="co"># Specifically: Graph.dfs_helper and Graph.bfs</span></a>
<a class="sourceLine" id="cb5-15" title="15"><span class="co"># New methods have been added to associate node numbers with names</span></a>
<a class="sourceLine" id="cb5-16" title="16"><span class="co"># Specifically: Graph.set_node_names</span></a>
<a class="sourceLine" id="cb5-17" title="17"><span class="co"># and the methods ending in &quot;_names&quot; which will print names instead</span></a>
<a class="sourceLine" id="cb5-18" title="18"><span class="co"># of node numbers</span></a>
<a class="sourceLine" id="cb5-19" title="19"></a>
<a class="sourceLine" id="cb5-20" title="20"><span class="kw">class</span> Graph(<span class="bu">object</span>):</a>
<a class="sourceLine" id="cb5-21" title="21">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, nodes<span class="op">=</span><span class="va">None</span>, edges<span class="op">=</span><span class="va">None</span>):</a>
<a class="sourceLine" id="cb5-22" title="22">        <span class="va">self</span>.nodes <span class="op">=</span> nodes <span class="kw">or</span> []</a>
<a class="sourceLine" id="cb5-23" title="23">        <span class="va">self</span>.edges <span class="op">=</span> edges <span class="kw">or</span> []</a>
<a class="sourceLine" id="cb5-24" title="24">        <span class="va">self</span>.node_names <span class="op">=</span> []</a>
<a class="sourceLine" id="cb5-25" title="25">        <span class="va">self</span>._node_map <span class="op">=</span> {}</a>
<a class="sourceLine" id="cb5-26" title="26"></a>
<a class="sourceLine" id="cb5-27" title="27">    <span class="kw">def</span> set_node_names(<span class="va">self</span>, names):</a>
<a class="sourceLine" id="cb5-28" title="28">        <span class="co">&quot;&quot;&quot;The Nth name in names should correspond to node number N.</span></a>
<a class="sourceLine" id="cb5-29" title="29"><span class="co">        Node numbers are 0 based (starting at 0).</span></a>
<a class="sourceLine" id="cb5-30" title="30"><span class="co">        &quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb5-31" title="31">        <span class="va">self</span>.node_names <span class="op">=</span> <span class="bu">list</span>(names)</a>
<a class="sourceLine" id="cb5-32" title="32"></a>
<a class="sourceLine" id="cb5-33" title="33">    <span class="kw">def</span> insert_node(<span class="va">self</span>, new_node_val):</a>
<a class="sourceLine" id="cb5-34" title="34">        <span class="co">&quot;Insert a new node with value new_node_val&quot;</span></a>
<a class="sourceLine" id="cb5-35" title="35">        new_node <span class="op">=</span> Node(new_node_val)</a>
<a class="sourceLine" id="cb5-36" title="36">        <span class="va">self</span>.nodes.append(new_node)</a>
<a class="sourceLine" id="cb5-37" title="37">        <span class="va">self</span>._node_map[new_node_val] <span class="op">=</span> new_node</a>
<a class="sourceLine" id="cb5-38" title="38">        <span class="cf">return</span> new_node</a>
<a class="sourceLine" id="cb5-39" title="39"></a>
<a class="sourceLine" id="cb5-40" title="40">    <span class="kw">def</span> insert_edge(<span class="va">self</span>, new_edge_val, node_from_val, node_to_val):</a>
<a class="sourceLine" id="cb5-41" title="41">        <span class="co">&quot;Insert a new edge, creating new nodes if necessary&quot;</span></a>
<a class="sourceLine" id="cb5-42" title="42">        nodes <span class="op">=</span> {node_from_val: <span class="va">None</span>, node_to_val: <span class="va">None</span>}</a>
<a class="sourceLine" id="cb5-43" title="43">        <span class="cf">for</span> node <span class="kw">in</span> <span class="va">self</span>.nodes:</a>
<a class="sourceLine" id="cb5-44" title="44">            <span class="cf">if</span> node.value <span class="kw">in</span> nodes:</a>
<a class="sourceLine" id="cb5-45" title="45">                nodes[node.value] <span class="op">=</span> node</a>
<a class="sourceLine" id="cb5-46" title="46">                <span class="cf">if</span> <span class="bu">all</span>(nodes.values()):</a>
<a class="sourceLine" id="cb5-47" title="47">                    <span class="cf">break</span></a>
<a class="sourceLine" id="cb5-48" title="48">        <span class="cf">for</span> node_val <span class="kw">in</span> nodes:</a>
<a class="sourceLine" id="cb5-49" title="49">            nodes[node_val] <span class="op">=</span> nodes[node_val] <span class="kw">or</span> <span class="va">self</span>.insert_node(node_val)</a>
<a class="sourceLine" id="cb5-50" title="50">        node_from <span class="op">=</span> nodes[node_from_val]</a>
<a class="sourceLine" id="cb5-51" title="51">        node_to <span class="op">=</span> nodes[node_to_val]</a>
<a class="sourceLine" id="cb5-52" title="52">        new_edge <span class="op">=</span> Edge(new_edge_val, node_from, node_to)</a>
<a class="sourceLine" id="cb5-53" title="53">        node_from.edges.append(new_edge)</a>
<a class="sourceLine" id="cb5-54" title="54">        node_to.edges.append(new_edge)</a>
<a class="sourceLine" id="cb5-55" title="55">        <span class="va">self</span>.edges.append(new_edge)</a>
<a class="sourceLine" id="cb5-56" title="56"></a>
<a class="sourceLine" id="cb5-57" title="57">    <span class="kw">def</span> get_edge_list(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb5-58" title="58">        <span class="co">&quot;&quot;&quot;Return a list of triples that looks like this:</span></a>
<a class="sourceLine" id="cb5-59" title="59"><span class="co">        (Edge Value, From Node, To Node)&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb5-60" title="60">        <span class="cf">return</span> [(e.value, e.node_from.value, e.node_to.value)</a>
<a class="sourceLine" id="cb5-61" title="61">                <span class="cf">for</span> e <span class="kw">in</span> <span class="va">self</span>.edges]</a>
<a class="sourceLine" id="cb5-62" title="62"></a>
<a class="sourceLine" id="cb5-63" title="63">    <span class="kw">def</span> get_edge_list_names(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb5-64" title="64">        <span class="co">&quot;&quot;&quot;Return a list of triples that looks like this:</span></a>
<a class="sourceLine" id="cb5-65" title="65"><span class="co">        (Edge Value, From Node Name, To Node Name)&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb5-66" title="66">        <span class="cf">return</span> [(edge.value,</a>
<a class="sourceLine" id="cb5-67" title="67">                 <span class="va">self</span>.node_names[edge.node_from.value],</a>
<a class="sourceLine" id="cb5-68" title="68">                 <span class="va">self</span>.node_names[edge.node_to.value])</a>
<a class="sourceLine" id="cb5-69" title="69">                <span class="cf">for</span> edge <span class="kw">in</span> <span class="va">self</span>.edges]</a>
<a class="sourceLine" id="cb5-70" title="70"></a>
<a class="sourceLine" id="cb5-71" title="71">    <span class="kw">def</span> get_adjacency_list(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb5-72" title="72">        <span class="co">&quot;&quot;&quot;Return a list of lists.</span></a>
<a class="sourceLine" id="cb5-73" title="73"><span class="co">        The indecies of the outer list represent &quot;from&quot; nodes.</span></a>
<a class="sourceLine" id="cb5-74" title="74"><span class="co">        Each section in the list will store a list</span></a>
<a class="sourceLine" id="cb5-75" title="75"><span class="co">        of tuples that looks like this:</span></a>
<a class="sourceLine" id="cb5-76" title="76"><span class="co">        (To Node, Edge Value)&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb5-77" title="77">        max_index <span class="op">=</span> <span class="va">self</span>.find_max_index()</a>
<a class="sourceLine" id="cb5-78" title="78">        adjacency_list <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(max_index)]</a>
<a class="sourceLine" id="cb5-79" title="79">        <span class="cf">for</span> edg <span class="kw">in</span> <span class="va">self</span>.edges:</a>
<a class="sourceLine" id="cb5-80" title="80">            from_value, to_value <span class="op">=</span> edg.node_from.value, edg.node_to.value</a>
<a class="sourceLine" id="cb5-81" title="81">            adjacency_list[from_value].append((to_value, edg.value))</a>
<a class="sourceLine" id="cb5-82" title="82">        <span class="cf">return</span> [a <span class="kw">or</span> <span class="va">None</span> <span class="cf">for</span> a <span class="kw">in</span> adjacency_list] <span class="co"># replace []&#39;s with None</span></a>
<a class="sourceLine" id="cb5-83" title="83"></a>
<a class="sourceLine" id="cb5-84" title="84">    <span class="kw">def</span> get_adjacency_list_names(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb5-85" title="85">        <span class="co">&quot;&quot;&quot;Each section in the list will store a list</span></a>
<a class="sourceLine" id="cb5-86" title="86"><span class="co">        of tuples that looks like this:</span></a>
<a class="sourceLine" id="cb5-87" title="87"><span class="co">        (To Node Name, Edge Value).</span></a>
<a class="sourceLine" id="cb5-88" title="88"><span class="co">        Node names should come from the names set</span></a>
<a class="sourceLine" id="cb5-89" title="89"><span class="co">        with set_node_names.&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb5-90" title="90">        adjacency_list <span class="op">=</span> <span class="va">self</span>.get_adjacency_list()</a>
<a class="sourceLine" id="cb5-91" title="91">        <span class="kw">def</span> convert_to_names(pair, graph<span class="op">=</span><span class="va">self</span>):</a>
<a class="sourceLine" id="cb5-92" title="92">            node_number, value <span class="op">=</span> pair</a>
<a class="sourceLine" id="cb5-93" title="93">            <span class="cf">return</span> (graph.node_names[node_number], value)</a>
<a class="sourceLine" id="cb5-94" title="94">        <span class="kw">def</span> map_conversion(adjacency_list_for_node):</a>
<a class="sourceLine" id="cb5-95" title="95">            <span class="cf">if</span> adjacency_list_for_node <span class="kw">is</span> <span class="va">None</span>:</a>
<a class="sourceLine" id="cb5-96" title="96">                <span class="cf">return</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb5-97" title="97">            <span class="cf">return</span> <span class="bu">map</span>(convert_to_names, adjacency_list_for_node)</a>
<a class="sourceLine" id="cb5-98" title="98">        <span class="cf">return</span> [map_conversion(adjacency_list_for_node)</a>
<a class="sourceLine" id="cb5-99" title="99">                <span class="cf">for</span> adjacency_list_for_node <span class="kw">in</span> adjacency_list]</a>
<a class="sourceLine" id="cb5-100" title="100"></a>
<a class="sourceLine" id="cb5-101" title="101">    <span class="kw">def</span> get_adjacency_matrix(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb5-102" title="102">        <span class="co">&quot;&quot;&quot;Return a matrix, or 2D list.</span></a>
<a class="sourceLine" id="cb5-103" title="103"><span class="co">        Row numbers represent from nodes,</span></a>
<a class="sourceLine" id="cb5-104" title="104"><span class="co">        column numbers represent to nodes.</span></a>
<a class="sourceLine" id="cb5-105" title="105"><span class="co">        Store the edge values in each spot,</span></a>
<a class="sourceLine" id="cb5-106" title="106"><span class="co">        and a 0 if no edge exists.&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb5-107" title="107">        max_index <span class="op">=</span> <span class="va">self</span>.find_max_index()</a>
<a class="sourceLine" id="cb5-108" title="108">        adjacency_matrix <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (max_index) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(max_index)]</a>
<a class="sourceLine" id="cb5-109" title="109">        <span class="cf">for</span> edg <span class="kw">in</span> <span class="va">self</span>.edges:</a>
<a class="sourceLine" id="cb5-110" title="110">            from_index, to_index <span class="op">=</span> edg.node_from.value, edg.node_to.value</a>
<a class="sourceLine" id="cb5-111" title="111">            adjacency_matrix[from_index][to_index] <span class="op">=</span> edg.value</a>
<a class="sourceLine" id="cb5-112" title="112">        <span class="cf">return</span> adjacency_matrix</a>
<a class="sourceLine" id="cb5-113" title="113"></a>
<a class="sourceLine" id="cb5-114" title="114">    <span class="kw">def</span> find_max_index(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb5-115" title="115">        <span class="co">&quot;&quot;&quot;Return the highest found node number</span></a>
<a class="sourceLine" id="cb5-116" title="116"><span class="co">        Or the length of the node names if set with set_node_names().&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb5-117" title="117">        <span class="cf">if</span> <span class="bu">len</span>(<span class="va">self</span>.node_names) <span class="op">&gt;</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb5-118" title="118">            <span class="cf">return</span> <span class="bu">len</span>(<span class="va">self</span>.node_names)</a>
<a class="sourceLine" id="cb5-119" title="119">        max_index <span class="op">=</span> <span class="dv">-1</span></a>
<a class="sourceLine" id="cb5-120" title="120">        <span class="cf">if</span> <span class="bu">len</span>(<span class="va">self</span>.nodes):</a>
<a class="sourceLine" id="cb5-121" title="121">            <span class="cf">for</span> node <span class="kw">in</span> <span class="va">self</span>.nodes:</a>
<a class="sourceLine" id="cb5-122" title="122">                <span class="cf">if</span> node.value <span class="op">&gt;</span> max_index:</a>
<a class="sourceLine" id="cb5-123" title="123">                    max_index <span class="op">=</span> node.value</a>
<a class="sourceLine" id="cb5-124" title="124">        <span class="cf">return</span> max_index</a>
<a class="sourceLine" id="cb5-125" title="125"></a>
<a class="sourceLine" id="cb5-126" title="126">    <span class="kw">def</span> find_node(<span class="va">self</span>, node_number):</a>
<a class="sourceLine" id="cb5-127" title="127">        <span class="co">&quot;Return the node with value node_number or None&quot;</span></a>
<a class="sourceLine" id="cb5-128" title="128">        <span class="cf">return</span> <span class="va">self</span>._node_map.get(node_number)</a>
<a class="sourceLine" id="cb5-129" title="129"></a>
<a class="sourceLine" id="cb5-130" title="130">    <span class="kw">def</span> _clear_visited(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb5-131" title="131">        <span class="cf">for</span> node <span class="kw">in</span> <span class="va">self</span>.nodes:</a>
<a class="sourceLine" id="cb5-132" title="132">            node.visited <span class="op">=</span> <span class="va">False</span></a>
<a class="sourceLine" id="cb5-133" title="133"></a>
<a class="sourceLine" id="cb5-134" title="134">    <span class="kw">def</span> dfs_helper(<span class="va">self</span>, start_node):</a>
<a class="sourceLine" id="cb5-135" title="135">        <span class="co">&quot;&quot;&quot;TODO: Write the helper function for a recursive implementation</span></a>
<a class="sourceLine" id="cb5-136" title="136"><span class="co">        of Depth First Search iterating through a node&#39;s edges. The</span></a>
<a class="sourceLine" id="cb5-137" title="137"><span class="co">        output should be a list of numbers corresponding to the</span></a>
<a class="sourceLine" id="cb5-138" title="138"><span class="co">        values of the traversed nodes.</span></a>
<a class="sourceLine" id="cb5-139" title="139"><span class="co">        ARGUMENTS: start_node is the starting Node</span></a>
<a class="sourceLine" id="cb5-140" title="140"><span class="co">        MODIFIES: the value of the visited property of nodes in self.nodes</span></a>
<a class="sourceLine" id="cb5-141" title="141"><span class="co">        RETURN: a list of the traversed node values (integers).</span></a>
<a class="sourceLine" id="cb5-142" title="142"><span class="co">        &quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb5-143" title="143">        ret_list <span class="op">=</span> [start_node.value]</a>
<a class="sourceLine" id="cb5-144" title="144">        <span class="co"># Your code here</span></a>
<a class="sourceLine" id="cb5-145" title="145">        start_node.visited <span class="op">=</span> <span class="va">True</span></a>
<a class="sourceLine" id="cb5-146" title="146">        next_edges <span class="op">=</span> start_node.edges</a>
<a class="sourceLine" id="cb5-147" title="147">        next_vals <span class="op">=</span> []</a>
<a class="sourceLine" id="cb5-148" title="148">        <span class="cf">for</span> this_edge <span class="kw">in</span> next_edges:</a>
<a class="sourceLine" id="cb5-149" title="149">            <span class="co">#iterates through edges to find the first edge that has places not &#39;visited&#39;</span></a>
<a class="sourceLine" id="cb5-150" title="150">            <span class="cf">if</span>(this_edge.node_to.visited<span class="op">==</span><span class="va">False</span>):</a>
<a class="sourceLine" id="cb5-151" title="151">                <span class="co"># adds all places not visited along this edge to the list of nodes</span></a>
<a class="sourceLine" id="cb5-152" title="152">                <span class="co"># to be returned, using recursion</span></a>
<a class="sourceLine" id="cb5-153" title="153">                next_vals.extend(<span class="va">self</span>.dfs_helper(this_edge.node_to))</a>
<a class="sourceLine" id="cb5-154" title="154"></a>
<a class="sourceLine" id="cb5-155" title="155">        <span class="cf">if</span>(next_vals<span class="op">!=</span>[]):</a>
<a class="sourceLine" id="cb5-156" title="156">            ret_list.extend(next_vals)</a>
<a class="sourceLine" id="cb5-157" title="157">        <span class="cf">return</span> ret_list</a>
<a class="sourceLine" id="cb5-158" title="158"></a>
<a class="sourceLine" id="cb5-159" title="159">    <span class="kw">def</span> dfs(<span class="va">self</span>, start_node_num):</a>
<a class="sourceLine" id="cb5-160" title="160">        <span class="co">&quot;&quot;&quot;Outputs a list of numbers corresponding to the traversed nodes</span></a>
<a class="sourceLine" id="cb5-161" title="161"><span class="co">        in a Depth First Search.</span></a>
<a class="sourceLine" id="cb5-162" title="162"><span class="co">        ARGUMENTS: start_node_num is the starting node number (integer)</span></a>
<a class="sourceLine" id="cb5-163" title="163"><span class="co">        MODIFIES: the value of the visited property of nodes in self.nodes</span></a>
<a class="sourceLine" id="cb5-164" title="164"><span class="co">        RETURN: a list of the node values (integers).&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb5-165" title="165">        <span class="va">self</span>._clear_visited()</a>
<a class="sourceLine" id="cb5-166" title="166">        start_node <span class="op">=</span> <span class="va">self</span>.find_node(start_node_num)</a>
<a class="sourceLine" id="cb5-167" title="167">        <span class="cf">return</span> <span class="va">self</span>.dfs_helper(start_node)</a>
<a class="sourceLine" id="cb5-168" title="168"></a>
<a class="sourceLine" id="cb5-169" title="169">    <span class="kw">def</span> dfs_names(<span class="va">self</span>, start_node_num):</a>
<a class="sourceLine" id="cb5-170" title="170">        <span class="co">&quot;&quot;&quot;Return the results of dfs with numbers converted to names.&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb5-171" title="171">        <span class="cf">return</span> [<span class="va">self</span>.node_names[num] <span class="cf">for</span> num <span class="kw">in</span> <span class="va">self</span>.dfs(start_node_num)]</a>
<a class="sourceLine" id="cb5-172" title="172"></a>
<a class="sourceLine" id="cb5-173" title="173">    <span class="kw">def</span> bfs(<span class="va">self</span>, start_node_num):</a>
<a class="sourceLine" id="cb5-174" title="174">        <span class="co">&quot;&quot;&quot;TODO: Create an iterative implementation of Breadth First Search</span></a>
<a class="sourceLine" id="cb5-175" title="175"><span class="co">        iterating through a node&#39;s edges. The output should be a list of</span></a>
<a class="sourceLine" id="cb5-176" title="176"><span class="co">        numbers corresponding to the traversed nodes.</span></a>
<a class="sourceLine" id="cb5-177" title="177"><span class="co">        ARGUMENTS: start_node_num is the node number (integer)</span></a>
<a class="sourceLine" id="cb5-178" title="178"><span class="co">        MODIFIES: the value of the visited property of nodes in self.nodes</span></a>
<a class="sourceLine" id="cb5-179" title="179"><span class="co">        RETURN: a list of the node values (integers).&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb5-180" title="180">        node <span class="op">=</span> <span class="va">self</span>.find_node(start_node_num)</a>
<a class="sourceLine" id="cb5-181" title="181">        <span class="va">self</span>._clear_visited()</a>
<a class="sourceLine" id="cb5-182" title="182">        ret_list <span class="op">=</span> [node.value]</a>
<a class="sourceLine" id="cb5-183" title="183">        <span class="co"># Your code here</span></a>
<a class="sourceLine" id="cb5-184" title="184">        node.visited <span class="op">=</span> <span class="va">True</span></a>
<a class="sourceLine" id="cb5-185" title="185">        total_edges <span class="op">=</span> node.edges</a>
<a class="sourceLine" id="cb5-186" title="186">        node_queue <span class="op">=</span> [node]</a>
<a class="sourceLine" id="cb5-187" title="187"></a>
<a class="sourceLine" id="cb5-188" title="188">        <span class="cf">while</span>(node_queue<span class="op">!=</span>[]):</a>
<a class="sourceLine" id="cb5-189" title="189">            this_node <span class="op">=</span> node_queue[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb5-190" title="190">            node_queue <span class="op">=</span> node_queue[<span class="dv">1</span>:]</a>
<a class="sourceLine" id="cb5-191" title="191">            node_edges <span class="op">=</span> this_node.edges</a>
<a class="sourceLine" id="cb5-192" title="192">            <span class="cf">for</span> each_edge <span class="kw">in</span> node_edges:</a>
<a class="sourceLine" id="cb5-193" title="193">                <span class="cf">if</span>(each_edge.node_to.visited<span class="op">==</span><span class="va">False</span>):</a>
<a class="sourceLine" id="cb5-194" title="194">                    node_queue.append(each_edge.node_to)</a>
<a class="sourceLine" id="cb5-195" title="195">                    each_edge.node_to.visited <span class="op">=</span> <span class="va">True</span></a>
<a class="sourceLine" id="cb5-196" title="196">                    ret_list.append(each_edge.node_to.value)</a>
<a class="sourceLine" id="cb5-197" title="197"></a>
<a class="sourceLine" id="cb5-198" title="198">        <span class="cf">return</span> ret_list</a>
<a class="sourceLine" id="cb5-199" title="199"></a>
<a class="sourceLine" id="cb5-200" title="200">    <span class="kw">def</span> bfs_names(<span class="va">self</span>, start_node_num):</a>
<a class="sourceLine" id="cb5-201" title="201">        <span class="co">&quot;&quot;&quot;Return the results of bfs with numbers converted to names.&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb5-202" title="202">        <span class="cf">return</span> [<span class="va">self</span>.node_names[num] <span class="cf">for</span> num <span class="kw">in</span> <span class="va">self</span>.bfs(start_node_num)]</a>
<a class="sourceLine" id="cb5-203" title="203"></a>
<a class="sourceLine" id="cb5-204" title="204">graph <span class="op">=</span> Graph()</a>
<a class="sourceLine" id="cb5-205" title="205"></a>
<a class="sourceLine" id="cb5-206" title="206"><span class="co"># You do not need to change anything below this line.</span></a>
<a class="sourceLine" id="cb5-207" title="207"><span class="co"># You only need to implement Graph.dfs_helper and Graph.bfs</span></a>
<a class="sourceLine" id="cb5-208" title="208"></a>
<a class="sourceLine" id="cb5-209" title="209">graph.set_node_names((<span class="st">&#39;Mountain View&#39;</span>,   <span class="co"># 0</span></a>
<a class="sourceLine" id="cb5-210" title="210">                      <span class="st">&#39;San Francisco&#39;</span>,   <span class="co"># 1</span></a>
<a class="sourceLine" id="cb5-211" title="211">                      <span class="st">&#39;London&#39;</span>,          <span class="co"># 2</span></a>
<a class="sourceLine" id="cb5-212" title="212">                      <span class="st">&#39;Shanghai&#39;</span>,        <span class="co"># 3</span></a>
<a class="sourceLine" id="cb5-213" title="213">                      <span class="st">&#39;Berlin&#39;</span>,          <span class="co"># 4</span></a>
<a class="sourceLine" id="cb5-214" title="214">                      <span class="st">&#39;Sao Paolo&#39;</span>,       <span class="co"># 5</span></a>
<a class="sourceLine" id="cb5-215" title="215">                      <span class="st">&#39;Bangalore&#39;</span>))      <span class="co"># 6</span></a>
<a class="sourceLine" id="cb5-216" title="216"></a>
<a class="sourceLine" id="cb5-217" title="217">graph.insert_edge(<span class="dv">51</span>, <span class="dv">0</span>, <span class="dv">1</span>)     <span class="co"># MV &lt;-&gt; SF</span></a>
<a class="sourceLine" id="cb5-218" title="218">graph.insert_edge(<span class="dv">51</span>, <span class="dv">1</span>, <span class="dv">0</span>)     <span class="co"># SF &lt;-&gt; MV</span></a>
<a class="sourceLine" id="cb5-219" title="219">graph.insert_edge(<span class="dv">9950</span>, <span class="dv">0</span>, <span class="dv">3</span>)   <span class="co"># MV &lt;-&gt; Shanghai</span></a>
<a class="sourceLine" id="cb5-220" title="220">graph.insert_edge(<span class="dv">9950</span>, <span class="dv">3</span>, <span class="dv">0</span>)   <span class="co"># Shanghai &lt;-&gt; MV</span></a>
<a class="sourceLine" id="cb5-221" title="221">graph.insert_edge(<span class="dv">10375</span>, <span class="dv">0</span>, <span class="dv">5</span>)  <span class="co"># MV &lt;-&gt; Sao Paolo</span></a>
<a class="sourceLine" id="cb5-222" title="222">graph.insert_edge(<span class="dv">10375</span>, <span class="dv">5</span>, <span class="dv">0</span>)  <span class="co"># Sao Paolo &lt;-&gt; MV</span></a>
<a class="sourceLine" id="cb5-223" title="223">graph.insert_edge(<span class="dv">9900</span>, <span class="dv">1</span>, <span class="dv">3</span>)   <span class="co"># SF &lt;-&gt; Shanghai</span></a>
<a class="sourceLine" id="cb5-224" title="224">graph.insert_edge(<span class="dv">9900</span>, <span class="dv">3</span>, <span class="dv">1</span>)   <span class="co"># Shanghai &lt;-&gt; SF</span></a>
<a class="sourceLine" id="cb5-225" title="225">graph.insert_edge(<span class="dv">9130</span>, <span class="dv">1</span>, <span class="dv">4</span>)   <span class="co"># SF &lt;-&gt; Berlin</span></a>
<a class="sourceLine" id="cb5-226" title="226">graph.insert_edge(<span class="dv">9130</span>, <span class="dv">4</span>, <span class="dv">1</span>)   <span class="co"># Berlin &lt;-&gt; SF</span></a>
<a class="sourceLine" id="cb5-227" title="227">graph.insert_edge(<span class="dv">9217</span>, <span class="dv">2</span>, <span class="dv">3</span>)   <span class="co"># London &lt;-&gt; Shanghai</span></a>
<a class="sourceLine" id="cb5-228" title="228">graph.insert_edge(<span class="dv">9217</span>, <span class="dv">3</span>, <span class="dv">2</span>)   <span class="co"># Shanghai &lt;-&gt; London</span></a>
<a class="sourceLine" id="cb5-229" title="229">graph.insert_edge(<span class="dv">932</span>, <span class="dv">2</span>, <span class="dv">4</span>)    <span class="co"># London &lt;-&gt; Berlin</span></a>
<a class="sourceLine" id="cb5-230" title="230">graph.insert_edge(<span class="dv">932</span>, <span class="dv">4</span>, <span class="dv">2</span>)    <span class="co"># Berlin &lt;-&gt; London</span></a>
<a class="sourceLine" id="cb5-231" title="231">graph.insert_edge(<span class="dv">9471</span>, <span class="dv">2</span>, <span class="dv">5</span>)   <span class="co"># London &lt;-&gt; Sao Paolo</span></a>
<a class="sourceLine" id="cb5-232" title="232">graph.insert_edge(<span class="dv">9471</span>, <span class="dv">5</span>, <span class="dv">2</span>)   <span class="co"># Sao Paolo &lt;-&gt; London</span></a>
<a class="sourceLine" id="cb5-233" title="233"><span class="co"># (6) &#39;Bangalore&#39; is intentionally disconnected (no edges)</span></a>
<a class="sourceLine" id="cb5-234" title="234"><span class="co"># for this problem and should produce None in the</span></a>
<a class="sourceLine" id="cb5-235" title="235"><span class="co"># Adjacency List, etc.</span></a>
<a class="sourceLine" id="cb5-236" title="236"></a>
<a class="sourceLine" id="cb5-237" title="237"><span class="im">import</span> pprint</a>
<a class="sourceLine" id="cb5-238" title="238">pp <span class="op">=</span> pprint.PrettyPrinter(indent<span class="op">=</span><span class="dv">2</span>)</a>
<a class="sourceLine" id="cb5-239" title="239"></a>
<a class="sourceLine" id="cb5-240" title="240"><span class="bu">print</span>(<span class="st">&quot;Edge List&quot;</span>)</a>
<a class="sourceLine" id="cb5-241" title="241">pp.pprint(graph.get_edge_list_names())</a>
<a class="sourceLine" id="cb5-242" title="242"></a>
<a class="sourceLine" id="cb5-243" title="243"><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">Adjacency List&quot;</span>)</a>
<a class="sourceLine" id="cb5-244" title="244">pp.pprint(graph.get_adjacency_list_names())</a>
<a class="sourceLine" id="cb5-245" title="245"></a>
<a class="sourceLine" id="cb5-246" title="246"><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">Adjacency Matrix&quot;</span>)</a>
<a class="sourceLine" id="cb5-247" title="247">pp.pprint(graph.get_adjacency_matrix())</a>
<a class="sourceLine" id="cb5-248" title="248"></a>
<a class="sourceLine" id="cb5-249" title="249"><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">Depth First Search&quot;</span>)</a>
<a class="sourceLine" id="cb5-250" title="250">pp.pprint(graph.dfs_names(<span class="dv">2</span>))</a>
<a class="sourceLine" id="cb5-251" title="251"></a>
<a class="sourceLine" id="cb5-252" title="252"><span class="co"># Should print:</span></a>
<a class="sourceLine" id="cb5-253" title="253"><span class="co"># Depth First Search</span></a>
<a class="sourceLine" id="cb5-254" title="254"><span class="co"># [&#39;London&#39;, &#39;Shanghai&#39;, &#39;Mountain View&#39;, &#39;San Francisco&#39;, &#39;Berlin&#39;, &#39;Sao Paolo&#39;]</span></a>
<a class="sourceLine" id="cb5-255" title="255"></a>
<a class="sourceLine" id="cb5-256" title="256"><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">Breadth First Search&quot;</span>)</a>
<a class="sourceLine" id="cb5-257" title="257">pp.pprint(graph.bfs_names(<span class="dv">2</span>))</a>
<a class="sourceLine" id="cb5-258" title="258"><span class="co"># test error reporting</span></a>
<a class="sourceLine" id="cb5-259" title="259"><span class="co"># pp.pprint([&#39;Sao Paolo&#39;, &#39;Mountain View&#39;, &#39;San Francisco&#39;, &#39;London&#39;, &#39;Shanghai&#39;, &#39;Berlin&#39;])</span></a>
<a class="sourceLine" id="cb5-260" title="260"></a>
<a class="sourceLine" id="cb5-261" title="261"><span class="co"># Should print:</span></a>
<a class="sourceLine" id="cb5-262" title="262"><span class="co"># Breadth First Search</span></a>
<a class="sourceLine" id="cb5-263" title="263"><span class="co"># [&#39;London&#39;, &#39;Shanghai&#39;, &#39;Berlin&#39;, &#39;Sao Paolo&#39;, &#39;Mountain View&#39;, &#39;San Francisco&#39;]</span></a></code></pre>
    </div>
    <p>{% endtab %}</p>
    <p>
      {% tab title=“Javascript” %} {% embed
      url=“https://gist.github.com/bgoonz/5f6cfb85d684629aa2e0d5eea35edacb” %}
    </p>
    <h3 id="js-advanced">JS ADVANCED:</h3>
    <p>
      {% embed
      url=“https://gist.github.com/bgoonz/bd665286cdc5c0b8f74f8129a1b74d16” %}
      {% endtab %} {% endtabs %}
    </p>
    <h2 id="intro-to-graphs">Intro to Graphs</h2>
    <figure>
      <img
        src="../../../.gitbook/assets/image%20%2816%29.png"
        alt="Directed Graph"
      />
      <figcaption>Directed Graph</figcaption>
    </figure>
    <h3 id="objectives">Objectives</h3>
    <ul>
      <li>Learn what graphs are</li>
      <li>Learn the components of graphs</li>
      <li>Learn what graphs are useful for</li>
    </ul>
    <h3 id="what-are-graphs">What Are Graphs?</h3>
    <p>
      Graphs are collections of related data. They’re like trees, except
      connections can be made from any node to any other node, even forming
      loops.
    </p>
    <p>
      The nodes in a graph are called <em>vertexes</em> (or <em>vertices</em> or
      <em>verts</em>), and the connections between the verts are called
      <em>edges</em>.
    </p>
    <p>And edge denotes a relationship or linkage between the two verts.</p>
    <h3 id="what-can-they-represent">What can they represent?</h3>
    <p>Graphs can represent any kind of multiway relational data.</p>
    <p>This could be a collection of cities and linking roads.</p>
    <p>It could be a collection of computers on a network.</p>
    <p>
      It could be a population of people who know each other and
      <a href="https://en.wikipedia.org/wiki/Six_Degrees_of_Kevin_Bacon"
        >Kevin Bacon</a
      >.
    </p>
    <p>It could represent trade relationships between nations.</p>
    <p>And so on.</p>
    <p><img src="../../../.gitbook/assets/image%20%2819%29.png" /></p>
    <h3 id="definitions">Definitions</h3>
    <h4 id="directedundirected-graphs">Directed/Undirected Graphs</h4>
    <p>
      If the edges are “one way” (have an arrow), the graph is said to be a
      <em>directed graph</em>. If there are no arrows, the edges are
      bidirectional and the graph is an <em>undirected</em> graph.
    </p>
    <p><img src="../../../.gitbook/assets/image%20%2817%29.png" /></p>
    <p>
      This is an <strong>undirected graph</strong> which could represent a
      social network like Facebook. Alice is friends with Bob, Carol and Dave,
      Bob is friends with Alice and Dave, Carol is only friend with Alice, and
      Dave is friends with only Alice and Bob. In this example, the nodes
      represent people and the edges represent friendship.
    </p>
    <figure>
      <img src="img/social_graph_directed.jpg" alt="Directed Graph" />
      <figcaption>Directed Graph</figcaption>
    </figure>
    <p>
      This is an <strong>directed graph</strong> which could represent a social
      network like Twitter or Instagram. Since Twitter/Instagram follows are
      one-way as opposed to always-mutual Facebook friendships, they are
      represented with arrows. In the above directed graph, Alice and Bob follow
      each other, Dave follows Alice and Bob, and Carol only follows Alice.
    </p>
    <h4 id="cyclicacyclic-graphs">Cyclic/Acyclic Graphs</h4>
    <p>
      If a cycle can be formed (e.g. you can follow the edges and arrive again
      at an already-visited vert), the graph is <em>cyclic</em>. Otherwise it is
      <em>acyclic</em>.
    </p>
    <h4 id="weighted-graphs">Weighted Graphs</h4>
    <p>
      Graphs with values (<em>weights</em>) associated with the edges are called
      <em>weighted graphs</em>.
    </p>
    <p>
      The meaning of the weight is dependent on the type of graph. A graph of
      road network segments might have weight represent the length of the road.
      The higher the total weight of a route on the graph, the longer the trip
      is. The weights can be used to help decide if a particular route should be
      chosen over another.
    </p>
    <p><img src="../../../.gitbook/assets/image%20%2814%29.png" /></p>
    <p>
      Weights can be further modified. For example, if one were building a
      bicycle map, roads with bad car traffic or very steep uphills could be
      given unnaturally large weights so a routing algorithm would be unlikely
      to take them. (This is how Google Maps avoids freeways when you ask it for
      walking directions.)
    </p>
    <h4 id="directed-acyclic-graphs-dags">Directed Acyclic Graphs (DAGs)</h4>
    <p>
      A <em>directed acyclic graph</em> (<em>DAG</em>) has a number of
      applications. From
      <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph"
        >Wikipedia</a
      >:
    </p>
    <blockquote>
      <p>
        DAGs can model many different kinds of information. A spreadsheet can be
        modeled as a DAG, with a vertex for each cell and an edge whenever the
        formula in one cell uses the value from another; a topological ordering
        of this DAG can be used to update all cell values when the spreadsheet
        is changed. Similarly, topological orderings of DAGs can be used to
        order the compilation operations in a makefile. The program evaluation
        and review technique uses DAGs to model the milestones and activities of
        large human projects, and schedule these projects to use as little total
        time as possible. Combinational logic blocks in electronic circuit
        design, and the operations in dataflow programming languages, involve
        acyclic networks of processing elements. DAGs can also represent
        collections of events and their influence on each other, either in a
        probabilistic structure such as a Bayesian network or as a record of
        historical data such as family trees or the version histories of
        distributed revision control systems. DAGs can also be used as a compact
        representation of sequence data, such as the directed acyclic word graph
        representation of a collection of strings, or the binary decision
        diagram representation of sequences of binary choices.
      </p>
    </blockquote>
    <p>
      It’s notable that git uses a DAG to represent commits. A commit can have a
      child commit, or more than one child commit (in the case of a branch). A
      child could come from one parent commit, or from two (in the case of a
      merge). But there’s no way to go back and form a repeating loop in the git
      commit hierarchy.
    </p>
    <p>{% page-ref page=“../array/” %}</p>
    <p>{% page-ref page=“../binary-search-tree/” %}</p>
    <p>{% page-ref page=“../untitled-4/” %}</p>
    <p>{% page-ref page=“../array/extra-array.md” %}</p>
    <p>{% page-ref page=“../stack/” %}</p>
    <p>{% page-ref page=“../binary-tree/” %}</p>
    <p>{% page-ref page=“../untitled-6/” %}</p>
    <p>{% page-ref page=“../untitled-5/” %}</p>
    <p>{% page-ref page=“../untitled-2/” %}</p>
    <p>{% page-ref page=“../untitled-3/” %}</p>
    <p>{% page-ref page=“../queue/queue-sandbox.md” %}</p>
    <p>{% page-ref page=“../untitled-5/” %}</p>
    <p>{% page-ref page=“../untitled-4/double-linked-list.md” %}</p>
    <p>{% page-ref page=“./” %}</p>
    <p>{% page-ref page=“../untitled/” %}</p>
    <p>{% page-ref page=“../heap/” %}</p>
  </body>
</html>
