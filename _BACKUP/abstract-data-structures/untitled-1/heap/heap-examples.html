<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>heap-examples</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
    <style type="text/css">
      a.sourceLine {
        display: inline-block;
        line-height: 1.25;
      }
      a.sourceLine {
        pointer-events: none;
        color: inherit;
        text-decoration: inherit;
      }
      a.sourceLine:empty {
        height: 1.2em;
      }
      .sourceCode {
        overflow: visible;
      }
      code.sourceCode {
        white-space: pre;
        position: relative;
      }
      div.sourceCode {
        margin: 1em 0;
      }
      pre.sourceCode {
        margin: 0;
      }
      @media screen {
        div.sourceCode {
          overflow: auto;
        }
      }
      @media print {
        code.sourceCode {
          white-space: pre-wrap;
        }
        a.sourceLine {
          text-indent: -1em;
          padding-left: 1em;
        }
      }
      pre.numberSource a.sourceLine {
        position: relative;
        left: -4em;
      }
      pre.numberSource a.sourceLine::before {
        content: attr(title);
        position: relative;
        left: -1em;
        text-align: right;
        vertical-align: baseline;
        border: none;
        pointer-events: all;
        display: inline-block;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        padding: 0 4px;
        width: 4em;
        color: #aaaaaa;
      }
      pre.numberSource {
        margin-left: 3em;
        border-left: 1px solid #aaaaaa;
        padding-left: 4px;
      }
      div.sourceCode {
      }
      @media screen {
        a.sourceLine::before {
          text-decoration: underline;
        }
      }
      code span.al {
        color: #ff0000;
        font-weight: bold;
      } /* Alert */
      code span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Annotation */
      code span.at {
        color: #7d9029;
      } /* Attribute */
      code span.bn {
        color: #40a070;
      } /* BaseN */
      code span.bu {
      } /* BuiltIn */
      code span.cf {
        color: #007020;
        font-weight: bold;
      } /* ControlFlow */
      code span.ch {
        color: #4070a0;
      } /* Char */
      code span.cn {
        color: #880000;
      } /* Constant */
      code span.co {
        color: #60a0b0;
        font-style: italic;
      } /* Comment */
      code span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* CommentVar */
      code span.do {
        color: #ba2121;
        font-style: italic;
      } /* Documentation */
      code span.dt {
        color: #902000;
      } /* DataType */
      code span.dv {
        color: #40a070;
      } /* DecVal */
      code span.er {
        color: #ff0000;
        font-weight: bold;
      } /* Error */
      code span.ex {
      } /* Extension */
      code span.fl {
        color: #40a070;
      } /* Float */
      code span.fu {
        color: #06287e;
      } /* Function */
      code span.im {
      } /* Import */
      code span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Information */
      code span.kw {
        color: #007020;
        font-weight: bold;
      } /* Keyword */
      code span.op {
        color: #666666;
      } /* Operator */
      code span.ot {
        color: #007020;
      } /* Other */
      code span.pp {
        color: #bc7a00;
      } /* Preprocessor */
      code span.sc {
        color: #4070a0;
      } /* SpecialChar */
      code span.ss {
        color: #bb6688;
      } /* SpecialString */
      code span.st {
        color: #4070a0;
      } /* String */
      code span.va {
        color: #19177c;
      } /* Variable */
      code span.vs {
        color: #4070a0;
      } /* VerbatimString */
      code span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Warning */
    </style>
  </head>
  <body>
    <h1 id="heap-examples">Heap Examples</h1>
    <p>{% tabs %} {% tab title=“Python” %}</p>
    <div class="sourceCode" id="cb1">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="co">Binary Heap. A min heap is a complete binary tree where each node is smaller than</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co">its children. The root, therefore, is the minimum element in the tree. The min</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="co">heap uses an array to represent the data and operation. For example a min heap:</span></a>
<a class="sourceLine" id="cb1-5" title="5"></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="co">     4</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="co">   /   \</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="co">  50    7</span></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="co"> / \   /</span></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="co">55 90 87</span></a>
<a class="sourceLine" id="cb1-11" title="11"></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="co">Heap [0, 4, 50, 7, 55, 90, 87]</span></a>
<a class="sourceLine" id="cb1-13" title="13"></a>
<a class="sourceLine" id="cb1-14" title="14"><span class="co">Method in class: insert, remove_min</span></a>
<a class="sourceLine" id="cb1-15" title="15"><span class="co">For example insert(2) in a min heap:</span></a>
<a class="sourceLine" id="cb1-16" title="16"></a>
<a class="sourceLine" id="cb1-17" title="17"><span class="co">     4                     4                     2</span></a>
<a class="sourceLine" id="cb1-18" title="18"><span class="co">   /   \                 /   \                 /   \</span></a>
<a class="sourceLine" id="cb1-19" title="19"><span class="co">  50    7      --&gt;     50     2       --&gt;     50    4</span></a>
<a class="sourceLine" id="cb1-20" title="20"><span class="co"> / \   /  \           /  \   / \             /  \  /  \</span></a>
<a class="sourceLine" id="cb1-21" title="21"><span class="co">55 90 87   2         55  90 87  7           55  90 87  7</span></a>
<a class="sourceLine" id="cb1-22" title="22"></a>
<a class="sourceLine" id="cb1-23" title="23"><span class="co">For example remove_min() in a min heap:</span></a>
<a class="sourceLine" id="cb1-24" title="24"></a>
<a class="sourceLine" id="cb1-25" title="25"><span class="co">     4                     87                    7</span></a>
<a class="sourceLine" id="cb1-26" title="26"><span class="co">   /   \                 /   \                 /   \</span></a>
<a class="sourceLine" id="cb1-27" title="27"><span class="co">  50    7      --&gt;     50     7       --&gt;     50    87</span></a>
<a class="sourceLine" id="cb1-28" title="28"><span class="co"> / \   /              /  \                   /  \</span></a>
<a class="sourceLine" id="cb1-29" title="29"><span class="co">55 90 87             55  90                 55  90</span></a>
<a class="sourceLine" id="cb1-30" title="30"></a>
<a class="sourceLine" id="cb1-31" title="31"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-32" title="32"><span class="im">from</span> abc <span class="im">import</span> ABCMeta, abstractmethod</a>
<a class="sourceLine" id="cb1-33" title="33"></a>
<a class="sourceLine" id="cb1-34" title="34"></a>
<a class="sourceLine" id="cb1-35" title="35"><span class="kw">class</span> AbstractHeap(metaclass<span class="op">=</span>ABCMeta):</a>
<a class="sourceLine" id="cb1-36" title="36">    <span class="co">&quot;&quot;&quot;Abstract Class for Binary Heap.&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-37" title="37"></a>
<a class="sourceLine" id="cb1-38" title="38">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb1-39" title="39">        <span class="cf">pass</span></a>
<a class="sourceLine" id="cb1-40" title="40"></a>
<a class="sourceLine" id="cb1-41" title="41">    <span class="at">@abstractmethod</span></a>
<a class="sourceLine" id="cb1-42" title="42">    <span class="kw">def</span> perc_up(<span class="va">self</span>, i):</a>
<a class="sourceLine" id="cb1-43" title="43">        <span class="cf">pass</span></a>
<a class="sourceLine" id="cb1-44" title="44"></a>
<a class="sourceLine" id="cb1-45" title="45">    <span class="at">@abstractmethod</span></a>
<a class="sourceLine" id="cb1-46" title="46">    <span class="kw">def</span> insert(<span class="va">self</span>, val):</a>
<a class="sourceLine" id="cb1-47" title="47">        <span class="cf">pass</span></a>
<a class="sourceLine" id="cb1-48" title="48"></a>
<a class="sourceLine" id="cb1-49" title="49">    <span class="at">@abstractmethod</span></a>
<a class="sourceLine" id="cb1-50" title="50">    <span class="kw">def</span> perc_down(<span class="va">self</span>, i):</a>
<a class="sourceLine" id="cb1-51" title="51">        <span class="cf">pass</span></a>
<a class="sourceLine" id="cb1-52" title="52"></a>
<a class="sourceLine" id="cb1-53" title="53">    <span class="at">@abstractmethod</span></a>
<a class="sourceLine" id="cb1-54" title="54">    <span class="kw">def</span> min_child(<span class="va">self</span>, i):</a>
<a class="sourceLine" id="cb1-55" title="55">        <span class="cf">pass</span></a>
<a class="sourceLine" id="cb1-56" title="56"></a>
<a class="sourceLine" id="cb1-57" title="57">    <span class="at">@abstractmethod</span></a>
<a class="sourceLine" id="cb1-58" title="58">    <span class="kw">def</span> remove_min(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb1-59" title="59">        <span class="cf">pass</span></a>
<a class="sourceLine" id="cb1-60" title="60"></a>
<a class="sourceLine" id="cb1-61" title="61"></a>
<a class="sourceLine" id="cb1-62" title="62"><span class="kw">class</span> BinaryHeap(AbstractHeap):</a>
<a class="sourceLine" id="cb1-63" title="63">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb1-64" title="64">        <span class="va">self</span>.currentSize <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb1-65" title="65">        <span class="va">self</span>.heap <span class="op">=</span> [(<span class="dv">0</span>)]</a>
<a class="sourceLine" id="cb1-66" title="66"></a>
<a class="sourceLine" id="cb1-67" title="67">    <span class="kw">def</span> perc_up(<span class="va">self</span>, i):</a>
<a class="sourceLine" id="cb1-68" title="68">        <span class="cf">while</span> i <span class="op">//</span> <span class="dv">2</span> <span class="op">&gt;</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb1-69" title="69">            <span class="cf">if</span> <span class="va">self</span>.heap[i] <span class="op">&lt;</span> <span class="va">self</span>.heap[i <span class="op">//</span> <span class="dv">2</span>]:</a>
<a class="sourceLine" id="cb1-70" title="70">                <span class="co"># Swap value of child with value of its parent</span></a>
<a class="sourceLine" id="cb1-71" title="71">                <span class="va">self</span>.heap[i], <span class="va">self</span>.heap[i <span class="op">//</span> <span class="dv">2</span>] <span class="op">=</span> <span class="va">self</span>.heap[i <span class="op">//</span> <span class="dv">2</span>], <span class="va">self</span>.heap[i]</a>
<a class="sourceLine" id="cb1-72" title="72">            i <span class="op">=</span> i <span class="op">//</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb1-73" title="73"></a>
<a class="sourceLine" id="cb1-74" title="74">    <span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-75" title="75"><span class="co">        Method insert always start by inserting the element at the bottom.</span></a>
<a class="sourceLine" id="cb1-76" title="76"><span class="co">        It inserts rightmost spot so as to maintain the complete tree property.</span></a>
<a class="sourceLine" id="cb1-77" title="77"><span class="co">        Then, it fixes the tree by swapping the new element with its parent,</span></a>
<a class="sourceLine" id="cb1-78" title="78"><span class="co">        until it finds an appropriate spot for the element. It essentially</span></a>
<a class="sourceLine" id="cb1-79" title="79"><span class="co">        perc_up the minimum element</span></a>
<a class="sourceLine" id="cb1-80" title="80"><span class="co">        Complexity: O(logN)</span></a>
<a class="sourceLine" id="cb1-81" title="81"><span class="co">    &quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-82" title="82"></a>
<a class="sourceLine" id="cb1-83" title="83">    <span class="kw">def</span> insert(<span class="va">self</span>, val):</a>
<a class="sourceLine" id="cb1-84" title="84">        <span class="va">self</span>.heap.append(val)</a>
<a class="sourceLine" id="cb1-85" title="85">        <span class="va">self</span>.currentSize <span class="op">=</span> <span class="va">self</span>.currentSize <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-86" title="86">        <span class="va">self</span>.perc_up(<span class="va">self</span>.currentSize)</a>
<a class="sourceLine" id="cb1-87" title="87"></a>
<a class="sourceLine" id="cb1-88" title="88">    <span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-89" title="89"><span class="co">        Method min_child returns the index of smaller of 2 children of parent at index i</span></a>
<a class="sourceLine" id="cb1-90" title="90"><span class="co">    &quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-91" title="91"></a>
<a class="sourceLine" id="cb1-92" title="92">    <span class="kw">def</span> min_child(<span class="va">self</span>, i):</a>
<a class="sourceLine" id="cb1-93" title="93">        <span class="cf">if</span> <span class="dv">2</span> <span class="op">*</span> i <span class="op">+</span> <span class="dv">1</span> <span class="op">&gt;</span> <span class="va">self</span>.currentSize:  <span class="co"># No right child</span></a>
<a class="sourceLine" id="cb1-94" title="94">            <span class="cf">return</span> <span class="dv">2</span> <span class="op">*</span> i</a>
<a class="sourceLine" id="cb1-95" title="95">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb1-96" title="96">            <span class="co"># left child &gt; right child</span></a>
<a class="sourceLine" id="cb1-97" title="97">            <span class="cf">if</span> <span class="va">self</span>.heap[<span class="dv">2</span> <span class="op">*</span> i] <span class="op">&gt;</span> <span class="va">self</span>.heap[<span class="dv">2</span> <span class="op">*</span> i <span class="op">+</span> <span class="dv">1</span>]:</a>
<a class="sourceLine" id="cb1-98" title="98">                <span class="cf">return</span> <span class="dv">2</span> <span class="op">*</span> i <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-99" title="99">            <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb1-100" title="100">                <span class="cf">return</span> <span class="dv">2</span> <span class="op">*</span> i</a>
<a class="sourceLine" id="cb1-101" title="101"></a>
<a class="sourceLine" id="cb1-102" title="102">    <span class="kw">def</span> perc_down(<span class="va">self</span>, i):</a>
<a class="sourceLine" id="cb1-103" title="103">        <span class="cf">while</span> <span class="dv">2</span> <span class="op">*</span> i <span class="op">&lt;</span> <span class="va">self</span>.currentSize:</a>
<a class="sourceLine" id="cb1-104" title="104">            min_child <span class="op">=</span> <span class="va">self</span>.min_child(i)</a>
<a class="sourceLine" id="cb1-105" title="105">            <span class="cf">if</span> <span class="va">self</span>.heap[min_child] <span class="op">&lt;</span> <span class="va">self</span>.heap[i]:</a>
<a class="sourceLine" id="cb1-106" title="106">                <span class="co"># Swap min child with parent</span></a>
<a class="sourceLine" id="cb1-107" title="107">                <span class="va">self</span>.heap[min_child], <span class="va">self</span>.heap[i] <span class="op">=</span> <span class="va">self</span>.heap[i], <span class="va">self</span>.heap[min_child]</a>
<a class="sourceLine" id="cb1-108" title="108">            i <span class="op">=</span> min_child</a>
<a class="sourceLine" id="cb1-109" title="109"></a>
<a class="sourceLine" id="cb1-110" title="110">    <span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-111" title="111"><span class="co">        Remove Min method removes the minimum element and swap it with the last</span></a>
<a class="sourceLine" id="cb1-112" title="112"><span class="co">        element in the heap( the bottommost, rightmost element). Then, it</span></a>
<a class="sourceLine" id="cb1-113" title="113"><span class="co">        perc_down this element, swapping it with one of its children until the</span></a>
<a class="sourceLine" id="cb1-114" title="114"><span class="co">        min heap property is restored</span></a>
<a class="sourceLine" id="cb1-115" title="115"><span class="co">        Complexity: O(logN)</span></a>
<a class="sourceLine" id="cb1-116" title="116"><span class="co">    &quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-117" title="117"></a>
<a class="sourceLine" id="cb1-118" title="118">    <span class="kw">def</span> remove_min(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb1-119" title="119">        ret <span class="op">=</span> <span class="va">self</span>.heap[<span class="dv">1</span>]  <span class="co"># the smallest value at beginning</span></a>
<a class="sourceLine" id="cb1-120" title="120">        <span class="va">self</span>.heap[<span class="dv">1</span>] <span class="op">=</span> <span class="va">self</span>.heap[<span class="va">self</span>.currentSize]  <span class="co"># Replace it by the last value</span></a>
<a class="sourceLine" id="cb1-121" title="121">        <span class="va">self</span>.currentSize <span class="op">=</span> <span class="va">self</span>.currentSize <span class="op">-</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-122" title="122">        <span class="va">self</span>.heap.pop()</a>
<a class="sourceLine" id="cb1-123" title="123">        <span class="va">self</span>.perc_down(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-124" title="124">        <span class="cf">return</span> ret</a>
<a class="sourceLine" id="cb1-125" title="125"></a>
<a class="sourceLine" id="cb1-126" title="126"><span class="im">from</span> .binary_heap <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb1-127" title="127"><span class="im">from</span> .skyline <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb1-128" title="128"><span class="im">from</span> .sliding_window_max <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb1-129" title="129"><span class="im">from</span> .merge_sorted_k_lists <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb1-130" title="130"><span class="im">from</span> .k_closest_points <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb1-131" title="131"></a>
<a class="sourceLine" id="cb1-132" title="132"><span class="co">&quot;&quot;&quot;Given a list of points, find the k closest to the origin.</span></a>
<a class="sourceLine" id="cb1-133" title="133"></a>
<a class="sourceLine" id="cb1-134" title="134"><span class="co">Idea: Maintain a max heap of k elements.</span></a>
<a class="sourceLine" id="cb1-135" title="135"><span class="co">We can iterate through all points.</span></a>
<a class="sourceLine" id="cb1-136" title="136"><span class="co">If a point p has a smaller distance to the origin than the top element of a heap, we add point p to the heap and remove the top element.</span></a>
<a class="sourceLine" id="cb1-137" title="137"><span class="co">After iterating through all points, our heap contains the k closest points to the origin.</span></a>
<a class="sourceLine" id="cb1-138" title="138"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-139" title="139"></a>
<a class="sourceLine" id="cb1-140" title="140"></a>
<a class="sourceLine" id="cb1-141" title="141"><span class="im">from</span> heapq <span class="im">import</span> heapify, heappushpop</a>
<a class="sourceLine" id="cb1-142" title="142"></a>
<a class="sourceLine" id="cb1-143" title="143"></a>
<a class="sourceLine" id="cb1-144" title="144"><span class="kw">def</span> k_closest(points, k, origin<span class="op">=</span>(<span class="dv">0</span>, <span class="dv">0</span>)):</a>
<a class="sourceLine" id="cb1-145" title="145">    <span class="co"># Time: O(k+(n-k)logk)</span></a>
<a class="sourceLine" id="cb1-146" title="146">    <span class="co"># Space: O(k)</span></a>
<a class="sourceLine" id="cb1-147" title="147">    <span class="co">&quot;&quot;&quot;Initialize max heap with first k points.</span></a>
<a class="sourceLine" id="cb1-148" title="148"><span class="co">    Python does not support a max heap; thus we can use the default min heap where the keys (distance) are negated.</span></a>
<a class="sourceLine" id="cb1-149" title="149"><span class="co">    &quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-150" title="150">    heap <span class="op">=</span> [(<span class="op">-</span>distance(p, origin), p) <span class="cf">for</span> p <span class="kw">in</span> points[:k]]</a>
<a class="sourceLine" id="cb1-151" title="151">    heapify(heap)</a>
<a class="sourceLine" id="cb1-152" title="152"></a>
<a class="sourceLine" id="cb1-153" title="153">    <span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-154" title="154"><span class="co">    For every point p in points[k:],</span></a>
<a class="sourceLine" id="cb1-155" title="155"><span class="co">    check if p is smaller than the root of the max heap;</span></a>
<a class="sourceLine" id="cb1-156" title="156"><span class="co">    if it is, add p to heap and remove root. Reheapify.</span></a>
<a class="sourceLine" id="cb1-157" title="157"><span class="co">    &quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-158" title="158">    <span class="cf">for</span> p <span class="kw">in</span> points[k:]:</a>
<a class="sourceLine" id="cb1-159" title="159">        d <span class="op">=</span> distance(p, origin)</a>
<a class="sourceLine" id="cb1-160" title="160"></a>
<a class="sourceLine" id="cb1-161" title="161">        heappushpop(heap, (<span class="op">-</span>d, p))  <span class="co"># heappushpop does conditional check</span></a>
<a class="sourceLine" id="cb1-162" title="162">        <span class="co">&quot;&quot;&quot;Same as:</span></a>
<a class="sourceLine" id="cb1-163" title="163"><span class="co">            if d &lt; -heap[0][0]:</span></a>
<a class="sourceLine" id="cb1-164" title="164"><span class="co">                heappush(heap, (-d,p))</span></a>
<a class="sourceLine" id="cb1-165" title="165"><span class="co">                heappop(heap)</span></a>
<a class="sourceLine" id="cb1-166" title="166"></a>
<a class="sourceLine" id="cb1-167" title="167"><span class="co">        Note: heappushpop is more efficient than separate push and pop calls.</span></a>
<a class="sourceLine" id="cb1-168" title="168"><span class="co">        Each heappushpop call takes O(logk) time.</span></a>
<a class="sourceLine" id="cb1-169" title="169"><span class="co">        &quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-170" title="170"></a>
<a class="sourceLine" id="cb1-171" title="171">    <span class="cf">return</span> [p <span class="cf">for</span> nd, p <span class="kw">in</span> heap]  <span class="co"># return points in heap</span></a>
<a class="sourceLine" id="cb1-172" title="172"></a>
<a class="sourceLine" id="cb1-173" title="173"></a>
<a class="sourceLine" id="cb1-174" title="174"><span class="kw">def</span> distance(point, origin<span class="op">=</span>(<span class="dv">0</span>, <span class="dv">0</span>)):</a>
<a class="sourceLine" id="cb1-175" title="175">    <span class="cf">return</span> (point[<span class="dv">0</span>] <span class="op">-</span> origin[<span class="dv">0</span>]) <span class="op">**</span> <span class="dv">2</span> <span class="op">+</span> (point[<span class="dv">1</span>] <span class="op">-</span> origin[<span class="dv">1</span>]) <span class="op">**</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb1-176" title="176"></a>
<a class="sourceLine" id="cb1-177" title="177"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-178" title="178"><span class="co">Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</span></a>
<a class="sourceLine" id="cb1-179" title="179"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-180" title="180"></a>
<a class="sourceLine" id="cb1-181" title="181"></a>
<a class="sourceLine" id="cb1-182" title="182"><span class="im">from</span> heapq <span class="im">import</span> heappop, heapreplace, heapify</a>
<a class="sourceLine" id="cb1-183" title="183"><span class="im">from</span> queue <span class="im">import</span> PriorityQueue</a>
<a class="sourceLine" id="cb1-184" title="184"></a>
<a class="sourceLine" id="cb1-185" title="185"></a>
<a class="sourceLine" id="cb1-186" title="186"><span class="co"># Definition for singly-linked list.</span></a>
<a class="sourceLine" id="cb1-187" title="187"><span class="kw">class</span> ListNode(<span class="bu">object</span>):</a>
<a class="sourceLine" id="cb1-188" title="188">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, x):</a>
<a class="sourceLine" id="cb1-189" title="189">        <span class="va">self</span>.val <span class="op">=</span> x</a>
<a class="sourceLine" id="cb1-190" title="190">        <span class="va">self</span>.<span class="bu">next</span> <span class="op">=</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb1-191" title="191"></a>
<a class="sourceLine" id="cb1-192" title="192"></a>
<a class="sourceLine" id="cb1-193" title="193"><span class="kw">def</span> merge_k_lists(lists):</a>
<a class="sourceLine" id="cb1-194" title="194">    dummy <span class="op">=</span> node <span class="op">=</span> ListNode(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb1-195" title="195">    h <span class="op">=</span> [(n.val, n) <span class="cf">for</span> n <span class="kw">in</span> lists <span class="cf">if</span> n]</a>
<a class="sourceLine" id="cb1-196" title="196">    heapify(h)</a>
<a class="sourceLine" id="cb1-197" title="197">    <span class="cf">while</span> h:</a>
<a class="sourceLine" id="cb1-198" title="198">        v, n <span class="op">=</span> h[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb1-199" title="199">        <span class="cf">if</span> n.<span class="bu">next</span> <span class="kw">is</span> <span class="va">None</span>:</a>
<a class="sourceLine" id="cb1-200" title="200">            heappop(h)  <span class="co"># only change heap size when necessary</span></a>
<a class="sourceLine" id="cb1-201" title="201">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb1-202" title="202">            heapreplace(h, (n.<span class="bu">next</span>.val, n.<span class="bu">next</span>))</a>
<a class="sourceLine" id="cb1-203" title="203">        node.<span class="bu">next</span> <span class="op">=</span> n</a>
<a class="sourceLine" id="cb1-204" title="204">        node <span class="op">=</span> node.<span class="bu">next</span></a>
<a class="sourceLine" id="cb1-205" title="205"></a>
<a class="sourceLine" id="cb1-206" title="206">    <span class="cf">return</span> dummy.<span class="bu">next</span></a>
<a class="sourceLine" id="cb1-207" title="207"></a>
<a class="sourceLine" id="cb1-208" title="208"></a>
<a class="sourceLine" id="cb1-209" title="209"><span class="kw">def</span> merge_k_lists(lists):</a>
<a class="sourceLine" id="cb1-210" title="210">    dummy <span class="op">=</span> ListNode(<span class="va">None</span>)</a>
<a class="sourceLine" id="cb1-211" title="211">    curr <span class="op">=</span> dummy</a>
<a class="sourceLine" id="cb1-212" title="212">    q <span class="op">=</span> PriorityQueue()</a>
<a class="sourceLine" id="cb1-213" title="213">    <span class="cf">for</span> node <span class="kw">in</span> lists:</a>
<a class="sourceLine" id="cb1-214" title="214">        <span class="cf">if</span> node:</a>
<a class="sourceLine" id="cb1-215" title="215">            q.put((node.val, node))</a>
<a class="sourceLine" id="cb1-216" title="216">    <span class="cf">while</span> <span class="kw">not</span> q.empty():</a>
<a class="sourceLine" id="cb1-217" title="217">        curr.<span class="bu">next</span> <span class="op">=</span> q.get()[<span class="dv">1</span>]  <span class="co"># These two lines seem to</span></a>
<a class="sourceLine" id="cb1-218" title="218">        curr <span class="op">=</span> curr.<span class="bu">next</span>  <span class="co"># be equivalent to :-   curr = q.get()[1]</span></a>
<a class="sourceLine" id="cb1-219" title="219">        <span class="cf">if</span> curr.<span class="bu">next</span>:</a>
<a class="sourceLine" id="cb1-220" title="220">            q.put((curr.<span class="bu">next</span>.val, curr.<span class="bu">next</span>))</a>
<a class="sourceLine" id="cb1-221" title="221">    <span class="cf">return</span> dummy.<span class="bu">next</span></a>
<a class="sourceLine" id="cb1-222" title="222"></a>
<a class="sourceLine" id="cb1-223" title="223"></a>
<a class="sourceLine" id="cb1-224" title="224"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-225" title="225"><span class="co">I think my code&#39;s complexity is also O(nlogk) and not using heap or priority queue,</span></a>
<a class="sourceLine" id="cb1-226" title="226"><span class="co">n means the total elements and k means the size of list.</span></a>
<a class="sourceLine" id="cb1-227" title="227"></a>
<a class="sourceLine" id="cb1-228" title="228"><span class="co">The mergeTwoLists function in my code comes from the problem Merge Two Sorted Lists</span></a>
<a class="sourceLine" id="cb1-229" title="229"><span class="co">whose complexity obviously is O(n), n is the sum of length of l1 and l2.</span></a>
<a class="sourceLine" id="cb1-230" title="230"></a>
<a class="sourceLine" id="cb1-231" title="231"><span class="co">To put it simpler, assume the k is 2^x, So the progress of combination is like a full binary tree,</span></a>
<a class="sourceLine" id="cb1-232" title="232"><span class="co">from bottom to top. So on every level of tree, the combination complexity is n,</span></a>
<a class="sourceLine" id="cb1-233" title="233"><span class="co">because every level have all n numbers without repetition.</span></a>
<a class="sourceLine" id="cb1-234" title="234"><span class="co">The level of tree is x, ie log k. So the complexity is O(n log k).</span></a>
<a class="sourceLine" id="cb1-235" title="235"></a>
<a class="sourceLine" id="cb1-236" title="236"><span class="co">for example, 8 ListNode, and the length of every ListNode is x1, x2,</span></a>
<a class="sourceLine" id="cb1-237" title="237"><span class="co">x3, x4, x5, x6, x7, x8, total is n.</span></a>
<a class="sourceLine" id="cb1-238" title="238"></a>
<a class="sourceLine" id="cb1-239" title="239"><span class="co">on level 3: x1+x2, x3+x4, x5+x6, x7+x8 sum: n</span></a>
<a class="sourceLine" id="cb1-240" title="240"></a>
<a class="sourceLine" id="cb1-241" title="241"><span class="co">on level 2: x1+x2+x3+x4, x5+x6+x7+x8 sum: n</span></a>
<a class="sourceLine" id="cb1-242" title="242"></a>
<a class="sourceLine" id="cb1-243" title="243"><span class="co">on level 1: x1+x2+x3+x4+x5+x6+x7+x8 sum: n</span></a>
<a class="sourceLine" id="cb1-244" title="244"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-245" title="245"></a>
<a class="sourceLine" id="cb1-246" title="246"><span class="co"># -*- coding: utf-8 -*-</span></a>
<a class="sourceLine" id="cb1-247" title="247"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-248" title="248"><span class="co">A city&#39;s skyline is the outer contour of the silhouette formed by all the buildings</span></a>
<a class="sourceLine" id="cb1-249" title="249"><span class="co">in that city when viewed from a distance.</span></a>
<a class="sourceLine" id="cb1-250" title="250"><span class="co">Now suppose you are given the locations and height of all the buildings</span></a>
<a class="sourceLine" id="cb1-251" title="251"><span class="co">as shown on a cityscape photo (Figure A),</span></a>
<a class="sourceLine" id="cb1-252" title="252"><span class="co">write a program to output the skyline formed by these buildings collectively (Figure B).</span></a>
<a class="sourceLine" id="cb1-253" title="253"></a>
<a class="sourceLine" id="cb1-254" title="254"><span class="co">The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi],</span></a>
<a class="sourceLine" id="cb1-255" title="255"><span class="co">where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively,</span></a>
<a class="sourceLine" id="cb1-256" title="256"><span class="co">and Hi is its height. It is guaranteed that 0 ≤ Li, Ri ≤ INT_MAX, 0 &lt; Hi ≤ INT_MAX, and Ri - Li &gt; 0.</span></a>
<a class="sourceLine" id="cb1-257" title="257"><span class="co">You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.</span></a>
<a class="sourceLine" id="cb1-258" title="258"></a>
<a class="sourceLine" id="cb1-259" title="259"><span class="co">For instance, the dimensions of all buildings in Figure A are recorded as:</span></a>
<a class="sourceLine" id="cb1-260" title="260"><span class="co">[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] .</span></a>
<a class="sourceLine" id="cb1-261" title="261"></a>
<a class="sourceLine" id="cb1-262" title="262"><span class="co">The output is a list of &quot;key points&quot; (red dots in Figure B) in the format of</span></a>
<a class="sourceLine" id="cb1-263" title="263"><span class="co">[ [x1,y1], [x2, y2], [x3, y3], ... ]</span></a>
<a class="sourceLine" id="cb1-264" title="264"><span class="co">that uniquely defines a skyline.</span></a>
<a class="sourceLine" id="cb1-265" title="265"><span class="co">A key point is the left endpoint of a horizontal line segment. Note that the last key point,</span></a>
<a class="sourceLine" id="cb1-266" title="266"><span class="co">where the rightmost building ends,</span></a>
<a class="sourceLine" id="cb1-267" title="267"><span class="co">is merely used to mark the termination of the skyline, and always has zero height.</span></a>
<a class="sourceLine" id="cb1-268" title="268"><span class="co">Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.</span></a>
<a class="sourceLine" id="cb1-269" title="269"></a>
<a class="sourceLine" id="cb1-270" title="270"><span class="co">For instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ].</span></a>
<a class="sourceLine" id="cb1-271" title="271"></a>
<a class="sourceLine" id="cb1-272" title="272"><span class="co">Notes:</span></a>
<a class="sourceLine" id="cb1-273" title="273"></a>
<a class="sourceLine" id="cb1-274" title="274"><span class="co">The number of buildings in any input list is guaranteed to be in the range [0, 10000].</span></a>
<a class="sourceLine" id="cb1-275" title="275"><span class="co">The input list is already sorted in ascending order by the left x position Li.</span></a>
<a class="sourceLine" id="cb1-276" title="276"><span class="co">The output list must be sorted by the x position.</span></a>
<a class="sourceLine" id="cb1-277" title="277"><span class="co">There must be no consecutive horizontal lines of equal height in the output skyline. For instance,</span></a>
<a class="sourceLine" id="cb1-278" title="278"><span class="co">[...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged</span></a>
<a class="sourceLine" id="cb1-279" title="279"><span class="co">into one in the final output as such: [...[2 3], [4 5], [12 7], ...]</span></a>
<a class="sourceLine" id="cb1-280" title="280"></a>
<a class="sourceLine" id="cb1-281" title="281"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-282" title="282"><span class="im">import</span> heapq</a>
<a class="sourceLine" id="cb1-283" title="283"></a>
<a class="sourceLine" id="cb1-284" title="284"></a>
<a class="sourceLine" id="cb1-285" title="285"><span class="kw">def</span> get_skyline(lrh):</a>
<a class="sourceLine" id="cb1-286" title="286">    <span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-287" title="287"><span class="co">    Wortst Time Complexity: O(NlogN)</span></a>
<a class="sourceLine" id="cb1-288" title="288"><span class="co">    :type buildings: List[List[int]]</span></a>
<a class="sourceLine" id="cb1-289" title="289"><span class="co">    :rtype: List[List[int]]</span></a>
<a class="sourceLine" id="cb1-290" title="290"><span class="co">    &quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-291" title="291">    skyline, live <span class="op">=</span> [], []</a>
<a class="sourceLine" id="cb1-292" title="292">    i, n <span class="op">=</span> <span class="dv">0</span>, <span class="bu">len</span>(lrh)</a>
<a class="sourceLine" id="cb1-293" title="293">    <span class="cf">while</span> i <span class="op">&lt;</span> n <span class="kw">or</span> live:</a>
<a class="sourceLine" id="cb1-294" title="294">        <span class="cf">if</span> <span class="kw">not</span> live <span class="kw">or</span> i <span class="op">&lt;</span> n <span class="kw">and</span> lrh[i][<span class="dv">0</span>] <span class="op">&lt;=</span> <span class="op">-</span>live[<span class="dv">0</span>][<span class="dv">1</span>]:</a>
<a class="sourceLine" id="cb1-295" title="295">            x <span class="op">=</span> lrh[i][<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb1-296" title="296">            <span class="cf">while</span> i <span class="op">&lt;</span> n <span class="kw">and</span> lrh[i][<span class="dv">0</span>] <span class="op">==</span> x:</a>
<a class="sourceLine" id="cb1-297" title="297">                heapq.heappush(live, (<span class="op">-</span>lrh[i][<span class="dv">2</span>], <span class="op">-</span>lrh[i][<span class="dv">1</span>]))</a>
<a class="sourceLine" id="cb1-298" title="298">                i <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-299" title="299">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb1-300" title="300">            x <span class="op">=</span> <span class="op">-</span>live[<span class="dv">0</span>][<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb1-301" title="301">            <span class="cf">while</span> live <span class="kw">and</span> <span class="op">-</span>live[<span class="dv">0</span>][<span class="dv">1</span>] <span class="op">&lt;=</span> x:</a>
<a class="sourceLine" id="cb1-302" title="302">                heapq.heappop(live)</a>
<a class="sourceLine" id="cb1-303" title="303">        height <span class="op">=</span> <span class="bu">len</span>(live) <span class="kw">and</span> <span class="op">-</span>live[<span class="dv">0</span>][<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb1-304" title="304">        <span class="cf">if</span> <span class="kw">not</span> skyline <span class="kw">or</span> height <span class="op">!=</span> skyline[<span class="op">-</span><span class="dv">1</span>][<span class="dv">1</span>]:</a>
<a class="sourceLine" id="cb1-305" title="305">            skyline <span class="op">+=</span> ([x, height],)</a>
<a class="sourceLine" id="cb1-306" title="306">    <span class="cf">return</span> skyline</a>
<a class="sourceLine" id="cb1-307" title="307"></a>
<a class="sourceLine" id="cb1-308" title="308"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-309" title="309"><span class="co">Given an array nums, there is a sliding window of size k</span></a>
<a class="sourceLine" id="cb1-310" title="310"><span class="co">which is moving from the very left of the array to the very right.</span></a>
<a class="sourceLine" id="cb1-311" title="311"><span class="co">You can only see the k numbers in the window.</span></a>
<a class="sourceLine" id="cb1-312" title="312"><span class="co">Each time the sliding window moves right by one position.</span></a>
<a class="sourceLine" id="cb1-313" title="313"></a>
<a class="sourceLine" id="cb1-314" title="314"><span class="co">For example,</span></a>
<a class="sourceLine" id="cb1-315" title="315"><span class="co">Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.</span></a>
<a class="sourceLine" id="cb1-316" title="316"></a>
<a class="sourceLine" id="cb1-317" title="317"><span class="co">Window position                Max</span></a>
<a class="sourceLine" id="cb1-318" title="318"><span class="co">---------------               -----</span></a>
<a class="sourceLine" id="cb1-319" title="319"><span class="co">[1  3  -1] -3  5  3  6  7       3</span></a>
<a class="sourceLine" id="cb1-320" title="320"><span class="co"> 1 [3  -1  -3] 5  3  6  7       3</span></a>
<a class="sourceLine" id="cb1-321" title="321"><span class="co"> 1  3 [-1  -3  5] 3  6  7       5</span></a>
<a class="sourceLine" id="cb1-322" title="322"><span class="co"> 1  3  -1 [-3  5  3] 6  7       5</span></a>
<a class="sourceLine" id="cb1-323" title="323"><span class="co"> 1  3  -1  -3 [5  3  6] 7       6</span></a>
<a class="sourceLine" id="cb1-324" title="324"><span class="co"> 1  3  -1  -3  5 [3  6  7]      7</span></a>
<a class="sourceLine" id="cb1-325" title="325"><span class="co">Therefore, return the max sliding window as [3,3,5,5,6,7].</span></a>
<a class="sourceLine" id="cb1-326" title="326"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-327" title="327"><span class="im">import</span> collections</a>
<a class="sourceLine" id="cb1-328" title="328"></a>
<a class="sourceLine" id="cb1-329" title="329"></a>
<a class="sourceLine" id="cb1-330" title="330"><span class="kw">def</span> max_sliding_window(nums, k):</a>
<a class="sourceLine" id="cb1-331" title="331">    <span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-332" title="332"><span class="co">    :type nums: List[int]</span></a>
<a class="sourceLine" id="cb1-333" title="333"><span class="co">    :type k: int</span></a>
<a class="sourceLine" id="cb1-334" title="334"><span class="co">    :rtype: List[int]</span></a>
<a class="sourceLine" id="cb1-335" title="335"><span class="co">    &quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-336" title="336">    <span class="cf">if</span> <span class="kw">not</span> nums:</a>
<a class="sourceLine" id="cb1-337" title="337">        <span class="cf">return</span> nums</a>
<a class="sourceLine" id="cb1-338" title="338">    queue <span class="op">=</span> collections.deque()</a>
<a class="sourceLine" id="cb1-339" title="339">    res <span class="op">=</span> []</a>
<a class="sourceLine" id="cb1-340" title="340">    <span class="cf">for</span> num <span class="kw">in</span> nums:</a>
<a class="sourceLine" id="cb1-341" title="341">        <span class="cf">if</span> <span class="bu">len</span>(queue) <span class="op">&lt;</span> k:</a>
<a class="sourceLine" id="cb1-342" title="342">            queue.append(num)</a>
<a class="sourceLine" id="cb1-343" title="343">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb1-344" title="344">            res.append(<span class="bu">max</span>(queue))</a>
<a class="sourceLine" id="cb1-345" title="345">            queue.popleft()</a>
<a class="sourceLine" id="cb1-346" title="346">            queue.append(num)</a>
<a class="sourceLine" id="cb1-347" title="347">    res.append(<span class="bu">max</span>(queue))</a>
<a class="sourceLine" id="cb1-348" title="348">    <span class="cf">return</span> res</a>
<a class="sourceLine" id="cb1-349" title="349"></a></code></pre>
    </div>
    <p>{% endtab %}</p>
    <p>{% tab title=“Heaps Explained” %}</p>
    <p>
      A binary heap is a special data structure that resembles a binary tree. It
      differs in the sense that the root of any subtree should be the smallest
      or the largest element.
    </p>
    <p>There are two main types of heaps.</p>
    <ul>
      <li>
        <strong>Minheap</strong> – In a minheap, the root of every subtree is
        the smallest element.
      </li>
      <li>
        <strong>Maxheap</strong> – In a maxheap, the root of every subtree is
        the largest element.
      </li>
    </ul>
    <p>
      In this article, let’s take a look at heaps and dive into programming
      heaps in Python.
    </p>
    <p>
      For more background on the different types of data structures in Python,
      check out the following articles:
    </p>
    <ul>
      <li>
        <a href="https://www.section.io/data-structures-python-part-1/"
          >Introduction to Data Structures</a
        >
      </li>
      <li>
        <a href="https://www.section.io/list-data-structure-python/">List</a>
      </li>
      <li>
        <a href="https://www.section.io/stack-data-structure-python/">Stack</a>
      </li>
      <li>
        <a href="https://www.section.io/queue-data-structure-python/">Queue</a>
      </li>
      <li>
        <a href="https://www.section.io/linked-list-data-structure-python/"
          >Linked Lists</a
        >
      </li>
      <li>
        <a href="https://www.section.io/binary-tree-data-structure-python/"
          >Binary Trees</a
        >
      </li>
    </ul>
    <p>
      <em
        >Note: Prerequisites – Make sure you have basic Python knowledge before
        diving into this article. It also might be a good idea to check out some
        linear data structures. (links are given above)</em
      >
    </p>
    <h4 id="table-of-contents">
      Table of Contents <a id="table-of-contents"></a>
    </h4>
    <ul>
      <li>
        <a
          href="https://www.section.io/engineering-education/heap-data-structure-python/#heaps:-introduction"
          >Heaps: Introduction</a
        >
      </li>
      <li>
        <a
          href="https://www.section.io/engineering-education/heap-data-structure-python/#applications-of-heaps"
          >Applications of Heaps</a
        >
      </li>
      <li>
        <a
          href="https://www.section.io/engineering-education/heap-data-structure-python/#implementing-a-heap"
          >Implementing a Heap</a
        >
      </li>
      <li>
        <a
          href="https://www.section.io/engineering-education/heap-data-structure-python/#practice-heaps"
          >Practice Heaps</a
        >
      </li>
      <li>
        <a
          href="https://www.section.io/engineering-education/heap-data-structure-python/#conclusion"
          >Conclusion</a
        >
      </li>
    </ul>
    <h4 id="heaps-introduction">
      Heaps: Introduction <a id="heaps-introduction"></a>
    </h4>
    <p>
      Heaps are complete binary trees. Complete binary trees satisfy the
      following conditions:
    </p>
    <ul>
      <li>All levels are filled, except the last.</li>
      <li>All the nodes are as far left as possible.</li>
    </ul>
    <figure>
      <img
        src="https://www.section.io/engineering-education/heap-data-structure-python/complete-binary-tree.png"
        alt="Complete Binary Tree"
      />
      <figcaption>Complete Binary Tree</figcaption>
    </figure>
    <p>
      <a
        href="https://www.andrew.cmu.edu/course/15-121/lectures/Trees/trees.html"
        ><em>Figure: Complete Binary Tree</em></a
      >
    </p>
    <p>
      Heaps satisfy the heap property. This means that the root of every subtree
      should be the greatest or smallest element in the subtree, recursively.
    </p>
    <h4 id="applications-of-heaps">
      Applications of Heaps <a id="applications-of-heaps"></a>
    </h4>
    <ul>
      <li>
        Priority Queues can be implemented using heaps. The root of a heap
        always contains the maximum or the minimum value, based on the heap
        type. Therefore, a min-priority queue is implemented using a minheap. A
        max-priority queue is implemented using a maxheap. The element with the
        highest priority can be retrieved in O(1) time.
      </li>
      <li>
        Statistics – If we want to get ordered statistics, heaps serve as a
        great choice. If we want the kth smallest or largest element, we can pop
        the heap k times to retrieve them.
      </li>
      <li>
        Heaps are used in implementing various graph algorithms like
        <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"
          >Dijkstra’s algorithm</a
        >
        and
        <a href="https://en.wikipedia.org/wiki/Prim%27s_algorithm"
          >Prim’s algorithm</a
        >.
      </li>
    </ul>
    <h4 id="implementing-a-heap">
      Implementing a Heap <a id="implementing-a-heap"></a>
    </h4>
    <p><strong>Heap Operations</strong></p>
    <p>A heap has the following methods:</p>
    <ul>
      <li>
        <strong><code>getMax()</code></strong>
        <ul>
          <li>This operation returns the root of the maxheap.</li>
          <li>Time Complexity - O(1).</li>
        </ul>
      </li>
      <li>
        <strong><code>insert(k)</code></strong>
        <ul>
          <li>
            This operation inserts the key <strong>k</strong> into the heap.
          </li>
          <li>Then it rearranges the heap to restore the heap property.</li>
          <li>Time Complexity - O(log n).</li>
        </ul>
      </li>
      <li>
        <strong><code>heapify()</code></strong>
        <ul>
          <li>
            This operation restores the heap property by rearranging the heap.
          </li>
          <li>Time complexity - O(log n).</li>
        </ul>
      </li>
      <li>
        <strong><code>printHeap()</code></strong>
        <ul>
          <li>Prints the heap’s level order traversal.</li>
        </ul>
      </li>
    </ul>
    <p><strong>Maxheap using List</strong></p>
    <p>
      We are going to do the list implementation of a heap. In this, the heap’s
      level-order traversal would be stored as an array/list.
    </p>
    <figure>
      <img
        src="https://www.section.io/engineering-education/heap-data-structure-python/level-order-traversal.png"
        alt="Level Order Traversal"
      />
      <figcaption>Level Order Traversal</figcaption>
    </figure>
    <p>
      <a
        href="https://qph.fs.quoracdn.net/main-qimg-0ddd0cbca44f70d7845cc2caba5a0853"
        ><em>Figure: Level-Order Traversal</em></a
      >
    </p>
    <p>
      <em
        >Note - Level-Order Traversal is a recursive traversal where the root is
        processed first, followed by the children of the root. This is followed
        by the grandchildren of the root until all the nodes are processed. In
        the diagram above, the root node is processed first, followed by the
        left child, right child and so on. The final level order traversal would
        be: 10 4 8 50 24 5 12 18. For an overview of what a level order
        traversal is, check out</em
      >
      <a
        href="https://www.quora.com/What-is-level-order-traversal-in-a-binary-tree"
        ><em>this</em></a
      >
      <em>Quora page.</em>
    </p>
    <p>
      In the array representation of a heap, for an element in array index i,
    </p>
    <ul>
      <li>The Parent Node would be at position floor((i-1)/2).</li>
      <li>The Left Child would be at position 2*i + 1.</li>
      <li>The Right Child would be at position 2*i + 2.</li>
    </ul>
    <p>Let us first define the Heap class.</p>
    <div class="sourceCode" id="cb2">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">class</span> MaxHeap:</a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb2-3" title="3">        <span class="va">self</span>.heap <span class="op">=</span> []</a></code></pre>
    </div>
    <p>This initiates a heap as a list. Now, let us define our methods.</p>
    <div class="sourceCode" id="cb3">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">class</span> MaxHeap:</a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb3-3" title="3">        <span class="co"># Initialize a heap using list</span></a>
<a class="sourceLine" id="cb3-4" title="4">        <span class="va">self</span>.heap <span class="op">=</span> []</a>
<a class="sourceLine" id="cb3-5" title="5"></a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="kw">def</span> getParentPosition(<span class="va">self</span>, i):</a>
<a class="sourceLine" id="cb3-7" title="7">        <span class="co"># The parent is located at floor((i-1)/2)</span></a>
<a class="sourceLine" id="cb3-8" title="8">        <span class="cf">return</span> <span class="bu">int</span>((i<span class="dv">-1</span>)<span class="op">/</span><span class="dv">2</span>)</a>
<a class="sourceLine" id="cb3-9" title="9"></a>
<a class="sourceLine" id="cb3-10" title="10">    <span class="kw">def</span> getLeftChildPosition(<span class="va">self</span>, i):</a>
<a class="sourceLine" id="cb3-11" title="11">        <span class="co"># The left child is located at 2 * i + 1</span></a>
<a class="sourceLine" id="cb3-12" title="12">        <span class="cf">return</span> <span class="dv">2</span><span class="op">*</span>i<span class="op">+</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb3-13" title="13"></a>
<a class="sourceLine" id="cb3-14" title="14">    <span class="kw">def</span> getRightChildPosition(<span class="va">self</span>, i):</a>
<a class="sourceLine" id="cb3-15" title="15">        <span class="co"># The right child is located at 2 * i + 2</span></a>
<a class="sourceLine" id="cb3-16" title="16">        <span class="cf">return</span> <span class="dv">2</span><span class="op">*</span>i<span class="op">+</span><span class="dv">2</span></a>
<a class="sourceLine" id="cb3-17" title="17"></a>
<a class="sourceLine" id="cb3-18" title="18">    <span class="kw">def</span> hasParent(<span class="va">self</span>, i):</a>
<a class="sourceLine" id="cb3-19" title="19">        <span class="co"># This function checks if the given node has a parent or not</span></a>
<a class="sourceLine" id="cb3-20" title="20">        <span class="cf">return</span> <span class="va">self</span>.getParentPosition(i) <span class="op">&lt;</span> <span class="bu">len</span>(<span class="va">self</span>.heap)</a>
<a class="sourceLine" id="cb3-21" title="21"></a>
<a class="sourceLine" id="cb3-22" title="22">    <span class="kw">def</span> hasLeftChild(<span class="va">self</span>, i):</a>
<a class="sourceLine" id="cb3-23" title="23">        <span class="co"># This function checks if the given node has a left child or not</span></a>
<a class="sourceLine" id="cb3-24" title="24">        <span class="cf">return</span> <span class="va">self</span>.getLeftChildPosition(i) <span class="op">&lt;</span> <span class="bu">len</span>(<span class="va">self</span>.heap)</a>
<a class="sourceLine" id="cb3-25" title="25"></a>
<a class="sourceLine" id="cb3-26" title="26">    <span class="kw">def</span> hasRightChild(<span class="va">self</span>, i):</a>
<a class="sourceLine" id="cb3-27" title="27">        <span class="co"># This function checks if the given node has a right child or not</span></a>
<a class="sourceLine" id="cb3-28" title="28">        <span class="cf">return</span> <span class="va">self</span>.getRightChildPosition(i) <span class="op">&lt;</span> <span class="bu">len</span>(<span class="va">self</span>.heap)</a>
<a class="sourceLine" id="cb3-29" title="29"></a>
<a class="sourceLine" id="cb3-30" title="30">    <span class="kw">def</span> insert(<span class="va">self</span>, key):</a>
<a class="sourceLine" id="cb3-31" title="31">        <span class="va">self</span>.heap.append(key) <span class="co"># Adds the key to the end of the list</span></a>
<a class="sourceLine" id="cb3-32" title="32">        <span class="va">self</span>.heapify(<span class="bu">len</span>(<span class="va">self</span>.heap) <span class="op">-</span> <span class="dv">1</span>) <span class="co"># Re-arranges the heap to maintain the heap property</span></a>
<a class="sourceLine" id="cb3-33" title="33"></a>
<a class="sourceLine" id="cb3-34" title="34">    <span class="kw">def</span> getMax(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb3-35" title="35">        <span class="cf">return</span> <span class="va">self</span>.heap[<span class="dv">0</span>] <span class="co"># Returns the largest value in the heap in O(1) time.</span></a>
<a class="sourceLine" id="cb3-36" title="36"></a>
<a class="sourceLine" id="cb3-37" title="37">    <span class="kw">def</span> heapify(<span class="va">self</span>, i):</a>
<a class="sourceLine" id="cb3-38" title="38">        <span class="cf">while</span>(<span class="va">self</span>.hasParent(i) <span class="kw">and</span> <span class="va">self</span>.heap[i] <span class="op">&gt;</span> <span class="va">self</span>.heap[<span class="va">self</span>.getParentPosition(i)]): <span class="co"># Loops until it reaches a leaf node</span></a>
<a class="sourceLine" id="cb3-39" title="39">            <span class="va">self</span>.heap[i], <span class="va">self</span>.heap[<span class="va">self</span>.getParentPosition(i)] <span class="op">=</span> <span class="va">self</span>.heap[<span class="va">self</span>.getParentPosition(i)], <span class="va">self</span>.heap[i] <span class="co"># Swap the values</span></a>
<a class="sourceLine" id="cb3-40" title="40">            i <span class="op">=</span> <span class="va">self</span>.getParentPosition(i) <span class="co"># Resets the new position</span></a>
<a class="sourceLine" id="cb3-41" title="41"></a>
<a class="sourceLine" id="cb3-42" title="42">    <span class="kw">def</span> printHeap(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb3-43" title="43">        <span class="bu">print</span>(<span class="va">self</span>.heap) <span class="co"># Prints the heap</span></a></code></pre>
    </div>
    <p><strong>Minheap using Heapq</strong></p>
    <p>
      We have successfully implemented a heap using a list. Now, let’s use the
      <strong><code>heapq</code></strong> library in Python to implement a
      minheap.
    </p>
    <div class="sourceCode" id="cb4">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1"><span class="im">import</span> heapq</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">class</span> MinHeap:</a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, minheap): <span class="co"># minheap is the list that we can to convert to a heap</span></a>
<a class="sourceLine" id="cb4-4" title="4">        heapq.heapify(minheap) <span class="co"># Use the heapify function to convert list to a heap</span></a>
<a class="sourceLine" id="cb4-5" title="5">        <span class="va">self</span>.minheap <span class="op">=</span> minheap</a>
<a class="sourceLine" id="cb4-6" title="6"></a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="kw">def</span> insert(<span class="va">self</span>, key):</a>
<a class="sourceLine" id="cb4-8" title="8">        heapq.heappush(<span class="va">self</span>.minheap, key) <span class="co"># Insert key into the heap (heapq automatically maintains the heap property)</span></a>
<a class="sourceLine" id="cb4-9" title="9"></a>
<a class="sourceLine" id="cb4-10" title="10">    <span class="kw">def</span> getMin(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb4-11" title="11">        <span class="cf">return</span> <span class="va">self</span>.minheap[<span class="dv">0</span>] <span class="co"># Returns the smallest element of the heap in O(1) time</span></a>
<a class="sourceLine" id="cb4-12" title="12"></a>
<a class="sourceLine" id="cb4-13" title="13">    <span class="kw">def</span> removeMin(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb4-14" title="14">        heapq.heappop(<span class="va">self</span>.minheap) <span class="co"># The heappop function removes the smallest element in the heap</span></a>
<a class="sourceLine" id="cb4-15" title="15"></a>
<a class="sourceLine" id="cb4-16" title="16">    <span class="kw">def</span> printHeap(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb4-17" title="17">        <span class="bu">print</span>(<span class="va">self</span>.minheap) <span class="co"># Prints the heap</span></a></code></pre>
    </div>
    <p>{% endtab %} {% endtabs %}</p>
  </body>
</html>
