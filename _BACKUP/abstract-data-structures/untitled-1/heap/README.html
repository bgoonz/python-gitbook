<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="heap">Heap</h1>
<p>{% page-ref page=“heap-examples.md” %}</p>
<p>{% tabs %} {% tab title=“Max-Heap.js” %}</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">class</span> BinaryHeap <span class="op">{</span></a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="at">constructor</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="kw">this</span>.<span class="at">heap</span> <span class="op">=</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb1-4" title="4">  <span class="op">}</span></a>
<a class="sourceLine" id="cb1-5" title="5"></a>
<a class="sourceLine" id="cb1-6" title="6">  <span class="at">insert</span>(value) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-7" title="7">    <span class="kw">this</span>.<span class="va">heap</span>.<span class="at">push</span>(value)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-8" title="8">    <span class="kw">this</span>.<span class="at">heapify</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb1-9" title="9">  <span class="op">}</span></a>
<a class="sourceLine" id="cb1-10" title="10"></a>
<a class="sourceLine" id="cb1-11" title="11">  <span class="at">size</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb1-12" title="12">    <span class="cf">return</span> <span class="kw">this</span>.<span class="va">heap</span>.<span class="at">length</span><span class="op">;</span></a>
<a class="sourceLine" id="cb1-13" title="13">  <span class="op">}</span></a>
<a class="sourceLine" id="cb1-14" title="14"></a>
<a class="sourceLine" id="cb1-15" title="15">  <span class="at">empty</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb1-16" title="16">    <span class="cf">return</span> <span class="kw">this</span>.<span class="at">size</span>() <span class="op">===</span> <span class="dv">0</span><span class="op">;</span></a>
<a class="sourceLine" id="cb1-17" title="17">  <span class="op">}</span></a>
<a class="sourceLine" id="cb1-18" title="18"></a>
<a class="sourceLine" id="cb1-19" title="19">  <span class="co">// using iterative approach to reorder the heap after insertion</span></a>
<a class="sourceLine" id="cb1-20" title="20">  <span class="at">heapify</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb1-21" title="21">    <span class="kw">let</span> index <span class="op">=</span> <span class="kw">this</span>.<span class="at">size</span>() <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb1-22" title="22"></a>
<a class="sourceLine" id="cb1-23" title="23">    <span class="cf">while</span> (index <span class="op">&gt;</span> <span class="dv">0</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-24" title="24">      <span class="kw">const</span> element <span class="op">=</span> <span class="kw">this</span>.<span class="at">heap</span>[index]<span class="op">;</span></a>
<a class="sourceLine" id="cb1-25" title="25">      <span class="kw">const</span> parentIndex <span class="op">=</span> <span class="va">Math</span>.<span class="at">floor</span>((index <span class="op">-</span> <span class="dv">1</span>) / <span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-26" title="26">      <span class="kw">const</span> parent <span class="op">=</span> <span class="kw">this</span>.<span class="at">heap</span>[parentIndex]<span class="op">;</span></a>
<a class="sourceLine" id="cb1-27" title="27"></a>
<a class="sourceLine" id="cb1-28" title="28">      <span class="cf">if</span> (parent[<span class="dv">0</span>] <span class="op">&gt;=</span> element[<span class="dv">0</span>]) <span class="cf">break</span><span class="op">;</span></a>
<a class="sourceLine" id="cb1-29" title="29">      <span class="kw">this</span>.<span class="at">heap</span>[index] <span class="op">=</span> parent<span class="op">;</span></a>
<a class="sourceLine" id="cb1-30" title="30">      <span class="kw">this</span>.<span class="at">heap</span>[parentIndex] <span class="op">=</span> element<span class="op">;</span></a>
<a class="sourceLine" id="cb1-31" title="31">      index <span class="op">=</span> parentIndex<span class="op">;</span></a>
<a class="sourceLine" id="cb1-32" title="32">    <span class="op">}</span></a>
<a class="sourceLine" id="cb1-33" title="33">  <span class="op">}</span></a>
<a class="sourceLine" id="cb1-34" title="34"></a>
<a class="sourceLine" id="cb1-35" title="35">  <span class="co">// Extracting the maximum element from the Heap</span></a>
<a class="sourceLine" id="cb1-36" title="36">  <span class="at">extractMax</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb1-37" title="37">    <span class="kw">const</span> max <span class="op">=</span> <span class="kw">this</span>.<span class="at">heap</span>[<span class="dv">0</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb1-38" title="38">    <span class="kw">const</span> tmp <span class="op">=</span> <span class="kw">this</span>.<span class="va">heap</span>.<span class="at">pop</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb1-39" title="39">    <span class="cf">if</span> (<span class="op">!</span><span class="kw">this</span>.<span class="at">empty</span>()) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-40" title="40">      <span class="kw">this</span>.<span class="at">heap</span>[<span class="dv">0</span>] <span class="op">=</span> tmp<span class="op">;</span></a>
<a class="sourceLine" id="cb1-41" title="41">      <span class="kw">this</span>.<span class="at">sinkDown</span>(<span class="dv">0</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-42" title="42">    <span class="op">}</span></a>
<a class="sourceLine" id="cb1-43" title="43">    <span class="cf">return</span> max<span class="op">;</span></a>
<a class="sourceLine" id="cb1-44" title="44">  <span class="op">}</span></a>
<a class="sourceLine" id="cb1-45" title="45"></a>
<a class="sourceLine" id="cb1-46" title="46">  <span class="co">// To restore the balance of the heap after extraction.</span></a>
<a class="sourceLine" id="cb1-47" title="47">  <span class="at">sinkDown</span>(index) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-48" title="48">    <span class="kw">const</span> left <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> index <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb1-49" title="49">    <span class="kw">const</span> right <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> index <span class="op">+</span> <span class="dv">2</span><span class="op">;</span></a>
<a class="sourceLine" id="cb1-50" title="50">    <span class="kw">let</span> largest <span class="op">=</span> index<span class="op">;</span></a>
<a class="sourceLine" id="cb1-51" title="51">    <span class="kw">const</span> length <span class="op">=</span> <span class="kw">this</span>.<span class="at">size</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb1-52" title="52"></a>
<a class="sourceLine" id="cb1-53" title="53">    <span class="cf">if</span> (left <span class="op">&lt;</span> length <span class="op">&amp;&amp;</span> <span class="kw">this</span>.<span class="at">heap</span>[left][<span class="dv">0</span>] <span class="op">&gt;</span> <span class="kw">this</span>.<span class="at">heap</span>[largest][<span class="dv">0</span>]) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-54" title="54">      largest <span class="op">=</span> left<span class="op">;</span></a>
<a class="sourceLine" id="cb1-55" title="55">    <span class="op">}</span></a>
<a class="sourceLine" id="cb1-56" title="56">    <span class="cf">if</span> (right <span class="op">&lt;</span> length <span class="op">&amp;&amp;</span> <span class="kw">this</span>.<span class="at">heap</span>[right][<span class="dv">0</span>] <span class="op">&gt;</span> <span class="kw">this</span>.<span class="at">heap</span>[largest][<span class="dv">0</span>]) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-57" title="57">      largest <span class="op">=</span> right<span class="op">;</span></a>
<a class="sourceLine" id="cb1-58" title="58">    <span class="op">}</span></a>
<a class="sourceLine" id="cb1-59" title="59">    <span class="co">// swap</span></a>
<a class="sourceLine" id="cb1-60" title="60">    <span class="cf">if</span> (largest <span class="op">!==</span> index) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-61" title="61">      <span class="kw">const</span> tmp <span class="op">=</span> <span class="kw">this</span>.<span class="at">heap</span>[largest]<span class="op">;</span></a>
<a class="sourceLine" id="cb1-62" title="62">      <span class="kw">this</span>.<span class="at">heap</span>[largest] <span class="op">=</span> <span class="kw">this</span>.<span class="at">heap</span>[index]<span class="op">;</span></a>
<a class="sourceLine" id="cb1-63" title="63">      <span class="kw">this</span>.<span class="at">heap</span>[index] <span class="op">=</span> tmp<span class="op">;</span></a>
<a class="sourceLine" id="cb1-64" title="64">      <span class="kw">this</span>.<span class="at">sinkDown</span>(largest)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-65" title="65">    <span class="op">}</span></a>
<a class="sourceLine" id="cb1-66" title="66">  <span class="op">}</span></a>
<a class="sourceLine" id="cb1-67" title="67"><span class="op">}</span></a>
<a class="sourceLine" id="cb1-68" title="68"></a>
<a class="sourceLine" id="cb1-69" title="69"><span class="kw">const</span> maxHeap <span class="op">=</span> <span class="kw">new</span> <span class="at">BinaryHeap</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb1-70" title="70"><span class="va">maxHeap</span>.<span class="at">insert</span>([<span class="dv">4</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb1-71" title="71"><span class="va">maxHeap</span>.<span class="at">insert</span>([<span class="dv">3</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb1-72" title="72"><span class="va">maxHeap</span>.<span class="at">insert</span>([<span class="dv">6</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb1-73" title="73"><span class="va">maxHeap</span>.<span class="at">insert</span>([<span class="dv">1</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb1-74" title="74"><span class="va">maxHeap</span>.<span class="at">insert</span>([<span class="dv">8</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb1-75" title="75"><span class="va">maxHeap</span>.<span class="at">insert</span>([<span class="dv">2</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb1-76" title="76"></a>
<a class="sourceLine" id="cb1-77" title="77"><span class="cf">while</span> (<span class="op">!</span><span class="va">maxHeap</span>.<span class="at">empty</span>()) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-78" title="78">  <span class="kw">const</span> mx <span class="op">=</span> <span class="va">maxHeap</span>.<span class="at">extractMax</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb1-79" title="79">  <span class="va">console</span>.<span class="at">log</span>(mx)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-80" title="80"><span class="op">}</span></a></code></pre></div>
<p>{% endtab %}</p>
<p>{% tab title=“Max-Priority-queue.js” %}</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="co">/* Minimum Priority Queue</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="co"> * It is a part of heap data structure</span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="co"> * A heap is a specific tree based data structure</span></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="co"> * in which all the nodes of tree are in a specific order.</span></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="co"> * that is the children are arranged in some</span></a>
<a class="sourceLine" id="cb2-6" title="6"><span class="co"> * respect of their parents, can either be greater</span></a>
<a class="sourceLine" id="cb2-7" title="7"><span class="co"> * or less than the parent. This makes it a min priority queue</span></a>
<a class="sourceLine" id="cb2-8" title="8"><span class="co"> * or max priority queue.</span></a>
<a class="sourceLine" id="cb2-9" title="9"><span class="co"> */</span></a>
<a class="sourceLine" id="cb2-10" title="10"></a>
<a class="sourceLine" id="cb2-11" title="11"><span class="co">// Functions: insert, delete, peek, isEmpty, print, heapSort, sink</span></a>
<a class="sourceLine" id="cb2-12" title="12"></a>
<a class="sourceLine" id="cb2-13" title="13"><span class="kw">class</span> MinPriorityQueue <span class="op">{</span></a>
<a class="sourceLine" id="cb2-14" title="14">  <span class="co">// calls the constructor and initializes the capacity</span></a>
<a class="sourceLine" id="cb2-15" title="15">  <span class="at">constructor</span>(c) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-16" title="16">    <span class="kw">this</span>.<span class="at">heap</span> <span class="op">=</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb2-17" title="17">    <span class="kw">this</span>.<span class="at">capacity</span> <span class="op">=</span> c<span class="op">;</span></a>
<a class="sourceLine" id="cb2-18" title="18">    <span class="kw">this</span>.<span class="at">size</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-19" title="19">  <span class="op">}</span></a>
<a class="sourceLine" id="cb2-20" title="20"></a>
<a class="sourceLine" id="cb2-21" title="21">  <span class="co">// inserts the key at the end and rearranges it</span></a>
<a class="sourceLine" id="cb2-22" title="22">  <span class="co">// so that the binary heap is in appropriate order</span></a>
<a class="sourceLine" id="cb2-23" title="23">  <span class="at">insert</span>(key) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-24" title="24">    <span class="cf">if</span> (<span class="kw">this</span>.<span class="at">isFull</span>()) <span class="cf">return</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-25" title="25">    <span class="kw">this</span>.<span class="at">heap</span>[<span class="kw">this</span>.<span class="at">size</span> <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> key<span class="op">;</span></a>
<a class="sourceLine" id="cb2-26" title="26">    <span class="kw">let</span> k <span class="op">=</span> <span class="kw">this</span>.<span class="at">size</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-27" title="27">    <span class="cf">while</span> (k <span class="op">&gt;</span> <span class="dv">1</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-28" title="28">      <span class="cf">if</span> (<span class="kw">this</span>.<span class="at">heap</span>[k] <span class="op">&lt;</span> <span class="kw">this</span>.<span class="at">heap</span>[<span class="va">Math</span>.<span class="at">floor</span>(k / <span class="dv">2</span>)]) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-29" title="29">        <span class="kw">const</span> temp <span class="op">=</span> <span class="kw">this</span>.<span class="at">heap</span>[k]<span class="op">;</span></a>
<a class="sourceLine" id="cb2-30" title="30">        <span class="kw">this</span>.<span class="at">heap</span>[k] <span class="op">=</span> <span class="kw">this</span>.<span class="at">heap</span>[<span class="va">Math</span>.<span class="at">floor</span>(k / <span class="dv">2</span>)]<span class="op">;</span></a>
<a class="sourceLine" id="cb2-31" title="31">        <span class="kw">this</span>.<span class="at">heap</span>[<span class="va">Math</span>.<span class="at">floor</span>(k / <span class="dv">2</span>)] <span class="op">=</span> temp<span class="op">;</span></a>
<a class="sourceLine" id="cb2-32" title="32">      <span class="op">}</span></a>
<a class="sourceLine" id="cb2-33" title="33">      k <span class="op">=</span> <span class="va">Math</span>.<span class="at">floor</span>(k / <span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-34" title="34">    <span class="op">}</span></a>
<a class="sourceLine" id="cb2-35" title="35">    <span class="kw">this</span>.<span class="at">size</span><span class="op">++;</span></a>
<a class="sourceLine" id="cb2-36" title="36">  <span class="op">}</span></a>
<a class="sourceLine" id="cb2-37" title="37"></a>
<a class="sourceLine" id="cb2-38" title="38">  <span class="co">// returns the highest priority value</span></a>
<a class="sourceLine" id="cb2-39" title="39">  <span class="at">peek</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb2-40" title="40">    <span class="cf">return</span> <span class="kw">this</span>.<span class="at">heap</span>[<span class="dv">1</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb2-41" title="41">  <span class="op">}</span></a>
<a class="sourceLine" id="cb2-42" title="42"></a>
<a class="sourceLine" id="cb2-43" title="43">  <span class="co">// returns boolean value whether the heap is empty or not</span></a>
<a class="sourceLine" id="cb2-44" title="44">  <span class="at">isEmpty</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb2-45" title="45">    <span class="cf">return</span> <span class="kw">this</span>.<span class="at">size</span> <span class="op">===</span> <span class="dv">0</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-46" title="46">  <span class="op">}</span></a>
<a class="sourceLine" id="cb2-47" title="47"></a>
<a class="sourceLine" id="cb2-48" title="48">  <span class="co">// returns boolean value whether the heap is full or not</span></a>
<a class="sourceLine" id="cb2-49" title="49">  <span class="at">isFull</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb2-50" title="50">    <span class="cf">if</span> (<span class="kw">this</span>.<span class="at">size</span> <span class="op">===</span> <span class="kw">this</span>.<span class="at">capacity</span>) <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-51" title="51">    <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-52" title="52">  <span class="op">}</span></a>
<a class="sourceLine" id="cb2-53" title="53"></a>
<a class="sourceLine" id="cb2-54" title="54">  <span class="co">// prints the heap</span></a>
<a class="sourceLine" id="cb2-55" title="55">  <span class="at">print</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb2-56" title="56">    <span class="va">console</span>.<span class="at">log</span>(<span class="kw">this</span>.<span class="va">heap</span>.<span class="at">slice</span>(<span class="dv">1</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb2-57" title="57">  <span class="op">}</span></a>
<a class="sourceLine" id="cb2-58" title="58"></a>
<a class="sourceLine" id="cb2-59" title="59">  <span class="co">// heap sorting can be done by performing</span></a>
<a class="sourceLine" id="cb2-60" title="60">  <span class="co">// delete function to the number of times of the size of the heap</span></a>
<a class="sourceLine" id="cb2-61" title="61">  <span class="co">// it returns reverse sort because it is a min priority queue</span></a>
<a class="sourceLine" id="cb2-62" title="62">  <span class="at">heapSort</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb2-63" title="63">    <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="kw">this</span>.<span class="at">capacity</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-64" title="64">      <span class="kw">this</span>.<span class="at">delete</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb2-65" title="65">    <span class="op">}</span></a>
<a class="sourceLine" id="cb2-66" title="66">  <span class="op">}</span></a>
<a class="sourceLine" id="cb2-67" title="67"></a>
<a class="sourceLine" id="cb2-68" title="68">  <span class="co">// this function reorders the heap after every delete function</span></a>
<a class="sourceLine" id="cb2-69" title="69">  <span class="at">sink</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb2-70" title="70">    <span class="kw">let</span> k <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-71" title="71">    <span class="cf">while</span> (<span class="dv">2</span> <span class="op">*</span> k <span class="op">&lt;=</span> <span class="kw">this</span>.<span class="at">size</span> <span class="op">||</span> <span class="dv">2</span> <span class="op">*</span> k <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;=</span> <span class="kw">this</span>.<span class="at">size</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-72" title="72">      <span class="kw">let</span> minIndex<span class="op">;</span></a>
<a class="sourceLine" id="cb2-73" title="73">      <span class="cf">if</span> (<span class="kw">this</span>.<span class="at">heap</span>[<span class="dv">2</span> <span class="op">*</span> k] <span class="op">&gt;=</span> <span class="kw">this</span>.<span class="at">heap</span>[k]) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-74" title="74">        <span class="cf">if</span> (<span class="dv">2</span> <span class="op">*</span> k <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;=</span> <span class="kw">this</span>.<span class="at">size</span> <span class="op">&amp;&amp;</span> <span class="kw">this</span>.<span class="at">heap</span>[<span class="dv">2</span> <span class="op">*</span> k <span class="op">+</span> <span class="dv">1</span>] <span class="op">&gt;=</span> <span class="kw">this</span>.<span class="at">heap</span>[k]) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-75" title="75">          <span class="cf">break</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-76" title="76">        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> (<span class="dv">2</span> <span class="op">*</span> k <span class="op">+</span> <span class="dv">1</span> <span class="op">&gt;</span> <span class="kw">this</span>.<span class="at">size</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-77" title="77">          <span class="cf">break</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-78" title="78">        <span class="op">}</span></a>
<a class="sourceLine" id="cb2-79" title="79">      <span class="op">}</span></a>
<a class="sourceLine" id="cb2-80" title="80">      <span class="cf">if</span> (<span class="dv">2</span> <span class="op">*</span> k <span class="op">+</span> <span class="dv">1</span> <span class="op">&gt;</span> <span class="kw">this</span>.<span class="at">size</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-81" title="81">        minIndex <span class="op">=</span> <span class="kw">this</span>.<span class="at">heap</span>[<span class="dv">2</span> <span class="op">*</span> k] <span class="op">&lt;</span> <span class="kw">this</span>.<span class="at">heap</span>[k] <span class="op">?</span> <span class="dv">2</span> <span class="op">*</span> k : k<span class="op">;</span></a>
<a class="sourceLine" id="cb2-82" title="82">      <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-83" title="83">        <span class="cf">if</span> (</a>
<a class="sourceLine" id="cb2-84" title="84">          <span class="kw">this</span>.<span class="at">heap</span>[k] <span class="op">&gt;</span> <span class="kw">this</span>.<span class="at">heap</span>[<span class="dv">2</span> <span class="op">*</span> k] <span class="op">||</span></a>
<a class="sourceLine" id="cb2-85" title="85">          <span class="kw">this</span>.<span class="at">heap</span>[k] <span class="op">&gt;</span> <span class="kw">this</span>.<span class="at">heap</span>[<span class="dv">2</span> <span class="op">*</span> k <span class="op">+</span> <span class="dv">1</span>]</a>
<a class="sourceLine" id="cb2-86" title="86">        ) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-87" title="87">          minIndex <span class="op">=</span></a>
<a class="sourceLine" id="cb2-88" title="88">            <span class="kw">this</span>.<span class="at">heap</span>[<span class="dv">2</span> <span class="op">*</span> k] <span class="op">&lt;</span> <span class="kw">this</span>.<span class="at">heap</span>[<span class="dv">2</span> <span class="op">*</span> k <span class="op">+</span> <span class="dv">1</span>] <span class="op">?</span> <span class="dv">2</span> <span class="op">*</span> k : <span class="dv">2</span> <span class="op">*</span> k <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-89" title="89">        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-90" title="90">          minIndex <span class="op">=</span> k<span class="op">;</span></a>
<a class="sourceLine" id="cb2-91" title="91">        <span class="op">}</span></a>
<a class="sourceLine" id="cb2-92" title="92">      <span class="op">}</span></a>
<a class="sourceLine" id="cb2-93" title="93">      <span class="kw">const</span> temp <span class="op">=</span> <span class="kw">this</span>.<span class="at">heap</span>[k]<span class="op">;</span></a>
<a class="sourceLine" id="cb2-94" title="94">      <span class="kw">this</span>.<span class="at">heap</span>[k] <span class="op">=</span> <span class="kw">this</span>.<span class="at">heap</span>[minIndex]<span class="op">;</span></a>
<a class="sourceLine" id="cb2-95" title="95">      <span class="kw">this</span>.<span class="at">heap</span>[minIndex] <span class="op">=</span> temp<span class="op">;</span></a>
<a class="sourceLine" id="cb2-96" title="96">      k <span class="op">=</span> minIndex<span class="op">;</span></a>
<a class="sourceLine" id="cb2-97" title="97">    <span class="op">}</span></a>
<a class="sourceLine" id="cb2-98" title="98">  <span class="op">}</span></a>
<a class="sourceLine" id="cb2-99" title="99"></a>
<a class="sourceLine" id="cb2-100" title="100">  <span class="co">// deletes the highest priority value from the heap</span></a>
<a class="sourceLine" id="cb2-101" title="101">  <span class="kw">delete</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb2-102" title="102">    <span class="kw">const</span> min <span class="op">=</span> <span class="kw">this</span>.<span class="at">heap</span>[<span class="dv">1</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb2-103" title="103">    <span class="kw">this</span>.<span class="at">heap</span>[<span class="dv">1</span>] <span class="op">=</span> <span class="kw">this</span>.<span class="at">heap</span>[<span class="kw">this</span>.<span class="at">size</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb2-104" title="104">    <span class="kw">this</span>.<span class="at">heap</span>[<span class="kw">this</span>.<span class="at">size</span>] <span class="op">=</span> min<span class="op">;</span></a>
<a class="sourceLine" id="cb2-105" title="105">    <span class="kw">this</span>.<span class="at">size</span><span class="op">--;</span></a>
<a class="sourceLine" id="cb2-106" title="106">    <span class="kw">this</span>.<span class="at">sink</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb2-107" title="107">    <span class="cf">return</span> min<span class="op">;</span></a>
<a class="sourceLine" id="cb2-108" title="108">  <span class="op">}</span></a>
<a class="sourceLine" id="cb2-109" title="109"><span class="op">}</span></a>
<a class="sourceLine" id="cb2-110" title="110"></a>
<a class="sourceLine" id="cb2-111" title="111"><span class="co">// testing</span></a>
<a class="sourceLine" id="cb2-112" title="112"><span class="kw">const</span> q <span class="op">=</span> <span class="kw">new</span> <span class="at">MinPriorityQueue</span>(<span class="dv">8</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-113" title="113"></a>
<a class="sourceLine" id="cb2-114" title="114"><span class="va">q</span>.<span class="at">insert</span>(<span class="dv">5</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-115" title="115"><span class="va">q</span>.<span class="at">insert</span>(<span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-116" title="116"><span class="va">q</span>.<span class="at">insert</span>(<span class="dv">4</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-117" title="117"><span class="va">q</span>.<span class="at">insert</span>(<span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-118" title="118"><span class="va">q</span>.<span class="at">insert</span>(<span class="dv">7</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-119" title="119"><span class="va">q</span>.<span class="at">insert</span>(<span class="dv">6</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-120" title="120"><span class="va">q</span>.<span class="at">insert</span>(<span class="dv">3</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-121" title="121"><span class="va">q</span>.<span class="at">insert</span>(<span class="dv">8</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-122" title="122"><span class="va">q</span>.<span class="at">print</span>()<span class="op">;</span> <span class="co">// [ 1, 2, 3, 5, 7, 6, 4, 8 ]</span></a>
<a class="sourceLine" id="cb2-123" title="123"><span class="va">q</span>.<span class="at">heapSort</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb2-124" title="124"><span class="va">q</span>.<span class="at">print</span>()<span class="op">;</span> <span class="co">// [ 8, 7, 6, 5, 4, 3, 2, 1 ]</span></a></code></pre></div>
<p>{% endtab %} {% endtabs %}</p>
<h2 id="overview-of-heap">Overview of heap <a id="6d32"></a></h2>
<p>A heap is one common implementation of <a href="https://en.wikipedia.org/wiki/Priority_queue">a priority queue</a>. A priority queue contains items with some priority. You can always take an item out in the priority order from a priority queue. It is important to take an item out based on the priority. When you look around poster presentations at an academic conference, it is very possible you have set in order to pick some presentations. Or you will make a priority list before you go sight-seeing (In this case, an item will be a tourist spot.). A stack and a queue also contain items. You can take an item out from a stack if the item is the last one added to the stack. This is first in, last out (FILO). As for a queue, you can take an item out from the queue if this item is the first one added to the queue. This is first in, first out (FIFO). You can regard these as a specific type of a priority queue. This is because the priority of an inserted item in stack increases and the priority of an inserted item in a queue decreases.<img src="https://miro.medium.com/max/60/1*oN767xTYckRTUjTIyS3oyw.png?q=20" /></p>
<p><img src="https://miro.medium.com/max/409/1*oN767xTYckRTUjTIyS3oyw.png" /></p>
<h2 id="representation">2. Representation <a id="b367"></a></h2>
<p>A heap is one of the tree structures and represented as a binary tree. I put the image of heap below. You can implement a tree structure by a pointer or an array. In this post, I choose to use the array implementation like below. In terms of space complexity, the array implementation has more benefits than the pointer implementation. The indices of the array correspond to the node number in the below image.<img src="https://miro.medium.com/max/60/1*ds0JXOw3lLqNo6hw__NtZw.png?q=20" /></p>
<p><img src="https://miro.medium.com/max/564/1*ds0JXOw3lLqNo6hw__NtZw.png" /></p>
<p>The heap above is called <em>a min heap</em>, and <strong>each value of nodes is less than or equal to the value of child nodes</strong>_<strong>.</strong>_ We call this condition the heap property.<img src="https://miro.medium.com/max/60/1*MaIob54cy5Z7iL1TAEDt1A.png?q=20" /></p>
<p><img src="https://miro.medium.com/max/258/1*MaIob54cy5Z7iL1TAEDt1A.png" /></p>
<p>In a min heap, when you look at the parent node and its child nodes, the parent node always has the smallest value. When a heap has an opposite definition, we call it <em>a max heap</em>. For the following discussions, we call a min heap a heap.</p>
<p>You can access a parent node or a child nodes in the array with indices below.</p>
<ul>
<li>A root node ｜<em>i</em> = 1, the first item of the array</li>
<li>A parent node ｜ parent(<em>i</em>) = <em>i</em> / 2</li>
<li>A left child node ｜ left(<em>i</em>) = 2<em>i</em></li>
<li>A right child node ｜ right(<em>i</em>)=2<em>i</em>+1</li>
</ul>
<p>When you look at the node of index 4, the relation of nodes in the tree corresponds to the indices of the array below.<img src="https://miro.medium.com/max/60/1*ysSV1xV0OMm-1amWBpFb0A.png?q=20" /></p>
<p><img src="https://miro.medium.com/max/552/1*ysSV1xV0OMm-1amWBpFb0A.png" /></p>
<p>The parent node corresponds to the item of index 2 by parent(<em>i</em>) = 4 / 2 = 2. The child nodes correspond to the items of index 8 and 9 by left(<em>i</em>) = 2 * 2 = 4, right(<em>i</em>) = 2 * 2 + 1 = 5, respectively.</p>
<h2 id="the-way-how-to-build-a-heap">3. The way how to build a heap <a id="5173"></a></h2>
<p>You need two operations to build a heap from an arbitrary array.</p>
<ol type="1">
<li><code>min_heapify</code>｜ make some node and its descendant nodes meet the heap property.</li>
<li><code>build_min_heap</code>｜ produce a heap from an arbitrary array.</li>
</ol>
<p>We can build a heap by applying <em>min_heapify</em> to each node repeatedly.</p>
<h3 id="min_heapify">3.1 min_heapify <a id="ebe4"></a></h3>
<p>In <em>min_heapify</em>, we exchange some nodes with its child nodes to satisfy the heap property under these two features below;</p>
<ol type="1">
<li>Some node and its child nodes don’t satisfy the heap property,</li>
<li>That child nodes and its descendant nodes satisfy the property.</li>
</ol>
<p>A tree structure has the two features below.<img src="https://miro.medium.com/max/60/1*7GdM58KmWHBgEE-yOSRy4Q.png?q=20" /></p>
<p><img src="https://miro.medium.com/max/519/1*7GdM58KmWHBgEE-yOSRy4Q.png" /></p>
<p>Look at the nodes surrounded by the orange square. We find that 9 is larger than both of 2 and 3, so these three nodes don’t satisfy the heap property (The value of node should be less than or equal to the values of its child nodes). Please check the orange nodes below.<img src="https://miro.medium.com/max/60/1*iDBRhJGiIyCBIAdVOMQnyg.png?q=20" /></p>
<p><img src="https://miro.medium.com/max/507/1*iDBRhJGiIyCBIAdVOMQnyg.png" /></p>
<p>However, look at the blue nodes. These nodes satisfy the heap property.<img src="https://miro.medium.com/max/60/1*8DJyn5AJMYp4DqWgv0dJAg.png?q=20" /></p>
<p><img src="https://miro.medium.com/max/559/1*8DJyn5AJMYp4DqWgv0dJAg.png" /></p>
<p>Here we define <em>min_heapify</em>(<em>array</em>, <em>index</em>). This method takes two arguments, <em>array,</em> and <em>index</em>. We assume this method exchange the node of <em>array</em>[<em>index</em>] with its child nodes to satisfy the heap property.</p>
<p>Let’s check the way how <em>min_heapify</em> works by producing a heap from the tree structure above. First, we call <em>min_heapify</em>(<em>array</em>, 2) to exchange the node of index 2 with the node of index 4.<img src="https://miro.medium.com/max/60/1*6ZsaVxXdLu0fyOz99GD1vg.png?q=20" /></p>
<p><img src="https://miro.medium.com/max/522/1*6ZsaVxXdLu0fyOz99GD1vg.png" /></p>
<p>After apply <em>min_heapify</em>(<em>array</em>, 2) to the subtree, the subtree changes below and meets the heap property. This subtree colored blue.<img src="https://miro.medium.com/max/60/1*Pg5r3aNAcMluu2YafmcOEw.png?q=20" /></p>
<p><img src="https://miro.medium.com/max/530/1*Pg5r3aNAcMluu2YafmcOEw.png" /></p>
<p>If the subtree exchanged the node of index 2 with the node of index5, the subtree won’t meet the heap property like below. So the subtree exchange the node has the smallest value in the subtree with the parent node to satisfy the heap property.<img src="https://miro.medium.com/max/60/1*1MXtFjQWaWTqNTGakj4DNg.png?q=20" /></p>
<p><img src="https://miro.medium.com/max/527/1*1MXtFjQWaWTqNTGakj4DNg.png" /></p>
<p>Get back to the tree correctly exchanged. When we look at the orange nodes, this subtree doesn’t satisfy the heap property.<img src="https://miro.medium.com/max/60/1*sE-XfLcquAc8u1Xzxe5PmA.png?q=20" /></p>
<p><img src="https://miro.medium.com/max/564/1*sE-XfLcquAc8u1Xzxe5PmA.png" /></p>
<p>So call <em>min_heapify</em>(<em>array</em>, 4) to make the subtree meet the heap property.<img src="https://miro.medium.com/max/60/1*NGqt-gG64O_X1GJei_MdJQ.png?q=20" /></p>
<p><img src="https://miro.medium.com/max/532/1*NGqt-gG64O_X1GJei_MdJQ.png" /></p>
<p>Now, this subtree satisfies the heap property by exchanging the node of index 4 with the node of index 8.</p>
<p>These operations above produce the heap from the unordered tree (the array).</p>
<h3 id="build_min_heap">3.2 build_min_heap <a id="caed"></a></h3>
<p>The pseudo-code below stands for how <em>build_min_heap</em> works.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1">build_min_heap(array)</a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="cf">for</span> i<span class="op">=</span>n<span class="op">/</span><span class="dv">2</span> downto <span class="dv">1</span></a>
<a class="sourceLine" id="cb3-3" title="3">        do min_heapify(array, i)</a></code></pre></div>
<p>This function iterates the nodes except the leaf nodes with the for-loop and applies <em>min_heapify</em> to each node. We don’t need to apply <em>min_heapify</em> to the items of indices after <em>n</em>/2+1, which are all the leaf nodes. We apply <em>min_heapify in</em> the orange nodes below.<img src="https://miro.medium.com/max/60/1*Qa4zV-Ys8iXRbPCt2Xt3Zw.png?q=20" /></p>
<p><img src="https://miro.medium.com/max/591/1*Qa4zV-Ys8iXRbPCt2Xt3Zw.png" /></p>
<p>Each node can satisfy the heap property with meeting the conditions to be able to apply <em>min_heapfiy.</em> This is because this function iterates the nodes from the bottom (the second last level) to the top (the root node level). For instance, this function first applies <em>min_heapify</em> to the nodes both of index 4 and index 5 and then applying <em>min_heapify</em> to the node of index 2. So the node of the index and its descendent nodes satisfy the heap property when applying <em>min_heapify.</em></p>
<h2 id="time-complexity">4. Time complexity <a id="afb9"></a></h2>
<p>Let’s think about the time complexity of <em>build_min_heap.</em> First of all, we think the time complexity of <em>min_heapify</em>, which is a main part of <em>build_min_heap.</em></p>
<p><em>min_heapify</em> repeats the operation of exchanging the items in an array, which runs in constant time. So the time complexity of <em>min_heapify</em> will be in proportional to the number of repeating. In the worst case, <em>min_heapify</em> should repeat the operation the height of the tree times. This is because in the worst case, min_heapify will exchange the root nodes with the most depth leaf node. Assuming <em>h</em> as the height of the root node, the time complexity of <em>min_heapify</em> will take <em>O</em>(<em>h</em>) time.</p>
<p>The time complexities of <em>min_heapify</em> in each depth are shown below. The number of the nodes is also showed in right.<img src="https://miro.medium.com/max/60/1*a-h1jgMmLuIFq_ZhuMmBnw.png?q=20" /></p>
<p><img src="https://miro.medium.com/max/591/1*a-h1jgMmLuIFq_ZhuMmBnw.png" /></p>
<p>From the figure, the time complexity of <em>build_min_heap</em> will be the sum of the time complexity of inner nodes. The final time complexity becomes:<img src="https://miro.medium.com/max/60/1*nlTVz17IMbUwcrs6SxEWrw.png?q=20" /><img src="https://miro.medium.com/max/591/1*nlTVz17IMbUwcrs6SxEWrw.png" /></p>
<p>So we should know the height of the tree to get the time complexity.</p>
<p>The sum of the number of nodes in each depth will become <em>n</em>. So we will get this equation below.<img src="https://miro.medium.com/max/60/1*OA6ZyHHxwRFMDdspJooQ1A.png?q=20" /><img src="https://miro.medium.com/max/451/1*OA6ZyHHxwRFMDdspJooQ1A.png" /></p>
<p>The equation above stands for the geometric sequence, so we can deform it and get the height of the tree as follow:<img src="https://miro.medium.com/max/60/1*etWYXqoPtFIl5C7j-K_TiA.png?q=20" /><img src="https://miro.medium.com/max/591/1*etWYXqoPtFIl5C7j-K_TiA.png" /></p>
<p>Finally, we get <em>O</em>(<em>n</em>) as the time complexity of <em>build_min_heap</em>. Also, we get <em>O</em>(log<em>n</em>) as the time complexity of <em>min_heapify</em>.</p>
<h2 id="implementation">5. Implementation <a id="5c96"></a></h2>
<p>Here we implement <em>min_heapify</em> and <em>build_min_heap</em> with Python. the implementation of <em>min_heapify</em> will be as follow.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">def</span> min_heapify(array, i):</a>
<a class="sourceLine" id="cb4-2" title="2">    left <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> i <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-3" title="3">    right <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> i <span class="op">+</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb4-4" title="4">    length <span class="op">=</span> <span class="bu">len</span>(array) <span class="op">-</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-5" title="5">    smallest <span class="op">=</span> i    <span class="cf">if</span> left <span class="op">&lt;=</span> length <span class="kw">and</span> array[i] <span class="op">&gt;</span> array[left]:</a>
<a class="sourceLine" id="cb4-6" title="6">        smallest <span class="op">=</span> left</a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="cf">if</span> right <span class="op">&lt;=</span> length <span class="kw">and</span> array[smallest] <span class="op">&gt;</span> array[right]:</a>
<a class="sourceLine" id="cb4-8" title="8">        smallest <span class="op">=</span> right</a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="cf">if</span> smallest <span class="op">!=</span> i:</a>
<a class="sourceLine" id="cb4-10" title="10">        array[i], array[smallest] <span class="op">=</span> array[smallest], array[i]</a>
<a class="sourceLine" id="cb4-11" title="11">        min_heapify(array, smallest)</a></code></pre></div>
<p>First, this method computes the node of the smallest value among the node of index <em>i</em> and its child nodes and then exchange the node of the smallest value with the node of index <em>i</em>. When the exchange happens, this method applies <em>min_heapify</em> to the node exchanged.</p>
<p>Index of a list (an array) in Python starts from 0, the way to access the nodes will change as follow.</p>
<ul>
<li>The root node ｜<em>i</em> = 0</li>
<li>The parent node ｜ parent(<em>i</em>) = (<em>i</em>-1) / 2</li>
<li>The left child node ｜ left(<em>i</em>) = 2<em>i</em> + 1</li>
<li>The right child node ｜ right(<em>i</em>)=2<em>i</em>+2</li>
</ul>
<p>The variable, <em>smallest</em> has the index of the node of the smallest value. If the <em>smallest</em> doesn’t equal to the <em>i</em>, which means this subtree doesn’t satisfy the heap property, this method exchanges the nodes and executes <em>min_heapify</em> to the node of the <em>smallest</em>.</p>
<p>The implementation of <em>build_min_heap</em> is almost the same as the pseudo-code.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">def</span> build_min_heap(array):</a>
<a class="sourceLine" id="cb5-2" title="2">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">reversed</span>(<span class="bu">range</span>(<span class="bu">len</span>(array)<span class="op">//</span><span class="dv">2</span>)):</a>
<a class="sourceLine" id="cb5-3" title="3">        min_heapify(array, i)</a></code></pre></div>
<p>The for-loop differs from the pseudo-code, but the behavior is the same. This for-loop also iterates the nodes from the second last level of nodes to the root nodes.</p>
<h2 id="heapsort">6. Heapsort <a id="91ea"></a></h2>
<p>Heapsort is one sort algorithm with a heap. It’s really easy to implement it with <em>min_heapify</em> and <em>build_min_heap.</em> The flow of sort will be as follow. Please note that the order of sort is ascending.</p>
<ol type="1">
<li>Build a heap from an arbitrary array with <em>build_min_heap.</em></li>
<li>Swap the first item with the last item in the array.</li>
<li>Remove the last item from the array.</li>
<li>Run <em>min_heapify</em> to the first item.</li>
<li>Back to step 2.</li>
</ol>
<p>In a heap, the smallest item is the first item of an array. The array after step 3 satisfies the conditions to apply <em>min_heapify</em> because we remove the last item after we swap the first item with the last item. By this nature, we can sort an array by repeating steps 2 to 4.</p>
<p>The implementation of heapsort will become as follow.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">def</span> heapsort(array):</a>
<a class="sourceLine" id="cb6-2" title="2">    array <span class="op">=</span> array.copy()</a>
<a class="sourceLine" id="cb6-3" title="3">    build_min_heap(array)    sorted_array <span class="op">=</span> []</a>
<a class="sourceLine" id="cb6-4" title="4">    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(array)):</a>
<a class="sourceLine" id="cb6-5" title="5">        array[<span class="dv">0</span>], array[<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> array[<span class="op">-</span><span class="dv">1</span>], array[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb6-6" title="6">        sorted_array.append(array.pop())</a>
<a class="sourceLine" id="cb6-7" title="7">        min_heapify(array, <span class="dv">0</span>)    <span class="cf">return</span> sorted_array</a></code></pre></div>
<p>The time complexity of heapsort is <em>O</em>(<em>n_log_n</em>) because in the worst case, we should repeat <em>min_heapify</em> the number of items in array times, which is <em>n</em>.</p>
<p>In <a href="https://docs.python.org/3/library/heapq.html">the heapq module</a> of Python, it has already implemented some operation for a heap. I followed the method in MIT’s lecture, the implementation differs from Python’s. If you’d like to know Python’s detail implementation, please visit <a href="https://github.com/python/cpython/blob/master/Lib/heapq.py">the source code here</a>. For example, these methods are implemented in Python.</p>
<ul>
<li><code>heapq.heapify</code> | corresponds to <em>build_min_heap</em></li>
<li><code>heapq.heapop</code> | corresponds to swapping items, remove the last item, and <em>min_heapify</em> at once<em>.</em></li>
</ul>
<p>By using those methods above, we can implement heapsort as follow. Please note that it differs from <a href="https://docs.python.org/3/library/heapq.html#basic-examples">the implementation of heapsort in the official documents</a>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" title="1"><span class="im">import</span> heapqdef heapsort(array):</a>
<a class="sourceLine" id="cb7-2" title="2">    h <span class="op">=</span> array.copy()</a>
<a class="sourceLine" id="cb7-3" title="3">    heapq.heapify(h)</a>
<a class="sourceLine" id="cb7-4" title="4">    <span class="cf">return</span> [heapq.heappop(h) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(array))]</a></code></pre></div>
<p>So that’s all for this post. Thank you for reading!</p>
<h3 id="references">References <a id="9803"></a></h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=B7hVxCmfPtM">MIT OpenCourseWare 4. Heaps and Heap Sort</a></li>
</ul>
<h2 id="implementation-1">Implementation</h2>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb8-1" title="1"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="co">Heaps (priority queues)</span></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="co"># the maximum number of items that can be stored in the heap</span></a>
<a class="sourceLine" id="cb8-5" title="5">CAPACITY <span class="op">=</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb8-6" title="6"></a>
<a class="sourceLine" id="cb8-7" title="7"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb8-8" title="8"><span class="co">*** Max Heap ***</span></a>
<a class="sourceLine" id="cb8-9" title="9"><span class="co">----------------</span></a>
<a class="sourceLine" id="cb8-10" title="10"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb8-11" title="11"></a>
<a class="sourceLine" id="cb8-12" title="12"></a>
<a class="sourceLine" id="cb8-13" title="13"><span class="co"># define the heap class</span></a>
<a class="sourceLine" id="cb8-14" title="14"><span class="kw">class</span> Heap(<span class="bu">object</span>):</a>
<a class="sourceLine" id="cb8-15" title="15"></a>
<a class="sourceLine" id="cb8-16" title="16">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb8-17" title="17">        <span class="co"># create array with as many slots as the CAPACITY</span></a>
<a class="sourceLine" id="cb8-18" title="18">        <span class="va">self</span>.heap <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> CAPACITY</a>
<a class="sourceLine" id="cb8-19" title="19">        <span class="co"># track the size of the heap (the number of items in the heap)</span></a>
<a class="sourceLine" id="cb8-20" title="20">        <span class="va">self</span>.heap_size <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb8-21" title="21"></a>
<a class="sourceLine" id="cb8-22" title="22">    <span class="co"># insertion takes O(1) running time BUT we have to make sure that hte</span></a>
<a class="sourceLine" id="cb8-23" title="23">    <span class="co"># heap properties are not violated (it takes O(logN) because of the</span></a>
<a class="sourceLine" id="cb8-24" title="24">    <span class="co"># fixUp() method)</span></a>
<a class="sourceLine" id="cb8-25" title="25">    <span class="kw">def</span> insert(<span class="va">self</span>, item):</a>
<a class="sourceLine" id="cb8-26" title="26">        <span class="co"># if the heap is at CAPACITY already we can not insert any more items</span></a>
<a class="sourceLine" id="cb8-27" title="27">        <span class="cf">if</span> CAPACITY <span class="op">==</span> <span class="va">self</span>.heap_size:</a>
<a class="sourceLine" id="cb8-28" title="28">            <span class="cf">return</span></a>
<a class="sourceLine" id="cb8-29" title="29"></a>
<a class="sourceLine" id="cb8-30" title="30">        <span class="co"># insert the item at the index of the size of the heap (the last</span></a>
<a class="sourceLine" id="cb8-31" title="31">        <span class="co"># empty spot) and then increment the counter</span></a>
<a class="sourceLine" id="cb8-32" title="32">        <span class="va">self</span>.heap[<span class="va">self</span>.heap_size] <span class="op">=</span> item</a>
<a class="sourceLine" id="cb8-33" title="33">        <span class="va">self</span>.heap_size <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb8-34" title="34"></a>
<a class="sourceLine" id="cb8-35" title="35">        <span class="co"># after insert check to see if the heap properties were violated and</span></a>
<a class="sourceLine" id="cb8-36" title="36">        <span class="co"># if so fix them</span></a>
<a class="sourceLine" id="cb8-37" title="37">        <span class="va">self</span>.fix_up(<span class="va">self</span>.heap_size <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb8-38" title="38"></a>
<a class="sourceLine" id="cb8-39" title="39">    <span class="co"># we consider the last item and check whether swaps are needed or not</span></a>
<a class="sourceLine" id="cb8-40" title="40">    <span class="co"># running time O(logN)</span></a>
<a class="sourceLine" id="cb8-41" title="41">    <span class="kw">def</span> fix_up(<span class="va">self</span>, index):</a>
<a class="sourceLine" id="cb8-42" title="42"></a>
<a class="sourceLine" id="cb8-43" title="43">        <span class="co"># get the parent index of the given node in the heap</span></a>
<a class="sourceLine" id="cb8-44" title="44">        parent_index <span class="op">=</span> (index <span class="op">-</span> <span class="dv">1</span>) <span class="op">//</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb8-45" title="45"></a>
<a class="sourceLine" id="cb8-46" title="46">        <span class="co"># while the index &gt; 0 means until we consider all the items &quot;above&quot;</span></a>
<a class="sourceLine" id="cb8-47" title="47">        <span class="co"># the one we inserted we have to swap the node with the parent if the</span></a>
<a class="sourceLine" id="cb8-48" title="48">        <span class="co"># heap property is violated</span></a>
<a class="sourceLine" id="cb8-49" title="49">        <span class="co"># this is a MAX HEAP: largest items are in the higher layers (max</span></a>
<a class="sourceLine" id="cb8-50" title="50">        <span class="co"># item == root node)</span></a>
<a class="sourceLine" id="cb8-51" title="51">        <span class="cf">if</span> index <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> <span class="va">self</span>.heap[index] <span class="op">&gt;</span> <span class="va">self</span>.heap[parent_index]:</a>
<a class="sourceLine" id="cb8-52" title="52">            <span class="va">self</span>.swap(index, parent_index)</a>
<a class="sourceLine" id="cb8-53" title="53">            <span class="co"># run the check again after the swap on the parent</span></a>
<a class="sourceLine" id="cb8-54" title="54">            <span class="va">self</span>.fix_up(parent_index)</a>
<a class="sourceLine" id="cb8-55" title="55"></a>
<a class="sourceLine" id="cb8-56" title="56">    <span class="co"># Get max, return the root node.  Because this is a max heap the root is</span></a>
<a class="sourceLine" id="cb8-57" title="57">    <span class="co"># the max item.  Because this is an array it takes O(1) time</span></a>
<a class="sourceLine" id="cb8-58" title="58">    <span class="co"># this is the peek() method</span></a>
<a class="sourceLine" id="cb8-59" title="59">    <span class="kw">def</span> get_max(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb8-60" title="60">        <span class="cf">return</span> <span class="va">self</span>.heap[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb8-61" title="61"></a>
<a class="sourceLine" id="cb8-62" title="62">    <span class="co"># Get poll, returns the max item and also REMOVES the item from the heap</span></a>
<a class="sourceLine" id="cb8-63" title="63">    <span class="co"># note: we just dont care about that item anymore but because we have an</span></a>
<a class="sourceLine" id="cb8-64" title="64">    <span class="co"># array with fixed size we aren&#39;t able to get rid of it completely</span></a>
<a class="sourceLine" id="cb8-65" title="65">    <span class="co"># O(logN) running time</span></a>
<a class="sourceLine" id="cb8-66" title="66">    <span class="kw">def</span> poll(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb8-67" title="67"></a>
<a class="sourceLine" id="cb8-68" title="68">        <span class="bu">max</span> <span class="op">=</span> <span class="va">self</span>.get_max()</a>
<a class="sourceLine" id="cb8-69" title="69"></a>
<a class="sourceLine" id="cb8-70" title="70">        <span class="co"># first swap the first item with the last item</span></a>
<a class="sourceLine" id="cb8-71" title="71">        <span class="va">self</span>.swap(<span class="dv">0</span>, <span class="va">self</span>.heap_size <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb8-72" title="72">        <span class="co"># then decrement the heap size ( excludes the last item from the heap</span></a>
<a class="sourceLine" id="cb8-73" title="73">        <span class="co"># going forward thus &#39;removing it&#39;)</span></a>
<a class="sourceLine" id="cb8-74" title="74">        <span class="va">self</span>.heap_size <span class="op">=</span> <span class="va">self</span>.heap_size <span class="op">-</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb8-75" title="75"></a>
<a class="sourceLine" id="cb8-76" title="76">        <span class="co"># nex check if the heap properties have been violated and if so fix</span></a>
<a class="sourceLine" id="cb8-77" title="77">        <span class="co"># them ( fix down is similar to fix up but works from the root down )</span></a>
<a class="sourceLine" id="cb8-78" title="78">        <span class="va">self</span>.fix_down(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb8-79" title="79"></a>
<a class="sourceLine" id="cb8-80" title="80">        <span class="co"># finally return the max item removed</span></a>
<a class="sourceLine" id="cb8-81" title="81">        <span class="cf">return</span> <span class="bu">max</span></a>
<a class="sourceLine" id="cb8-82" title="82"></a>
<a class="sourceLine" id="cb8-83" title="83">    <span class="co"># fix down, we have a given item in the heap and we consider all the</span></a>
<a class="sourceLine" id="cb8-84" title="84">    <span class="co"># items below and check whether the heap properties are violated or not</span></a>
<a class="sourceLine" id="cb8-85" title="85">    <span class="kw">def</span> fix_down(<span class="va">self</span>, index):</a>
<a class="sourceLine" id="cb8-86" title="86"></a>
<a class="sourceLine" id="cb8-87" title="87">        <span class="co"># every node has 2 children so in the array the node i has left child</span></a>
<a class="sourceLine" id="cb8-88" title="88">        <span class="co"># with index *i+1 and right child with index 2*i+2</span></a>
<a class="sourceLine" id="cb8-89" title="89">        index_left <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> index <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb8-90" title="90">        index_right <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> index <span class="op">+</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb8-91" title="91">        <span class="co"># this is a max heap so the parent is always greater than the children</span></a>
<a class="sourceLine" id="cb8-92" title="92">        index_largest <span class="op">=</span> index</a>
<a class="sourceLine" id="cb8-93" title="93"></a>
<a class="sourceLine" id="cb8-94" title="94">        <span class="co"># if the left child is greater than the parent: largest is the left node</span></a>
<a class="sourceLine" id="cb8-95" title="95">        <span class="cf">if</span> index_left <span class="op">&lt;</span> <span class="va">self</span>.heap_size <span class="kw">and</span> <span class="va">self</span>.heap[index_left] <span class="op">&gt;</span> <span class="va">self</span>.heap[</a>
<a class="sourceLine" id="cb8-96" title="96">            index]:</a>
<a class="sourceLine" id="cb8-97" title="97">            index_largest <span class="op">=</span> index_left</a>
<a class="sourceLine" id="cb8-98" title="98"></a>
<a class="sourceLine" id="cb8-99" title="99">        <span class="co"># figure out if the left child or right child is the greater one</span></a>
<a class="sourceLine" id="cb8-100" title="100">        <span class="co"># first check if the given index is valid ( not larger than the heap</span></a>
<a class="sourceLine" id="cb8-101" title="101">        <span class="co"># size)</span></a>
<a class="sourceLine" id="cb8-102" title="102">        <span class="co"># if the right child is greater than the left child: largest is the</span></a>
<a class="sourceLine" id="cb8-103" title="103">        <span class="co"># right node</span></a>
<a class="sourceLine" id="cb8-104" title="104">        <span class="cf">if</span> index_right <span class="op">&lt;</span> <span class="va">self</span>.heap_size <span class="kw">and</span> <span class="va">self</span>.heap[index_right] <span class="op">&gt;</span> <span class="op">\</span></a>
<a class="sourceLine" id="cb8-105" title="105">                <span class="va">self</span>.heap[index_largest]:</a>
<a class="sourceLine" id="cb8-106" title="106">            index_largest <span class="op">=</span> index_right</a>
<a class="sourceLine" id="cb8-107" title="107"></a>
<a class="sourceLine" id="cb8-108" title="108">        <span class="co"># we don&#39;t want to swap items with themselves</span></a>
<a class="sourceLine" id="cb8-109" title="109">        <span class="cf">if</span> index <span class="op">!=</span> index_largest:</a>
<a class="sourceLine" id="cb8-110" title="110">            <span class="va">self</span>.swap(index, index_largest)</a>
<a class="sourceLine" id="cb8-111" title="111">            <span class="co"># recursively check down the tree for any other heap violations</span></a>
<a class="sourceLine" id="cb8-112" title="112">            <span class="co"># and fix them as needed</span></a>
<a class="sourceLine" id="cb8-113" title="113">            <span class="va">self</span>.fix_down(index_largest)</a>
<a class="sourceLine" id="cb8-114" title="114"></a>
<a class="sourceLine" id="cb8-115" title="115">    <span class="co"># we have N items and we want to sort them with a heap</span></a>
<a class="sourceLine" id="cb8-116" title="116">    <span class="co"># every poll operation takes O(logN) time because of the fix down</span></a>
<a class="sourceLine" id="cb8-117" title="117">    <span class="co"># method thats why the overall running time is O(NlogN) for heapsort</span></a>
<a class="sourceLine" id="cb8-118" title="118">    <span class="kw">def</span> heap_sort(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb8-119" title="119"></a>
<a class="sourceLine" id="cb8-120" title="120">        <span class="co"># we decrease the size of hte heap in the poll method so we have to</span></a>
<a class="sourceLine" id="cb8-121" title="121">        <span class="co"># store it</span></a>
<a class="sourceLine" id="cb8-122" title="122">        size <span class="op">=</span> <span class="va">self</span>.heap_size</a>
<a class="sourceLine" id="cb8-123" title="123"></a>
<a class="sourceLine" id="cb8-124" title="124">        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, size):</a>
<a class="sourceLine" id="cb8-125" title="125">            <span class="bu">max</span> <span class="op">=</span> <span class="va">self</span>.poll()</a>
<a class="sourceLine" id="cb8-126" title="126">            <span class="bu">print</span>(<span class="bu">max</span>)</a>
<a class="sourceLine" id="cb8-127" title="127"></a>
<a class="sourceLine" id="cb8-128" title="128">    <span class="co"># swap two items with (index1, index2) in the heap array</span></a>
<a class="sourceLine" id="cb8-129" title="129">    <span class="kw">def</span> swap(<span class="va">self</span>, index1, index2):</a>
<a class="sourceLine" id="cb8-130" title="130">        <span class="va">self</span>.heap[index2], <span class="va">self</span>.heap[index1] <span class="op">=</span> <span class="va">self</span>.heap[index1], <span class="va">self</span>.heap[index2]</a>
<a class="sourceLine" id="cb8-131" title="131"></a>
<a class="sourceLine" id="cb8-132" title="132">heap <span class="op">=</span> Heap()</a>
<a class="sourceLine" id="cb8-133" title="133">heap.insert(<span class="dv">10</span>)</a>
<a class="sourceLine" id="cb8-134" title="134">heap.insert(<span class="dv">8</span>)</a>
<a class="sourceLine" id="cb8-135" title="135">heap.insert(<span class="dv">12</span>)</a>
<a class="sourceLine" id="cb8-136" title="136">heap.insert(<span class="dv">20</span>)</a>
<a class="sourceLine" id="cb8-137" title="137">heap.insert(<span class="op">-</span><span class="dv">2</span>)</a>
<a class="sourceLine" id="cb8-138" title="138">heap.insert(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb8-139" title="139">heap.insert(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb8-140" title="140">heap.insert(<span class="dv">321</span>)</a>
<a class="sourceLine" id="cb8-141" title="141"></a>
<a class="sourceLine" id="cb8-142" title="142">heap.heap_sort()</a></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb9-1" title="1"><span class="co"># Implements a min-heap. For max-heap, simply reverse all comparison orders.</span></a>
<a class="sourceLine" id="cb9-2" title="2"><span class="co">#</span></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="co"># Note on alternate subroutine namings (used in some textbooks):</span></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="co">#     - _bubble_up = siftdown</span></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="co">#     - _bubble_down = siftup</span></a>
<a class="sourceLine" id="cb9-6" title="6"></a>
<a class="sourceLine" id="cb9-7" title="7"><span class="kw">def</span> _bubble_up(heap, i):</a>
<a class="sourceLine" id="cb9-8" title="8">    <span class="cf">while</span> i <span class="op">&gt;</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb9-9" title="9">        parent_i <span class="op">=</span> (i <span class="op">-</span> <span class="dv">1</span>) <span class="op">//</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb9-10" title="10">        <span class="cf">if</span> heap[i] <span class="op">&lt;</span> heap[parent_i]:</a>
<a class="sourceLine" id="cb9-11" title="11">            heap[i], heap[parent_i] <span class="op">=</span> heap[parent_i], heap[i]</a>
<a class="sourceLine" id="cb9-12" title="12">            i <span class="op">=</span> parent_i</a>
<a class="sourceLine" id="cb9-13" title="13">            <span class="cf">continue</span></a>
<a class="sourceLine" id="cb9-14" title="14">        <span class="cf">break</span></a>
<a class="sourceLine" id="cb9-15" title="15"></a>
<a class="sourceLine" id="cb9-16" title="16"><span class="kw">def</span> _bubble_down(heap, i):</a>
<a class="sourceLine" id="cb9-17" title="17">    startpos <span class="op">=</span> i</a>
<a class="sourceLine" id="cb9-18" title="18">    newitem <span class="op">=</span> heap[i]</a>
<a class="sourceLine" id="cb9-19" title="19">    left_i <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> i <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb9-20" title="20">    <span class="cf">while</span> left_i <span class="op">&lt;</span> <span class="bu">len</span>(heap):</a>
<a class="sourceLine" id="cb9-21" title="21">        <span class="co"># Pick the smaller of the L and R children</span></a>
<a class="sourceLine" id="cb9-22" title="22">        right_i <span class="op">=</span> left_i <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb9-23" title="23">        <span class="cf">if</span> right_i <span class="op">&lt;</span> <span class="bu">len</span>(heap) <span class="kw">and</span> <span class="kw">not</span> heap[left_i] <span class="op">&lt;</span> heap[right_i]:</a>
<a class="sourceLine" id="cb9-24" title="24">            child_i <span class="op">=</span> right_i</a>
<a class="sourceLine" id="cb9-25" title="25">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb9-26" title="26">            child_i <span class="op">=</span> left_i</a>
<a class="sourceLine" id="cb9-27" title="27"></a>
<a class="sourceLine" id="cb9-28" title="28">        <span class="co"># Break if heap invariant satisfied</span></a>
<a class="sourceLine" id="cb9-29" title="29">        <span class="cf">if</span> heap[i] <span class="op">&lt;</span> heap[child_i]:</a>
<a class="sourceLine" id="cb9-30" title="30">            <span class="cf">break</span></a>
<a class="sourceLine" id="cb9-31" title="31"></a>
<a class="sourceLine" id="cb9-32" title="32">        <span class="co"># Move the smaller child up.</span></a>
<a class="sourceLine" id="cb9-33" title="33">        heap[i], heap[child_i] <span class="op">=</span> heap[child_i], heap[i]</a>
<a class="sourceLine" id="cb9-34" title="34">        i <span class="op">=</span> child_i</a>
<a class="sourceLine" id="cb9-35" title="35">        left_i <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> i <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb9-36" title="36"></a>
<a class="sourceLine" id="cb9-37" title="37"><span class="kw">def</span> heapify(lst):</a>
<a class="sourceLine" id="cb9-38" title="38">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">reversed</span>(<span class="bu">range</span>(<span class="bu">len</span>(lst) <span class="op">//</span> <span class="dv">2</span>)):</a>
<a class="sourceLine" id="cb9-39" title="39">        _bubble_down(lst, i)</a>
<a class="sourceLine" id="cb9-40" title="40"></a>
<a class="sourceLine" id="cb9-41" title="41"><span class="kw">def</span> heappush(heap, item):</a>
<a class="sourceLine" id="cb9-42" title="42">    heap.append(item)</a>
<a class="sourceLine" id="cb9-43" title="43">    _bubble_up(heap, <span class="bu">len</span>(heap) <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb9-44" title="44"></a>
<a class="sourceLine" id="cb9-45" title="45"><span class="kw">def</span> heappop(heap):</a>
<a class="sourceLine" id="cb9-46" title="46">    <span class="cf">if</span> <span class="bu">len</span>(heap) <span class="op">==</span> <span class="dv">1</span>:</a>
<a class="sourceLine" id="cb9-47" title="47">        <span class="cf">return</span> heap.pop()</a>
<a class="sourceLine" id="cb9-48" title="48">    min_value <span class="op">=</span> heap[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb9-49" title="49">    heap[<span class="dv">0</span>] <span class="op">=</span> heap[<span class="op">-</span><span class="dv">1</span>]</a>
<a class="sourceLine" id="cb9-50" title="50">    <span class="kw">del</span> heap[<span class="op">-</span><span class="dv">1</span>]</a>
<a class="sourceLine" id="cb9-51" title="51">    _bubble_down(heap, <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb9-52" title="52">    <span class="cf">return</span> min_value</a>
<a class="sourceLine" id="cb9-53" title="53"></a>
<a class="sourceLine" id="cb9-54" title="54"></a>
<a class="sourceLine" id="cb9-55" title="55"></a>
<a class="sourceLine" id="cb9-56" title="56"><span class="co"># Example usage</span></a>
<a class="sourceLine" id="cb9-57" title="57">heap <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">0</span>]</a>
<a class="sourceLine" id="cb9-58" title="58">heapify(heap)</a>
<a class="sourceLine" id="cb9-59" title="59"><span class="bu">print</span>(<span class="st">&#39;Heap(0, 1, 2, 3):&#39;</span>, heap)</a>
<a class="sourceLine" id="cb9-60" title="60">heappush(heap, <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb9-61" title="61">heappush(heap, <span class="dv">7</span>)</a>
<a class="sourceLine" id="cb9-62" title="62">heappush(heap, <span class="dv">6</span>)</a>
<a class="sourceLine" id="cb9-63" title="63">heappush(heap, <span class="dv">5</span>)</a>
<a class="sourceLine" id="cb9-64" title="64"><span class="bu">print</span>(<span class="st">&#39;Heap(0, 1, 2, 3, 4, 5, 6, 7):&#39;</span>, heap)</a>
<a class="sourceLine" id="cb9-65" title="65"></a>
<a class="sourceLine" id="cb9-66" title="66">sorted_list <span class="op">=</span> [heappop(heap) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">8</span>)]</a>
<a class="sourceLine" id="cb9-67" title="67"><span class="bu">print</span>(<span class="st">&#39;Heap-sorted list:&#39;</span>, sorted_list)</a>
<a class="sourceLine" id="cb9-68" title="68"></a>
<a class="sourceLine" id="cb9-69" title="69"><span class="co"># Large test case, for randomized tests</span></a>
<a class="sourceLine" id="cb9-70" title="70"><span class="im">import</span> random</a>
<a class="sourceLine" id="cb9-71" title="71"></a>
<a class="sourceLine" id="cb9-72" title="72"><span class="co"># Heapify 0 ~ 99</span></a>
<a class="sourceLine" id="cb9-73" title="73">heap <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="dv">100</span>))</a>
<a class="sourceLine" id="cb9-74" title="74">random.shuffle(heap)</a>
<a class="sourceLine" id="cb9-75" title="75">heapify(heap)</a>
<a class="sourceLine" id="cb9-76" title="76"></a>
<a class="sourceLine" id="cb9-77" title="77"><span class="co"># Push 100 ~ 199 in random order</span></a>
<a class="sourceLine" id="cb9-78" title="78">new_elems <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="dv">100</span>, <span class="dv">200</span>))</a>
<a class="sourceLine" id="cb9-79" title="79">random.shuffle(new_elems)</a>
<a class="sourceLine" id="cb9-80" title="80"><span class="cf">for</span> elem <span class="kw">in</span> new_elems:</a>
<a class="sourceLine" id="cb9-81" title="81">    heappush(heap, elem)</a>
<a class="sourceLine" id="cb9-82" title="82"></a>
<a class="sourceLine" id="cb9-83" title="83">sorted_list <span class="op">=</span> [heappop(heap) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">200</span>)]</a>
<a class="sourceLine" id="cb9-84" title="84"><span class="bu">print</span>(sorted_list <span class="op">==</span> <span class="bu">sorted</span>(sorted_list))</a></code></pre></div>
<p>{% page-ref page=“../array/” %}</p>
<p>{% page-ref page=“../binary-search-tree/” %}</p>
<p>{% page-ref page=“../untitled-4/” %}</p>
<p>{% page-ref page=“../array/extra-array.md” %}</p>
<p>{% page-ref page=“../stack/” %}</p>
<p>{% page-ref page=“../binary-tree/” %}</p>
<p>{% page-ref page=“../untitled-6/” %}</p>
<p>{% page-ref page=“../untitled-5/” %}</p>
<p>{% page-ref page=“../untitled-2/” %}</p>
<p>{% page-ref page=“../untitled-3/” %}</p>
<p>{% page-ref page=“../queue/queue-sandbox.md” %}</p>
<p>{% page-ref page=“../untitled-5/” %}</p>
<p>{% page-ref page=“../untitled-4/double-linked-list.md” %}</p>
<p>{% page-ref page=“../untitled-1/” %}</p>
<p>{% page-ref page=“../untitled/” %}</p>
<p>{% page-ref page=“./” %}</p>
</body>
</html>
