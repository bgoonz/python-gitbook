<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>find-the-maximum-path-sum-between-two-leaves-of-a-binary-tree</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
    <style type="text/css">
      a.sourceLine {
        display: inline-block;
        line-height: 1.25;
      }
      a.sourceLine {
        pointer-events: none;
        color: inherit;
        text-decoration: inherit;
      }
      a.sourceLine:empty {
        height: 1.2em;
      }
      .sourceCode {
        overflow: visible;
      }
      code.sourceCode {
        white-space: pre;
        position: relative;
      }
      div.sourceCode {
        margin: 1em 0;
      }
      pre.sourceCode {
        margin: 0;
      }
      @media screen {
        div.sourceCode {
          overflow: auto;
        }
      }
      @media print {
        code.sourceCode {
          white-space: pre-wrap;
        }
        a.sourceLine {
          text-indent: -1em;
          padding-left: 1em;
        }
      }
      pre.numberSource a.sourceLine {
        position: relative;
        left: -4em;
      }
      pre.numberSource a.sourceLine::before {
        content: attr(title);
        position: relative;
        left: -1em;
        text-align: right;
        vertical-align: baseline;
        border: none;
        pointer-events: all;
        display: inline-block;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        padding: 0 4px;
        width: 4em;
        color: #aaaaaa;
      }
      pre.numberSource {
        margin-left: 3em;
        border-left: 1px solid #aaaaaa;
        padding-left: 4px;
      }
      div.sourceCode {
      }
      @media screen {
        a.sourceLine::before {
          text-decoration: underline;
        }
      }
      code span.al {
        color: #ff0000;
        font-weight: bold;
      } /* Alert */
      code span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Annotation */
      code span.at {
        color: #7d9029;
      } /* Attribute */
      code span.bn {
        color: #40a070;
      } /* BaseN */
      code span.bu {
      } /* BuiltIn */
      code span.cf {
        color: #007020;
        font-weight: bold;
      } /* ControlFlow */
      code span.ch {
        color: #4070a0;
      } /* Char */
      code span.cn {
        color: #880000;
      } /* Constant */
      code span.co {
        color: #60a0b0;
        font-style: italic;
      } /* Comment */
      code span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* CommentVar */
      code span.do {
        color: #ba2121;
        font-style: italic;
      } /* Documentation */
      code span.dt {
        color: #902000;
      } /* DataType */
      code span.dv {
        color: #40a070;
      } /* DecVal */
      code span.er {
        color: #ff0000;
        font-weight: bold;
      } /* Error */
      code span.ex {
      } /* Extension */
      code span.fl {
        color: #40a070;
      } /* Float */
      code span.fu {
        color: #06287e;
      } /* Function */
      code span.im {
      } /* Import */
      code span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Information */
      code span.kw {
        color: #007020;
        font-weight: bold;
      } /* Keyword */
      code span.op {
        color: #666666;
      } /* Operator */
      code span.ot {
        color: #007020;
      } /* Other */
      code span.pp {
        color: #bc7a00;
      } /* Preprocessor */
      code span.sc {
        color: #4070a0;
      } /* SpecialChar */
      code span.ss {
        color: #bb6688;
      } /* SpecialString */
      code span.st {
        color: #4070a0;
      } /* String */
      code span.va {
        color: #19177c;
      } /* Variable */
      code span.vs {
        color: #4070a0;
      } /* VerbatimString */
      code span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Warning */
    </style>
  </head>
  <body>
    <h1 id="find-the-maximum-path-sum-between-two-leaves-of-a-binary-tree">
      Find the maximum path sum between two leaves of a binary tree
    </h1>
    <p>
      Given a binary tree in which each node element contains a number. Find the
      maximum possible sum from one leaf node to another. The maximum sum path
      may or may not go through root. For example, in the following binary tree,
      the maximum sum is <strong>27</strong>(3 + 6 + 9 + 0 - 1 + 10). Expected
      time complexity is O(n). If one side of root is empty, then function
      should return minus infinite (INT_MIN in case of C/C++)
      <img
        src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/tree.png"
        alt="tree"
      />
    </p>
    <p>
      <a href="https://practice.geeksforgeeks.org/problems/maximum-path-sum/1"
        >Recommended: Please solve it on “<strong>PRACTICE</strong>” first,
        before moving on to the solution.</a
      >
    </p>
    <p>
      A simple solution is to traverse the tree and do following for every
      traversed node X. 1) Find maximum sum from leaf to root in left subtree of
      X (we can use
      <a
        href="https://www.cdn.geeksforgeeks.org/find-the-maximum-sum-path-in-a-binary-tree/"
        >this post</a
      >
      for this and next steps) 2) Find maximum sum from leaf to root in right
      subtree of X. 3) Add the above two calculated values and X-&gt;data and
      compare the sum with the maximum value obtained so far and update the
      maximum value. 4) Return the maximum value. The time complexity of above
      solution is O(n2)
      <strong
        >We can find the maximum sum using single traversal of binary
        tree</strong
      >. The idea is to maintain two values in recursive calls
    </p>
    <p>
      (<strong
        >Note: If the tree is right-most or left-most tree then first we have to
        adjust the tree such that both the right and left are not null.
        Left-most means if the right of super root of the tree is null and
        right-most tree means if left of super root of the tree is
        null.)</strong
      >
    </p>
    <p>
      1) Maximum root to leaf path sum for the subtree rooted under current
      node. 2) The maximum path sum between leaves (desired output). For every
      visited node X, we find the maximum root to leaf sum in left and right
      subtrees of X. We add the two values with X-&gt;data, and compare the sum
      with maximum path sum found so far.
    </p>
    <p>Python</p>
    <div class="sourceCode" id="cb1">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="co"># Python program to find maximumpath sum between two leaves</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="co"># of a binary tree</span></a>
<a class="sourceLine" id="cb1-3" title="3"></a>
<a class="sourceLine" id="cb1-4" title="4">INT_MIN <span class="op">=</span> <span class="dv">-2</span><span class="op">**</span><span class="dv">32</span></a>
<a class="sourceLine" id="cb1-5" title="5"></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="co"># A binary tree node</span></a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8"></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="kw">class</span> Node:</a>
<a class="sourceLine" id="cb1-10" title="10">    <span class="co"># Constructor to create a new node</span></a>
<a class="sourceLine" id="cb1-11" title="11">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, data):</a>
<a class="sourceLine" id="cb1-12" title="12">        <span class="va">self</span>.data <span class="op">=</span> data</a>
<a class="sourceLine" id="cb1-13" title="13">        <span class="va">self</span>.left <span class="op">=</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb1-14" title="14">        <span class="va">self</span>.right <span class="op">=</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb1-15" title="15"></a>
<a class="sourceLine" id="cb1-16" title="16"><span class="co"># Utility function to find maximum sum between any</span></a>
<a class="sourceLine" id="cb1-17" title="17"><span class="co"># two leaves. This function calculates two values:</span></a>
<a class="sourceLine" id="cb1-18" title="18"><span class="co"># 1) Maximum path sum between two leaves which are stored</span></a>
<a class="sourceLine" id="cb1-19" title="19"><span class="co">#    in res</span></a>
<a class="sourceLine" id="cb1-20" title="20"><span class="co"># 2) The maximum root to leaf path sum which is returned</span></a>
<a class="sourceLine" id="cb1-21" title="21"><span class="co"># If one side of root is empty, then it returns INT_MIN</span></a>
<a class="sourceLine" id="cb1-22" title="22"></a>
<a class="sourceLine" id="cb1-23" title="23"></a>
<a class="sourceLine" id="cb1-24" title="24"><span class="kw">def</span> maxPathSumUtil(root, res):</a>
<a class="sourceLine" id="cb1-25" title="25"></a>
<a class="sourceLine" id="cb1-26" title="26">    <span class="co"># Base Case</span></a>
<a class="sourceLine" id="cb1-27" title="27">    <span class="cf">if</span> root <span class="kw">is</span> <span class="va">None</span>:</a>
<a class="sourceLine" id="cb1-28" title="28">        <span class="cf">return</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb1-29" title="29"></a>
<a class="sourceLine" id="cb1-30" title="30">    <span class="co"># Find maximumsum in left and righ subtree. Also</span></a>
<a class="sourceLine" id="cb1-31" title="31">    <span class="co"># find maximum root to leaf sums in left and right</span></a>
<a class="sourceLine" id="cb1-32" title="32">    <span class="co"># subtrees ans store them in ls and rs</span></a>
<a class="sourceLine" id="cb1-33" title="33">    ls <span class="op">=</span> maxPathSumUtil(root.left, res)</a>
<a class="sourceLine" id="cb1-34" title="34">    rs <span class="op">=</span> maxPathSumUtil(root.right, res)</a>
<a class="sourceLine" id="cb1-35" title="35"></a>
<a class="sourceLine" id="cb1-36" title="36">    <span class="co"># If both left and right children exist</span></a>
<a class="sourceLine" id="cb1-37" title="37">    <span class="cf">if</span> root.left <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="kw">and</span> root.right <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</a>
<a class="sourceLine" id="cb1-38" title="38"></a>
<a class="sourceLine" id="cb1-39" title="39">        <span class="co"># update result if needed</span></a>
<a class="sourceLine" id="cb1-40" title="40">        res[<span class="dv">0</span>] <span class="op">=</span> <span class="bu">max</span>(res[<span class="dv">0</span>], ls <span class="op">+</span> rs <span class="op">+</span> root.data)</a>
<a class="sourceLine" id="cb1-41" title="41"></a>
<a class="sourceLine" id="cb1-42" title="42">        <span class="co"># Return maximum possible value for root being</span></a>
<a class="sourceLine" id="cb1-43" title="43">        <span class="co"># on one side</span></a>
<a class="sourceLine" id="cb1-44" title="44">        <span class="cf">return</span> <span class="bu">max</span>(ls, rs) <span class="op">+</span> root.data</a>
<a class="sourceLine" id="cb1-45" title="45"></a>
<a class="sourceLine" id="cb1-46" title="46">    <span class="co"># If any of the two children is empty, return</span></a>
<a class="sourceLine" id="cb1-47" title="47">    <span class="co"># root sum for root being on one side</span></a>
<a class="sourceLine" id="cb1-48" title="48">    <span class="cf">if</span> root.left <span class="kw">is</span> <span class="va">None</span>:</a>
<a class="sourceLine" id="cb1-49" title="49">        <span class="cf">return</span> rs <span class="op">+</span> root.data</a>
<a class="sourceLine" id="cb1-50" title="50">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb1-51" title="51">        <span class="cf">return</span> ls <span class="op">+</span> root.data</a>
<a class="sourceLine" id="cb1-52" title="52"></a>
<a class="sourceLine" id="cb1-53" title="53"><span class="co"># The main function which returns sum of the maximum</span></a>
<a class="sourceLine" id="cb1-54" title="54"><span class="co"># sum path betwee ntwo leaves. THis function mainly</span></a>
<a class="sourceLine" id="cb1-55" title="55"><span class="co"># uses maxPathSumUtil()</span></a>
<a class="sourceLine" id="cb1-56" title="56"></a>
<a class="sourceLine" id="cb1-57" title="57"></a>
<a class="sourceLine" id="cb1-58" title="58"><span class="kw">def</span> maxPathSum(root):</a>
<a class="sourceLine" id="cb1-59" title="59">    res <span class="op">=</span> [INT_MIN]</a>
<a class="sourceLine" id="cb1-60" title="60">    maxPathSumUtil(root, res)</a>
<a class="sourceLine" id="cb1-61" title="61">    <span class="cf">return</span> res[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb1-62" title="62"></a>
<a class="sourceLine" id="cb1-63" title="63"></a>
<a class="sourceLine" id="cb1-64" title="64"><span class="co"># Driver program to test above function</span></a>
<a class="sourceLine" id="cb1-65" title="65">root <span class="op">=</span> Node(<span class="op">-</span><span class="dv">15</span>)</a>
<a class="sourceLine" id="cb1-66" title="66">root.left <span class="op">=</span> Node(<span class="dv">5</span>)</a>
<a class="sourceLine" id="cb1-67" title="67">root.right <span class="op">=</span> Node(<span class="dv">6</span>)</a>
<a class="sourceLine" id="cb1-68" title="68">root.left.left <span class="op">=</span> Node(<span class="op">-</span><span class="dv">8</span>)</a>
<a class="sourceLine" id="cb1-69" title="69">root.left.right <span class="op">=</span> Node(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-70" title="70">root.left.left.left <span class="op">=</span> Node(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb1-71" title="71">root.left.left.right <span class="op">=</span> Node(<span class="dv">6</span>)</a>
<a class="sourceLine" id="cb1-72" title="72">root.right.left <span class="op">=</span> Node(<span class="dv">3</span>)</a>
<a class="sourceLine" id="cb1-73" title="73">root.right.right <span class="op">=</span> Node(<span class="dv">9</span>)</a>
<a class="sourceLine" id="cb1-74" title="74">root.right.right.right <span class="op">=</span> Node(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb1-75" title="75">root.right.right.right.left <span class="op">=</span> Node(<span class="dv">4</span>)</a>
<a class="sourceLine" id="cb1-76" title="76">root.right.right.right.right <span class="op">=</span> Node(<span class="op">-</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-77" title="77">root.right.right.right.right.left <span class="op">=</span> Node(<span class="dv">10</span>)</a>
<a class="sourceLine" id="cb1-78" title="78"></a>
<a class="sourceLine" id="cb1-79" title="79"><span class="bu">print</span> <span class="st">&quot;Max pathSum of the given binary tree is&quot;</span>, maxPathSum(root)</a>
<a class="sourceLine" id="cb1-80" title="80"></a>
<a class="sourceLine" id="cb1-81" title="81">ck_007)</a></code></pre>
    </div>
    <p><strong>Output</strong></p>
    <div class="sourceCode" id="cb2">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1">Max pathSum of the given binary tree <span class="kw">is</span> <span class="dv">27</span></a></code></pre>
    </div>
  </body>
</html>
