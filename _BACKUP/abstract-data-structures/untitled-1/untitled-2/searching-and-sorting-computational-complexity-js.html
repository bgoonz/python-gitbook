<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>searching-and-sorting-computational-complexity-js</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
  </head>
  <body>
    <h1 id="searching-sorting-computational-complexity-js">
      Searching &amp; Sorting Computational Complexity (JS)
    </h1>
    <h4 id="sorting-algorithms">Sorting Algorithms</h4>
    <h4 id="bubble-sort">Bubble Sort</h4>
    <p><code>Time Complexity</code>: Quadratic O(n^2)</p>
    <ul>
      <li>
        The inner for-loop contributes to O(n), however in a worst case scenario
        the while loop will need to run n times before bringing all n elements
        to their final resting spot.
      </li>
    </ul>
    <p><code>Space Complexity</code>: O(1)</p>
    <ul>
      <li>
        Bubble Sort will always use the same amount of memory regardless of n.
      </li>
    </ul>
    <p>
      <img src="https://cdn-images-1.medium.com/max/800/0*Ck9aeGY-d5tbz7dT" />
    </p>
    <p>
      {% embed
      url=“https://gist.github.com/eengineergz/e67e56bed7c5a20a54851867ba5efef6”
      %}
    </p>
    <ul>
      <li>
        The first major sorting algorithm one learns in introductory programming
        courses.
      </li>
      <li>Gives an intro on how to convert unsorted data into sorted data.</li>
    </ul>
    <blockquote>
      <p>It’s almost never used in production code because:</p>
    </blockquote>
    <ul>
      <li><em>It’s not efficient</em></li>
      <li><em>It’s not commonly used</em></li>
      <li><em>There is stigma attached to it</em></li>
      <li>
        <em
          ><code>Bubbling Up</code> : Term that infers that an item is in
          motion, moving in some direction, and has some final resting
          destination.</em
        >
      </li>
      <li>
        <em
          >Bubble sort, sorts an array of integers by bubbling the largest
          integer to the top.</em
        >
      </li>
    </ul>
    <p>
      <a
        href="https://gist.github.com/eengineergz/fd4acc0c89033bd219ebf9d3ec40b053"
        >https://gist.github.com/eengineergz/fd4acc0c89033bd219ebf9d3ec40b053</a
      ><a
        href="https://gist.github.com/eengineergz/80934783c628c70ac2a5a48119a82d54"
        >https://gist.github.com/eengineergz/80934783c628c70ac2a5a48119a82d54</a
      >
    </p>
    <ul>
      <li>
        <em
          >Worst Case &amp; Best Case are always the same because it makes
          nested loops.</em
        >
      </li>
      <li>
        <em
          >Double for loops are polynomial time complexity or more specifically
          in this case Quadratic (Big O) of: O(n²)</em
        >
      </li>
    </ul>
    <h4 id="selection-sort">Selection Sort</h4>
    <p><code>Time Complexity</code>: Quadratic O(n^2)</p>
    <ul>
      <li>
        Our outer loop will contribute O(n) while the inner loop will contribute
        O(n / 2) on average. Because our loops are nested we will get O(n²);
      </li>
    </ul>
    <p><code>Space Complexity</code>: O(1)</p>
    <ul>
      <li>
        Selection Sort will always use the same amount of memory regardless of
        n.
      </li>
    </ul>
    <p>
      <img src="https://cdn-images-1.medium.com/max/800/0*AByxtBjFrPVVYmyu" />
    </p>
    <p>
      {% embed
      url=“https://gist.github.com/eengineergz/4abc0fe0bf01599b0c4104b0ba633402”
      %}
    </p>
    <ul>
      <li>
        Selection sort organizes the smallest elements to the start of the
        array.
      </li>
    </ul>
    <p>
      <img src="https://cdn-images-1.medium.com/max/800/0*GeYNxlRcbt2cf0rY" />
    </p>
    <blockquote>
      <p>Summary of how Selection Sort should work:</p>
    </blockquote>
    <ol type="1">
      <li><em>Set MIN to location 0</em></li>
      <li><em>Search the minimum element in the list.</em></li>
      <li><em>Swap with value at location Min</em></li>
      <li><em>Increment Min to point to next element.</em></li>
      <li><em>Repeat until list is sorted.</em></li>
    </ol>
    <p>
      {% embed
      url=“https://gist.github.com/eengineergz/61f130c8e0097572ed908fe2629bdee0”
      %}
    </p>
    <h4 id="insertion-sort">Insertion Sort</h4>
    <p><code>Time Complexity</code>: Quadratic O(n^2)</p>
    <ul>
      <li>
        Our outer loop will contribute O(n) while the inner loop will contribute
        O(n / 2) on average. Because our loops are nested we will get O(n²);
      </li>
    </ul>
    <p><code>Space Complexity</code>: O(n)</p>
    <ul>
      <li>
        Because we are creating a subArray for each element in the original
        input, our Space Comlexity becomes linear.
      </li>
    </ul>
    <p>
      <img src="https://cdn-images-1.medium.com/max/800/0*gbNU6wrszGPrfAZG" />
    </p>
    <p>
      {% embed
      url=“https://gist.github.com/eengineergz/a9f4b8596c7546ac92746db659186d8c”
      %}
    </p>
    <h4 id="merge-sort">Merge Sort</h4>
    <p><code>Time Complexity</code>: Log Linear O(nlog(n))</p>
    <ul>
      <li>
        Since our array gets split in half every single time we contribute
        O(log(n)). The while loop contained in our helper merge function
        contributes O(n) therefore our time complexity is O(nlog(n));
        <code>Space Complexity</code>: O(n)
      </li>
      <li>We are linear O(n) time because we are creating subArrays.</li>
    </ul>
    <p>
      <img src="https://cdn-images-1.medium.com/max/800/0*GeU8YwwCoK8GiSTD" />
    </p>
    <p><img src="../../../.gitbook/assets/image%20%2840%29.png" /></p>
    <h4 id="section"></h4>
    <h4 id="example-of-merge-sort">Example of Merge Sort</h4>
    <p>
      {% embed
      url=“https://gist.github.com/eengineergz/18fbb7edc9f5c4820ccfcecacf3c5e48”
      %}
    </p>
    <p>
      {% embed
      url=“https://gist.github.com/eengineergz/cbb533137a7f957d3bc4077395c1ff64”
      %}
    </p>
    <p>
      <img src="https://cdn-images-1.medium.com/max/800/0*HMCR--9niDt5zY6M" />
    </p>
    <ul>
      <li><strong>Merge sort is O(nlog(n)) time.</strong></li>
      <li>
        <em>We need a function for merging and a function for sorting.</em>
      </li>
    </ul>
    <blockquote>
      <p>Steps:</p>
    </blockquote>
    <ol type="1">
      <li>
        <em
          >If there is only one element in the list, it is already sorted;
          return the array.</em
        >
      </li>
      <li>
        <em
          >Otherwise, divide the list recursively into two halves until it can
          no longer be divided.</em
        >
      </li>
      <li>
        <em>Merge the smallest lists into new list in a sorted order.</em>
      </li>
    </ol>
    <h4 id="quick-sort">Quick Sort</h4>
    <p><code>Time Complexity</code>: Quadratic O(n^2)</p>
    <ul>
      <li>
        Even though the average time complexity O(nLog(n)), the worst case
        scenario is always quadratic.
      </li>
    </ul>
    <p><code>Space Complexity</code>: O(n)</p>
    <ul>
      <li>
        Our space complexity is linear O(n) because of the partition arrays we
        create.
      </li>
      <li>QS is another Divide and Conquer strategy.</li>
      <li>Some key ideas to keep in mind:</li>
      <li>
        It is easy to sort elements of an array relative to a particular target
        value.
      </li>
      <li>An array of 0 or 1 elements is already trivially sorted.</li>
    </ul>
    <p>
      <img src="https://cdn-images-1.medium.com/max/800/0*WLl_HpdBGXYx284T" />
    </p>
    <p><img src="../../../.gitbook/assets/image%20%2841%29.png" /></p>
    <p>
      {% embed
      url=“https://gist.github.com/eengineergz/24bcbc5248a8c4e1671945e9512da57e”
      %}
    </p>
    <h4 id="binary-search">Binary Search</h4>
    <p><code>Time Complexity</code>: Log Time O(log(n))</p>
    <p><code>Space Complexity</code>: O(1)</p>
    <p>
      <img src="https://cdn-images-1.medium.com/max/800/0*-naVYGTXzE2Yoali" />
    </p>
    <blockquote>
      <p><em>Recursive Solution</em></p>
    </blockquote>
    <p>
      {% embed
      url=“https://gist.github.com/eengineergz/c82c00a4bcba4b69b7d326d6cad3ac8c”
      %}
    </p>
    <blockquote>
      <p><em>Min Max Solution</em></p>
    </blockquote>
    <p>
      {% embed
      url=“https://gist.github.com/eengineergz/eb8d1e1684db15cc2c8af28e13f38751”
      %}
    </p>
    <p>
      {% embed
      url=“https://gist.github.com/eengineergz/bc3f576b9795ccef12a108e36f9f820a”
      %}
    </p>
    <ul>
      <li><em>Must be conducted on a sorted array.</em></li>
      <li>
        <em
          >Binary search is logarithmic time, not exponential b/c n is cut down
          by two, not growing.</em
        >
      </li>
      <li><em>Binary Search is part of Divide and Conquer.</em></li>
    </ul>
    <h4 id="insertion-sort-1">Insertion Sort</h4>
    <ul>
      <li>
        <strong
          >Works by building a larger and larger sorted region at the left-most
          end of the array.</strong
        >
      </li>
    </ul>
    <blockquote>
      <p>Steps:</p>
    </blockquote>
    <ol type="1">
      <li>
        <em>If it is the first element, and it is already sorted; return 1.</em>
      </li>
      <li><em>Pick next element.</em></li>
      <li><em>Compare with all elements in the sorted sub list</em></li>
      <li>
        <em
          >Shift all the elements in the sorted sub list that is greater than
          the value to be sorted.</em
        >
      </li>
      <li><em>Insert the value</em></li>
      <li><em>Repeat until list is sorted.</em></li>
    </ol>
    <p>
      {% embed
      url=“https://gist.github.com/eengineergz/ffead1de0836c4bcc6445780a604f617”
      %}
    </p>
  </body>
</html>
