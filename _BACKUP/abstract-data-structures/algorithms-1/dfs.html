<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>dfs</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
    <style type="text/css">
      a.sourceLine {
        display: inline-block;
        line-height: 1.25;
      }
      a.sourceLine {
        pointer-events: none;
        color: inherit;
        text-decoration: inherit;
      }
      a.sourceLine:empty {
        height: 1.2em;
      }
      .sourceCode {
        overflow: visible;
      }
      code.sourceCode {
        white-space: pre;
        position: relative;
      }
      div.sourceCode {
        margin: 1em 0;
      }
      pre.sourceCode {
        margin: 0;
      }
      @media screen {
        div.sourceCode {
          overflow: auto;
        }
      }
      @media print {
        code.sourceCode {
          white-space: pre-wrap;
        }
        a.sourceLine {
          text-indent: -1em;
          padding-left: 1em;
        }
      }
      pre.numberSource a.sourceLine {
        position: relative;
        left: -4em;
      }
      pre.numberSource a.sourceLine::before {
        content: attr(title);
        position: relative;
        left: -1em;
        text-align: right;
        vertical-align: baseline;
        border: none;
        pointer-events: all;
        display: inline-block;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        padding: 0 4px;
        width: 4em;
        color: #aaaaaa;
      }
      pre.numberSource {
        margin-left: 3em;
        border-left: 1px solid #aaaaaa;
        padding-left: 4px;
      }
      div.sourceCode {
      }
      @media screen {
        a.sourceLine::before {
          text-decoration: underline;
        }
      }
      code span.al {
        color: #ff0000;
        font-weight: bold;
      } /* Alert */
      code span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Annotation */
      code span.at {
        color: #7d9029;
      } /* Attribute */
      code span.bn {
        color: #40a070;
      } /* BaseN */
      code span.bu {
      } /* BuiltIn */
      code span.cf {
        color: #007020;
        font-weight: bold;
      } /* ControlFlow */
      code span.ch {
        color: #4070a0;
      } /* Char */
      code span.cn {
        color: #880000;
      } /* Constant */
      code span.co {
        color: #60a0b0;
        font-style: italic;
      } /* Comment */
      code span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* CommentVar */
      code span.do {
        color: #ba2121;
        font-style: italic;
      } /* Documentation */
      code span.dt {
        color: #902000;
      } /* DataType */
      code span.dv {
        color: #40a070;
      } /* DecVal */
      code span.er {
        color: #ff0000;
        font-weight: bold;
      } /* Error */
      code span.ex {
      } /* Extension */
      code span.fl {
        color: #40a070;
      } /* Float */
      code span.fu {
        color: #06287e;
      } /* Function */
      code span.im {
      } /* Import */
      code span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Information */
      code span.kw {
        color: #007020;
        font-weight: bold;
      } /* Keyword */
      code span.op {
        color: #666666;
      } /* Operator */
      code span.ot {
        color: #007020;
      } /* Other */
      code span.pp {
        color: #bc7a00;
      } /* Preprocessor */
      code span.sc {
        color: #4070a0;
      } /* SpecialChar */
      code span.ss {
        color: #bb6688;
      } /* SpecialString */
      code span.st {
        color: #4070a0;
      } /* String */
      code span.va {
        color: #19177c;
      } /* Variable */
      code span.vs {
        color: #4070a0;
      } /* VerbatimString */
      code span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Warning */
    </style>
  </head>
  <body>
    <h1 id="dfs">DFS</h1>
    <p>{% tabs %} {% tab title=“First Tab” %}</p>
    <div class="sourceCode" id="cb1">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="im">from</span> .all_factors <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="im">from</span> .count_islands <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="im">from</span> .pacific_atlantic <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="im">from</span> .sudoku_solver <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="im">from</span> .walls_and_gates <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="im">from</span> .maze_search <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="co">Numbers can be regarded as product of its factors. For example,</span></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="co">8 = 2 x 2 x 2;</span></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="co">  = 2 x 4.</span></a>
<a class="sourceLine" id="cb1-12" title="12"></a>
<a class="sourceLine" id="cb1-13" title="13"></a>
<a class="sourceLine" id="cb1-14" title="14"><span class="co">Write a function that takes an integer n and return all possible combinations</span></a>
<a class="sourceLine" id="cb1-15" title="15"><span class="co">of its factors.Numbers can be regarded as product of its factors. For example,</span></a>
<a class="sourceLine" id="cb1-16" title="16"><span class="co">8 = 2 x 2 x 2;</span></a>
<a class="sourceLine" id="cb1-17" title="17"><span class="co">  = 2 x 4.</span></a>
<a class="sourceLine" id="cb1-18" title="18"></a>
<a class="sourceLine" id="cb1-19" title="19"><span class="co">Examples:</span></a>
<a class="sourceLine" id="cb1-20" title="20"><span class="co">input: 1</span></a>
<a class="sourceLine" id="cb1-21" title="21"><span class="co">output:</span></a>
<a class="sourceLine" id="cb1-22" title="22"><span class="co">[]</span></a>
<a class="sourceLine" id="cb1-23" title="23"></a>
<a class="sourceLine" id="cb1-24" title="24"></a>
<a class="sourceLine" id="cb1-25" title="25"><span class="co">input: 37</span></a>
<a class="sourceLine" id="cb1-26" title="26"><span class="co">output:</span></a>
<a class="sourceLine" id="cb1-27" title="27"><span class="co">[]</span></a>
<a class="sourceLine" id="cb1-28" title="28"></a>
<a class="sourceLine" id="cb1-29" title="29"><span class="co">input: 32</span></a>
<a class="sourceLine" id="cb1-30" title="30"><span class="co">output:</span></a>
<a class="sourceLine" id="cb1-31" title="31"><span class="co">[</span></a>
<a class="sourceLine" id="cb1-32" title="32"><span class="co">  [2, 16],</span></a>
<a class="sourceLine" id="cb1-33" title="33"><span class="co">  [2, 2, 8],</span></a>
<a class="sourceLine" id="cb1-34" title="34"><span class="co">  [2, 2, 2, 4],</span></a>
<a class="sourceLine" id="cb1-35" title="35"><span class="co">  [2, 2, 2, 2, 2],</span></a>
<a class="sourceLine" id="cb1-36" title="36"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-37" title="37"></a>
<a class="sourceLine" id="cb1-38" title="38"></a>
<a class="sourceLine" id="cb1-39" title="39"><span class="kw">def</span> get_factors(n):</a>
<a class="sourceLine" id="cb1-40" title="40">    <span class="co">&quot;&quot;&quot;[summary]</span></a>
<a class="sourceLine" id="cb1-41" title="41"></a>
<a class="sourceLine" id="cb1-42" title="42"><span class="co">    Arguments:</span></a>
<a class="sourceLine" id="cb1-43" title="43"><span class="co">        n {[int]} -- [to analysed number]</span></a>
<a class="sourceLine" id="cb1-44" title="44"></a>
<a class="sourceLine" id="cb1-45" title="45"><span class="co">    Returns:</span></a>
<a class="sourceLine" id="cb1-46" title="46"><span class="co">        [list of lists] -- [all factors of the number n]</span></a>
<a class="sourceLine" id="cb1-47" title="47"><span class="co">    &quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-48" title="48"></a>
<a class="sourceLine" id="cb1-49" title="49">    <span class="kw">def</span> factor(n, i, combi, res):</a>
<a class="sourceLine" id="cb1-50" title="50">        <span class="co">&quot;&quot;&quot;[summary]</span></a>
<a class="sourceLine" id="cb1-51" title="51"><span class="co">        helper function</span></a>
<a class="sourceLine" id="cb1-52" title="52"></a>
<a class="sourceLine" id="cb1-53" title="53"><span class="co">        Arguments:</span></a>
<a class="sourceLine" id="cb1-54" title="54"><span class="co">            n {[int]} -- [number]</span></a>
<a class="sourceLine" id="cb1-55" title="55"><span class="co">            i {[int]} -- [to tested divisor]</span></a>
<a class="sourceLine" id="cb1-56" title="56"><span class="co">            combi {[list]} -- [catch divisors]</span></a>
<a class="sourceLine" id="cb1-57" title="57"><span class="co">            res {[list]} -- [all factors of the number n]</span></a>
<a class="sourceLine" id="cb1-58" title="58"></a>
<a class="sourceLine" id="cb1-59" title="59"><span class="co">        Returns:</span></a>
<a class="sourceLine" id="cb1-60" title="60"><span class="co">            [list] -- [res]</span></a>
<a class="sourceLine" id="cb1-61" title="61"><span class="co">        &quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-62" title="62"></a>
<a class="sourceLine" id="cb1-63" title="63">        <span class="cf">while</span> i <span class="op">*</span> i <span class="op">&lt;=</span> n:</a>
<a class="sourceLine" id="cb1-64" title="64">            <span class="cf">if</span> n <span class="op">%</span> i <span class="op">==</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb1-65" title="65">                res <span class="op">+=</span> (combi <span class="op">+</span> [i, <span class="bu">int</span>(n <span class="op">/</span> i)],)</a>
<a class="sourceLine" id="cb1-66" title="66">                factor(n <span class="op">/</span> i, i, combi <span class="op">+</span> [i], res)</a>
<a class="sourceLine" id="cb1-67" title="67">            i <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-68" title="68">        <span class="cf">return</span> res</a>
<a class="sourceLine" id="cb1-69" title="69"></a>
<a class="sourceLine" id="cb1-70" title="70">    <span class="cf">return</span> factor(n, <span class="dv">2</span>, [], [])</a>
<a class="sourceLine" id="cb1-71" title="71"></a>
<a class="sourceLine" id="cb1-72" title="72"></a>
<a class="sourceLine" id="cb1-73" title="73"><span class="kw">def</span> get_factors_iterative1(n):</a>
<a class="sourceLine" id="cb1-74" title="74">    <span class="co">&quot;&quot;&quot;[summary]</span></a>
<a class="sourceLine" id="cb1-75" title="75"><span class="co">    Computes all factors of n.</span></a>
<a class="sourceLine" id="cb1-76" title="76"><span class="co">    Translated the function get_factors(...) in</span></a>
<a class="sourceLine" id="cb1-77" title="77"><span class="co">    a call-stack modell.</span></a>
<a class="sourceLine" id="cb1-78" title="78"></a>
<a class="sourceLine" id="cb1-79" title="79"><span class="co">    Arguments:</span></a>
<a class="sourceLine" id="cb1-80" title="80"><span class="co">        n {[int]} -- [to analysed number]</span></a>
<a class="sourceLine" id="cb1-81" title="81"></a>
<a class="sourceLine" id="cb1-82" title="82"><span class="co">    Returns:</span></a>
<a class="sourceLine" id="cb1-83" title="83"><span class="co">        [list of lists] -- [all factors]</span></a>
<a class="sourceLine" id="cb1-84" title="84"><span class="co">    &quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-85" title="85"></a>
<a class="sourceLine" id="cb1-86" title="86">    todo, res <span class="op">=</span> [(n, <span class="dv">2</span>, [])], []</a>
<a class="sourceLine" id="cb1-87" title="87">    <span class="cf">while</span> todo:</a>
<a class="sourceLine" id="cb1-88" title="88">        n, i, combi <span class="op">=</span> todo.pop()</a>
<a class="sourceLine" id="cb1-89" title="89">        <span class="cf">while</span> i <span class="op">*</span> i <span class="op">&lt;=</span> n:</a>
<a class="sourceLine" id="cb1-90" title="90">            <span class="cf">if</span> n <span class="op">%</span> i <span class="op">==</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb1-91" title="91">                res <span class="op">+=</span> (combi <span class="op">+</span> [i, n <span class="op">//</span> i],)</a>
<a class="sourceLine" id="cb1-92" title="92">                todo.append((n <span class="op">//</span> i, i, combi <span class="op">+</span> [i])),</a>
<a class="sourceLine" id="cb1-93" title="93">            i <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-94" title="94">    <span class="cf">return</span> res</a>
<a class="sourceLine" id="cb1-95" title="95"></a>
<a class="sourceLine" id="cb1-96" title="96"></a>
<a class="sourceLine" id="cb1-97" title="97"><span class="kw">def</span> get_factors_iterative2(n):</a>
<a class="sourceLine" id="cb1-98" title="98">    <span class="co">&quot;&quot;&quot;[summary]</span></a>
<a class="sourceLine" id="cb1-99" title="99"><span class="co">    analog as above</span></a>
<a class="sourceLine" id="cb1-100" title="100"></a>
<a class="sourceLine" id="cb1-101" title="101"><span class="co">    Arguments:</span></a>
<a class="sourceLine" id="cb1-102" title="102"><span class="co">        n {[int]} -- [description]</span></a>
<a class="sourceLine" id="cb1-103" title="103"></a>
<a class="sourceLine" id="cb1-104" title="104"><span class="co">    Returns:</span></a>
<a class="sourceLine" id="cb1-105" title="105"><span class="co">        [list of lists] -- [all factors of n]</span></a>
<a class="sourceLine" id="cb1-106" title="106"><span class="co">    &quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-107" title="107"></a>
<a class="sourceLine" id="cb1-108" title="108">    ans, stack, x <span class="op">=</span> [], [], <span class="dv">2</span></a>
<a class="sourceLine" id="cb1-109" title="109">    <span class="cf">while</span> <span class="va">True</span>:</a>
<a class="sourceLine" id="cb1-110" title="110">        <span class="cf">if</span> x <span class="op">&gt;</span> n <span class="op">//</span> x:</a>
<a class="sourceLine" id="cb1-111" title="111">            <span class="cf">if</span> <span class="kw">not</span> stack:</a>
<a class="sourceLine" id="cb1-112" title="112">                <span class="cf">return</span> ans</a>
<a class="sourceLine" id="cb1-113" title="113">            ans.append(stack <span class="op">+</span> [n])</a>
<a class="sourceLine" id="cb1-114" title="114">            x <span class="op">=</span> stack.pop()</a>
<a class="sourceLine" id="cb1-115" title="115">            n <span class="op">*=</span> x</a>
<a class="sourceLine" id="cb1-116" title="116">            x <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-117" title="117">        <span class="cf">elif</span> n <span class="op">%</span> x <span class="op">==</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb1-118" title="118">            stack.append(x)</a>
<a class="sourceLine" id="cb1-119" title="119">            n <span class="op">//=</span> x</a>
<a class="sourceLine" id="cb1-120" title="120">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb1-121" title="121">            x <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-122" title="122"></a>
<a class="sourceLine" id="cb1-123" title="123"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-124" title="124"><span class="co">Given a 2d grid map of &#39;1&#39;s (land) and &#39;0&#39;s (water),</span></a>
<a class="sourceLine" id="cb1-125" title="125"><span class="co">count the number of islands.</span></a>
<a class="sourceLine" id="cb1-126" title="126"><span class="co">An island is surrounded by water and is formed by</span></a>
<a class="sourceLine" id="cb1-127" title="127"><span class="co">connecting adjacent lands horizontally or vertically.</span></a>
<a class="sourceLine" id="cb1-128" title="128"><span class="co">You may assume all four edges of the grid are all surrounded by water.</span></a>
<a class="sourceLine" id="cb1-129" title="129"></a>
<a class="sourceLine" id="cb1-130" title="130"><span class="co">Example 1:</span></a>
<a class="sourceLine" id="cb1-131" title="131"></a>
<a class="sourceLine" id="cb1-132" title="132"><span class="co">11110</span></a>
<a class="sourceLine" id="cb1-133" title="133"><span class="co">11010</span></a>
<a class="sourceLine" id="cb1-134" title="134"><span class="co">11000</span></a>
<a class="sourceLine" id="cb1-135" title="135"><span class="co">00000</span></a>
<a class="sourceLine" id="cb1-136" title="136"><span class="co">Answer: 1</span></a>
<a class="sourceLine" id="cb1-137" title="137"></a>
<a class="sourceLine" id="cb1-138" title="138"><span class="co">Example 2:</span></a>
<a class="sourceLine" id="cb1-139" title="139"></a>
<a class="sourceLine" id="cb1-140" title="140"><span class="co">11000</span></a>
<a class="sourceLine" id="cb1-141" title="141"><span class="co">11000</span></a>
<a class="sourceLine" id="cb1-142" title="142"><span class="co">00100</span></a>
<a class="sourceLine" id="cb1-143" title="143"><span class="co">00011</span></a>
<a class="sourceLine" id="cb1-144" title="144"><span class="co">Answer: 3</span></a>
<a class="sourceLine" id="cb1-145" title="145"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-146" title="146"></a>
<a class="sourceLine" id="cb1-147" title="147"></a>
<a class="sourceLine" id="cb1-148" title="148"><span class="kw">def</span> num_islands(grid):</a>
<a class="sourceLine" id="cb1-149" title="149">    count <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb1-150" title="150">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(grid)):</a>
<a class="sourceLine" id="cb1-151" title="151">        <span class="cf">for</span> j, col <span class="kw">in</span> <span class="bu">enumerate</span>(grid[i]):</a>
<a class="sourceLine" id="cb1-152" title="152">            <span class="cf">if</span> col <span class="op">==</span> <span class="dv">1</span>:</a>
<a class="sourceLine" id="cb1-153" title="153">                dfs(grid, i, j)</a>
<a class="sourceLine" id="cb1-154" title="154">                count <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-155" title="155">    <span class="cf">return</span> count</a>
<a class="sourceLine" id="cb1-156" title="156"></a>
<a class="sourceLine" id="cb1-157" title="157"></a>
<a class="sourceLine" id="cb1-158" title="158"><span class="kw">def</span> dfs(grid, i, j):</a>
<a class="sourceLine" id="cb1-159" title="159">    <span class="cf">if</span> (i <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">or</span> i <span class="op">&gt;=</span> <span class="bu">len</span>(grid)) <span class="kw">or</span> (j <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">or</span> j <span class="op">&gt;=</span> <span class="bu">len</span>(grid[<span class="dv">0</span>])):</a>
<a class="sourceLine" id="cb1-160" title="160">        <span class="cf">return</span></a>
<a class="sourceLine" id="cb1-161" title="161">    <span class="cf">if</span> grid[i][j] <span class="op">!=</span> <span class="dv">1</span>:</a>
<a class="sourceLine" id="cb1-162" title="162">        <span class="cf">return</span></a>
<a class="sourceLine" id="cb1-163" title="163">    grid[i][j] <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb1-164" title="164">    dfs(grid, i <span class="op">+</span> <span class="dv">1</span>, j)</a>
<a class="sourceLine" id="cb1-165" title="165">    dfs(grid, i <span class="op">-</span> <span class="dv">1</span>, j)</a>
<a class="sourceLine" id="cb1-166" title="166">    dfs(grid, i, j <span class="op">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-167" title="167">    dfs(grid, i, j <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-168" title="168"></a>
<a class="sourceLine" id="cb1-169" title="169"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-170" title="170"><span class="co">Find shortest path from top left column to the right lowest column using DFS.</span></a>
<a class="sourceLine" id="cb1-171" title="171"><span class="co">only step on the columns whose value is 1</span></a>
<a class="sourceLine" id="cb1-172" title="172"><span class="co">if there is no path, it returns -1</span></a>
<a class="sourceLine" id="cb1-173" title="173"><span class="co">(The first column(top left column) is not included in the answer.)</span></a>
<a class="sourceLine" id="cb1-174" title="174"></a>
<a class="sourceLine" id="cb1-175" title="175"><span class="co">Ex 1)</span></a>
<a class="sourceLine" id="cb1-176" title="176"><span class="co">If maze is</span></a>
<a class="sourceLine" id="cb1-177" title="177"><span class="co">[[1,0,1,1,1,1],</span></a>
<a class="sourceLine" id="cb1-178" title="178"><span class="co"> [1,0,1,0,1,0],</span></a>
<a class="sourceLine" id="cb1-179" title="179"><span class="co"> [1,0,1,0,1,1],</span></a>
<a class="sourceLine" id="cb1-180" title="180"><span class="co"> [1,1,1,0,1,1]],</span></a>
<a class="sourceLine" id="cb1-181" title="181"><span class="co">the answer is: 14</span></a>
<a class="sourceLine" id="cb1-182" title="182"></a>
<a class="sourceLine" id="cb1-183" title="183"><span class="co">Ex 2)</span></a>
<a class="sourceLine" id="cb1-184" title="184"><span class="co">If maze is</span></a>
<a class="sourceLine" id="cb1-185" title="185"><span class="co">[[1,0,0],</span></a>
<a class="sourceLine" id="cb1-186" title="186"><span class="co"> [0,1,1],</span></a>
<a class="sourceLine" id="cb1-187" title="187"><span class="co"> [0,1,1]],</span></a>
<a class="sourceLine" id="cb1-188" title="188"><span class="co">the answer is: -1</span></a>
<a class="sourceLine" id="cb1-189" title="189"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-190" title="190"></a>
<a class="sourceLine" id="cb1-191" title="191"></a>
<a class="sourceLine" id="cb1-192" title="192"><span class="kw">def</span> find_path(maze):</a>
<a class="sourceLine" id="cb1-193" title="193">    cnt <span class="op">=</span> dfs(maze, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">-1</span>)</a>
<a class="sourceLine" id="cb1-194" title="194">    <span class="cf">return</span> cnt</a>
<a class="sourceLine" id="cb1-195" title="195"></a>
<a class="sourceLine" id="cb1-196" title="196"></a>
<a class="sourceLine" id="cb1-197" title="197"><span class="kw">def</span> dfs(maze, i, j, depth, cnt):</a>
<a class="sourceLine" id="cb1-198" title="198">    directions <span class="op">=</span> [(<span class="dv">0</span>, <span class="dv">-1</span>), (<span class="dv">0</span>, <span class="dv">1</span>), (<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>), (<span class="dv">1</span>, <span class="dv">0</span>)]</a>
<a class="sourceLine" id="cb1-199" title="199"></a>
<a class="sourceLine" id="cb1-200" title="200">    row <span class="op">=</span> <span class="bu">len</span>(maze)</a>
<a class="sourceLine" id="cb1-201" title="201">    col <span class="op">=</span> <span class="bu">len</span>(maze[<span class="dv">0</span>])</a>
<a class="sourceLine" id="cb1-202" title="202"></a>
<a class="sourceLine" id="cb1-203" title="203">    <span class="cf">if</span> i <span class="op">==</span> row <span class="op">-</span> <span class="dv">1</span> <span class="kw">and</span> j <span class="op">==</span> col <span class="op">-</span> <span class="dv">1</span>:</a>
<a class="sourceLine" id="cb1-204" title="204">        <span class="cf">if</span> cnt <span class="op">==</span> <span class="dv">-1</span>:</a>
<a class="sourceLine" id="cb1-205" title="205">            cnt <span class="op">=</span> depth</a>
<a class="sourceLine" id="cb1-206" title="206">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb1-207" title="207">            <span class="cf">if</span> cnt <span class="op">&gt;</span> depth:</a>
<a class="sourceLine" id="cb1-208" title="208">                cnt <span class="op">=</span> depth</a>
<a class="sourceLine" id="cb1-209" title="209">        <span class="cf">return</span> cnt</a>
<a class="sourceLine" id="cb1-210" title="210"></a>
<a class="sourceLine" id="cb1-211" title="211">    maze[i][j] <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb1-212" title="212"></a>
<a class="sourceLine" id="cb1-213" title="213">    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(directions)):</a>
<a class="sourceLine" id="cb1-214" title="214">        nx_i <span class="op">=</span> i <span class="op">+</span> directions[k][<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb1-215" title="215">        nx_j <span class="op">=</span> j <span class="op">+</span> directions[k][<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb1-216" title="216"></a>
<a class="sourceLine" id="cb1-217" title="217">        <span class="cf">if</span> nx_i <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> nx_i <span class="op">&lt;</span> row <span class="kw">and</span> nx_j <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> nx_j <span class="op">&lt;</span> col:</a>
<a class="sourceLine" id="cb1-218" title="218">            <span class="cf">if</span> maze[nx_i][nx_j] <span class="op">==</span> <span class="dv">1</span>:</a>
<a class="sourceLine" id="cb1-219" title="219">                cnt <span class="op">=</span> dfs(maze, nx_i, nx_j, depth <span class="op">+</span> <span class="dv">1</span>, cnt)</a>
<a class="sourceLine" id="cb1-220" title="220"></a>
<a class="sourceLine" id="cb1-221" title="221">    maze[i][j] <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-222" title="222"></a>
<a class="sourceLine" id="cb1-223" title="223">    <span class="cf">return</span> cnt</a>
<a class="sourceLine" id="cb1-224" title="224"></a>
<a class="sourceLine" id="cb1-225" title="225"><span class="co"># Given an m x n matrix of non-negative integers representing</span></a>
<a class="sourceLine" id="cb1-226" title="226"><span class="co"># the height of each unit cell in a continent,</span></a>
<a class="sourceLine" id="cb1-227" title="227"><span class="co"># the &quot;Pacific ocean&quot; touches the left and top edges of the matrix</span></a>
<a class="sourceLine" id="cb1-228" title="228"><span class="co"># and the &quot;Atlantic ocean&quot; touches the right and bottom edges.</span></a>
<a class="sourceLine" id="cb1-229" title="229"></a>
<a class="sourceLine" id="cb1-230" title="230"><span class="co"># Water can only flow in four directions (up, down, left, or right)</span></a>
<a class="sourceLine" id="cb1-231" title="231"><span class="co"># from a cell to another one with height equal or lower.</span></a>
<a class="sourceLine" id="cb1-232" title="232"></a>
<a class="sourceLine" id="cb1-233" title="233"><span class="co"># Find the list of grid coordinates where water can flow to both the</span></a>
<a class="sourceLine" id="cb1-234" title="234"><span class="co"># Pacific and Atlantic ocean.</span></a>
<a class="sourceLine" id="cb1-235" title="235"></a>
<a class="sourceLine" id="cb1-236" title="236"><span class="co"># Note:</span></a>
<a class="sourceLine" id="cb1-237" title="237"><span class="co"># The order of returned grid coordinates does not matter.</span></a>
<a class="sourceLine" id="cb1-238" title="238"><span class="co"># Both m and n are less than 150.</span></a>
<a class="sourceLine" id="cb1-239" title="239"><span class="co"># Example:</span></a>
<a class="sourceLine" id="cb1-240" title="240"></a>
<a class="sourceLine" id="cb1-241" title="241"><span class="co"># Given the following 5x5 matrix:</span></a>
<a class="sourceLine" id="cb1-242" title="242"></a>
<a class="sourceLine" id="cb1-243" title="243"><span class="co"># Pacific ~   ~   ~   ~   ~</span></a>
<a class="sourceLine" id="cb1-244" title="244"><span class="co"># ~  1   2   2   3  (5) *</span></a>
<a class="sourceLine" id="cb1-245" title="245"><span class="co"># ~  3   2   3  (4) (4) *</span></a>
<a class="sourceLine" id="cb1-246" title="246"><span class="co"># ~  2   4  (5)  3   1  *</span></a>
<a class="sourceLine" id="cb1-247" title="247"><span class="co"># ~ (6) (7)  1   4   5  *</span></a>
<a class="sourceLine" id="cb1-248" title="248"><span class="co"># ~ (5)  1   1   2   4  *</span></a>
<a class="sourceLine" id="cb1-249" title="249"><span class="co"># *   *   *   *   * Atlantic</span></a>
<a class="sourceLine" id="cb1-250" title="250"></a>
<a class="sourceLine" id="cb1-251" title="251"><span class="co"># Return:</span></a>
<a class="sourceLine" id="cb1-252" title="252"></a>
<a class="sourceLine" id="cb1-253" title="253"><span class="co"># [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]]</span></a>
<a class="sourceLine" id="cb1-254" title="254"><span class="co"># (positions with parentheses in above matrix).</span></a>
<a class="sourceLine" id="cb1-255" title="255"></a>
<a class="sourceLine" id="cb1-256" title="256"></a>
<a class="sourceLine" id="cb1-257" title="257"><span class="kw">def</span> pacific_atlantic(matrix):</a>
<a class="sourceLine" id="cb1-258" title="258">    <span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-259" title="259"><span class="co">    :type matrix: List[List[int]]</span></a>
<a class="sourceLine" id="cb1-260" title="260"><span class="co">    :rtype: List[List[int]]</span></a>
<a class="sourceLine" id="cb1-261" title="261"><span class="co">    &quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-262" title="262">    n <span class="op">=</span> <span class="bu">len</span>(matrix)</a>
<a class="sourceLine" id="cb1-263" title="263">    <span class="cf">if</span> <span class="kw">not</span> n:</a>
<a class="sourceLine" id="cb1-264" title="264">        <span class="cf">return</span> []</a>
<a class="sourceLine" id="cb1-265" title="265">    m <span class="op">=</span> <span class="bu">len</span>(matrix[<span class="dv">0</span>])</a>
<a class="sourceLine" id="cb1-266" title="266">    <span class="cf">if</span> <span class="kw">not</span> m:</a>
<a class="sourceLine" id="cb1-267" title="267">        <span class="cf">return</span> []</a>
<a class="sourceLine" id="cb1-268" title="268">    res <span class="op">=</span> []</a>
<a class="sourceLine" id="cb1-269" title="269">    atlantic <span class="op">=</span> [[<span class="va">False</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m)]</a>
<a class="sourceLine" id="cb1-270" title="270">    pacific <span class="op">=</span> [[<span class="va">False</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m)]</a>
<a class="sourceLine" id="cb1-271" title="271">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</a>
<a class="sourceLine" id="cb1-272" title="272">        dfs(pacific, matrix, <span class="bu">float</span>(<span class="st">&quot;-inf&quot;</span>), i, <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb1-273" title="273">        dfs(atlantic, matrix, <span class="bu">float</span>(<span class="st">&quot;-inf&quot;</span>), i, m <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-274" title="274">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m):</a>
<a class="sourceLine" id="cb1-275" title="275">        dfs(pacific, matrix, <span class="bu">float</span>(<span class="st">&quot;-inf&quot;</span>), <span class="dv">0</span>, i)</a>
<a class="sourceLine" id="cb1-276" title="276">        dfs(atlantic, matrix, <span class="bu">float</span>(<span class="st">&quot;-inf&quot;</span>), n <span class="op">-</span> <span class="dv">1</span>, i)</a>
<a class="sourceLine" id="cb1-277" title="277">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</a>
<a class="sourceLine" id="cb1-278" title="278">        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(m):</a>
<a class="sourceLine" id="cb1-279" title="279">            <span class="cf">if</span> pacific[i][j] <span class="kw">and</span> atlantic[i][j]:</a>
<a class="sourceLine" id="cb1-280" title="280">                res.append([i, j])</a>
<a class="sourceLine" id="cb1-281" title="281">    <span class="cf">return</span> res</a>
<a class="sourceLine" id="cb1-282" title="282"></a>
<a class="sourceLine" id="cb1-283" title="283"></a>
<a class="sourceLine" id="cb1-284" title="284"><span class="kw">def</span> dfs(grid, matrix, height, i, j):</a>
<a class="sourceLine" id="cb1-285" title="285">    <span class="cf">if</span> i <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">or</span> i <span class="op">&gt;=</span> <span class="bu">len</span>(matrix) <span class="kw">or</span> j <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">or</span> j <span class="op">&gt;=</span> <span class="bu">len</span>(matrix[<span class="dv">0</span>]):</a>
<a class="sourceLine" id="cb1-286" title="286">        <span class="cf">return</span></a>
<a class="sourceLine" id="cb1-287" title="287">    <span class="cf">if</span> grid[i][j] <span class="kw">or</span> matrix[i][j] <span class="op">&lt;</span> height:</a>
<a class="sourceLine" id="cb1-288" title="288">        <span class="cf">return</span></a>
<a class="sourceLine" id="cb1-289" title="289">    grid[i][j] <span class="op">=</span> <span class="va">True</span></a>
<a class="sourceLine" id="cb1-290" title="290">    dfs(grid, matrix, matrix[i][j], i <span class="op">-</span> <span class="dv">1</span>, j)</a>
<a class="sourceLine" id="cb1-291" title="291">    dfs(grid, matrix, matrix[i][j], i <span class="op">+</span> <span class="dv">1</span>, j)</a>
<a class="sourceLine" id="cb1-292" title="292">    dfs(grid, matrix, matrix[i][j], i, j <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-293" title="293">    dfs(grid, matrix, matrix[i][j], i, j <span class="op">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-294" title="294"></a>
<a class="sourceLine" id="cb1-295" title="295"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-296" title="296"><span class="co">It&#39;s similar to how human solve Sudoku.</span></a>
<a class="sourceLine" id="cb1-297" title="297"></a>
<a class="sourceLine" id="cb1-298" title="298"><span class="co">create a hash table (dictionary) val to store possible values in every location.</span></a>
<a class="sourceLine" id="cb1-299" title="299"><span class="co">Each time, start from the location with fewest possible values, choose one value</span></a>
<a class="sourceLine" id="cb1-300" title="300"><span class="co">from it and then update the board and possible values at other locations.</span></a>
<a class="sourceLine" id="cb1-301" title="301"><span class="co">If this update is valid, keep solving (DFS). If this update is invalid (leaving</span></a>
<a class="sourceLine" id="cb1-302" title="302"><span class="co">zero possible values at some locations) or this value doesn&#39;t lead to the</span></a>
<a class="sourceLine" id="cb1-303" title="303"><span class="co">solution, undo the updates and then choose the next value.</span></a>
<a class="sourceLine" id="cb1-304" title="304"><span class="co">Since we calculated val at the beginning and start filling the board from the</span></a>
<a class="sourceLine" id="cb1-305" title="305"><span class="co">location with fewest possible values, the amount of calculation and thus the</span></a>
<a class="sourceLine" id="cb1-306" title="306"><span class="co">runtime can be significantly reduced:</span></a>
<a class="sourceLine" id="cb1-307" title="307"></a>
<a class="sourceLine" id="cb1-308" title="308"></a>
<a class="sourceLine" id="cb1-309" title="309"><span class="co">The run time is 48-68 ms on LeetCode OJ, which seems to be among the fastest</span></a>
<a class="sourceLine" id="cb1-310" title="310"><span class="co">python solutions here.</span></a>
<a class="sourceLine" id="cb1-311" title="311"></a>
<a class="sourceLine" id="cb1-312" title="312"></a>
<a class="sourceLine" id="cb1-313" title="313"><span class="co">The PossibleVals function may be further simplified/optimized, but it works just</span></a>
<a class="sourceLine" id="cb1-314" title="314"><span class="co">fine for now. (it would look less lengthy if we are allowed to use numpy array</span></a>
<a class="sourceLine" id="cb1-315" title="315"><span class="co">for the board lol).</span></a>
<a class="sourceLine" id="cb1-316" title="316"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-317" title="317"></a>
<a class="sourceLine" id="cb1-318" title="318"></a>
<a class="sourceLine" id="cb1-319" title="319"><span class="kw">class</span> Sudoku:</a>
<a class="sourceLine" id="cb1-320" title="320">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, board, row, col):</a>
<a class="sourceLine" id="cb1-321" title="321">        <span class="va">self</span>.board <span class="op">=</span> board</a>
<a class="sourceLine" id="cb1-322" title="322">        <span class="va">self</span>.row <span class="op">=</span> row</a>
<a class="sourceLine" id="cb1-323" title="323">        <span class="va">self</span>.col <span class="op">=</span> col</a>
<a class="sourceLine" id="cb1-324" title="324">        <span class="va">self</span>.val <span class="op">=</span> <span class="va">self</span>.possible_values()</a>
<a class="sourceLine" id="cb1-325" title="325"></a>
<a class="sourceLine" id="cb1-326" title="326">    <span class="kw">def</span> possible_values(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb1-327" title="327">        a <span class="op">=</span> <span class="st">&quot;123456789&quot;</span></a>
<a class="sourceLine" id="cb1-328" title="328">        d, val <span class="op">=</span> {}, {}</a>
<a class="sourceLine" id="cb1-329" title="329">        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.row):</a>
<a class="sourceLine" id="cb1-330" title="330">            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.col):</a>
<a class="sourceLine" id="cb1-331" title="331">                ele <span class="op">=</span> <span class="va">self</span>.board[i][j]</a>
<a class="sourceLine" id="cb1-332" title="332">                <span class="cf">if</span> ele <span class="op">!=</span> <span class="st">&quot;.&quot;</span>:</a>
<a class="sourceLine" id="cb1-333" title="333">                    d[(<span class="st">&quot;r&quot;</span>, i)] <span class="op">=</span> d.get((<span class="st">&quot;r&quot;</span>, i), []) <span class="op">+</span> [ele]</a>
<a class="sourceLine" id="cb1-334" title="334">                    d[(<span class="st">&quot;c&quot;</span>, j)] <span class="op">=</span> d.get((<span class="st">&quot;c&quot;</span>, j), []) <span class="op">+</span> [ele]</a>
<a class="sourceLine" id="cb1-335" title="335">                    d[(i <span class="op">//</span> <span class="dv">3</span>, j <span class="op">//</span> <span class="dv">3</span>)] <span class="op">=</span> d.get((i <span class="op">//</span> <span class="dv">3</span>, j <span class="op">//</span> <span class="dv">3</span>), []) <span class="op">+</span> [ele]</a>
<a class="sourceLine" id="cb1-336" title="336">                <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb1-337" title="337">                    val[(i, j)] <span class="op">=</span> []</a>
<a class="sourceLine" id="cb1-338" title="338">        <span class="cf">for</span> (i, j) <span class="kw">in</span> val.keys():</a>
<a class="sourceLine" id="cb1-339" title="339">            inval <span class="op">=</span> (</a>
<a class="sourceLine" id="cb1-340" title="340">                d.get((<span class="st">&quot;r&quot;</span>, i), []) <span class="op">+</span> d.get((<span class="st">&quot;c&quot;</span>, j), []) <span class="op">+</span> d.get((i <span class="op">/</span> <span class="dv">3</span>, j <span class="op">/</span> <span class="dv">3</span>), [])</a>
<a class="sourceLine" id="cb1-341" title="341">            )</a>
<a class="sourceLine" id="cb1-342" title="342">            val[(i, j)] <span class="op">=</span> [n <span class="cf">for</span> n <span class="kw">in</span> a <span class="cf">if</span> n <span class="kw">not</span> <span class="kw">in</span> inval]</a>
<a class="sourceLine" id="cb1-343" title="343">        <span class="cf">return</span> val</a>
<a class="sourceLine" id="cb1-344" title="344"></a>
<a class="sourceLine" id="cb1-345" title="345">    <span class="kw">def</span> solve(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb1-346" title="346">        <span class="cf">if</span> <span class="bu">len</span>(<span class="va">self</span>.val) <span class="op">==</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb1-347" title="347">            <span class="cf">return</span> <span class="va">True</span></a>
<a class="sourceLine" id="cb1-348" title="348">        kee <span class="op">=</span> <span class="bu">min</span>(<span class="va">self</span>.val.keys(), key<span class="op">=</span><span class="kw">lambda</span> x: <span class="bu">len</span>(<span class="va">self</span>.val[x]))</a>
<a class="sourceLine" id="cb1-349" title="349">        nums <span class="op">=</span> <span class="va">self</span>.val[kee]</a>
<a class="sourceLine" id="cb1-350" title="350">        <span class="cf">for</span> n <span class="kw">in</span> nums:</a>
<a class="sourceLine" id="cb1-351" title="351">            update <span class="op">=</span> {kee: <span class="va">self</span>.val[kee]}</a>
<a class="sourceLine" id="cb1-352" title="352">            <span class="cf">if</span> <span class="va">self</span>.valid_one(n, kee, update):  <span class="co"># valid choice</span></a>
<a class="sourceLine" id="cb1-353" title="353">                <span class="cf">if</span> <span class="va">self</span>.solve():  <span class="co"># keep solving</span></a>
<a class="sourceLine" id="cb1-354" title="354">                    <span class="cf">return</span> <span class="va">True</span></a>
<a class="sourceLine" id="cb1-355" title="355">            <span class="va">self</span>.undo(kee, update)  <span class="co"># invalid choice or didn&#39;t solve it =&gt; undo</span></a>
<a class="sourceLine" id="cb1-356" title="356">        <span class="cf">return</span> <span class="va">False</span></a>
<a class="sourceLine" id="cb1-357" title="357"></a>
<a class="sourceLine" id="cb1-358" title="358">    <span class="kw">def</span> valid_one(<span class="va">self</span>, n, kee, update):</a>
<a class="sourceLine" id="cb1-359" title="359">        <span class="va">self</span>.board[kee[<span class="dv">0</span>]][kee[<span class="dv">1</span>]] <span class="op">=</span> n</a>
<a class="sourceLine" id="cb1-360" title="360">        <span class="kw">del</span> <span class="va">self</span>.val[kee]</a>
<a class="sourceLine" id="cb1-361" title="361">        i, j <span class="op">=</span> kee</a>
<a class="sourceLine" id="cb1-362" title="362">        <span class="cf">for</span> ind <span class="kw">in</span> <span class="va">self</span>.val.keys():</a>
<a class="sourceLine" id="cb1-363" title="363">            <span class="cf">if</span> n <span class="kw">in</span> <span class="va">self</span>.val[ind]:</a>
<a class="sourceLine" id="cb1-364" title="364">                <span class="cf">if</span> (</a>
<a class="sourceLine" id="cb1-365" title="365">                    ind[<span class="dv">0</span>] <span class="op">==</span> i</a>
<a class="sourceLine" id="cb1-366" title="366">                    <span class="kw">or</span> ind[<span class="dv">1</span>] <span class="op">==</span> j</a>
<a class="sourceLine" id="cb1-367" title="367">                    <span class="kw">or</span> (ind[<span class="dv">0</span>] <span class="op">/</span> <span class="dv">3</span>, ind[<span class="dv">1</span>] <span class="op">/</span> <span class="dv">3</span>) <span class="op">==</span> (i <span class="op">/</span> <span class="dv">3</span>, j <span class="op">/</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb1-368" title="368">                ):</a>
<a class="sourceLine" id="cb1-369" title="369">                    update[ind] <span class="op">=</span> n</a>
<a class="sourceLine" id="cb1-370" title="370">                    <span class="va">self</span>.val[ind].remove(n)</a>
<a class="sourceLine" id="cb1-371" title="371">                    <span class="cf">if</span> <span class="bu">len</span>(<span class="va">self</span>.val[ind]) <span class="op">==</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb1-372" title="372">                        <span class="cf">return</span> <span class="va">False</span></a>
<a class="sourceLine" id="cb1-373" title="373">        <span class="cf">return</span> <span class="va">True</span></a>
<a class="sourceLine" id="cb1-374" title="374"></a>
<a class="sourceLine" id="cb1-375" title="375">    <span class="kw">def</span> undo(<span class="va">self</span>, kee, update):</a>
<a class="sourceLine" id="cb1-376" title="376">        <span class="va">self</span>.board[kee[<span class="dv">0</span>]][kee[<span class="dv">1</span>]] <span class="op">=</span> <span class="st">&quot;.&quot;</span></a>
<a class="sourceLine" id="cb1-377" title="377">        <span class="cf">for</span> k <span class="kw">in</span> update:</a>
<a class="sourceLine" id="cb1-378" title="378">            <span class="cf">if</span> k <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.val:</a>
<a class="sourceLine" id="cb1-379" title="379">                <span class="va">self</span>.val[k] <span class="op">=</span> update[k]</a>
<a class="sourceLine" id="cb1-380" title="380">            <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb1-381" title="381">                <span class="va">self</span>.val[k].append(update[k])</a>
<a class="sourceLine" id="cb1-382" title="382">        <span class="cf">return</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb1-383" title="383"></a>
<a class="sourceLine" id="cb1-384" title="384">    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb1-385" title="385">        <span class="co">&quot;&quot;&quot;[summary]</span></a>
<a class="sourceLine" id="cb1-386" title="386"><span class="co">        Generates a board representation as string.</span></a>
<a class="sourceLine" id="cb1-387" title="387"></a>
<a class="sourceLine" id="cb1-388" title="388"><span class="co">        Returns:</span></a>
<a class="sourceLine" id="cb1-389" title="389"><span class="co">            [str] -- [board representation]</span></a>
<a class="sourceLine" id="cb1-390" title="390"><span class="co">        &quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-391" title="391"></a>
<a class="sourceLine" id="cb1-392" title="392">        resp <span class="op">=</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-393" title="393">        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.row):</a>
<a class="sourceLine" id="cb1-394" title="394">            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.col):</a>
<a class="sourceLine" id="cb1-395" title="395">                resp <span class="op">+=</span> <span class="st">&quot; </span><span class="sc">{0}</span><span class="st"> &quot;</span>.<span class="bu">format</span>(<span class="va">self</span>.board[i][j])</a>
<a class="sourceLine" id="cb1-396" title="396">            resp <span class="op">+=</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span></a>
<a class="sourceLine" id="cb1-397" title="397">        <span class="cf">return</span> resp</a>
<a class="sourceLine" id="cb1-398" title="398"></a>
<a class="sourceLine" id="cb1-399" title="399"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-400" title="400"><span class="co">You are given a m x n 2D grid initialized with these three possible values:</span></a>
<a class="sourceLine" id="cb1-401" title="401"><span class="co">    -1: A wall or an obstacle.</span></a>
<a class="sourceLine" id="cb1-402" title="402"><span class="co">    0: A gate.</span></a>
<a class="sourceLine" id="cb1-403" title="403"><span class="co">    INF: Infinity means an empty room. We use the value 2^31 - 1 = 2147483647 to represent INF</span></a>
<a class="sourceLine" id="cb1-404" title="404"><span class="co">         as you may assume that the distance to a gate is less than 2147483647.</span></a>
<a class="sourceLine" id="cb1-405" title="405"><span class="co">Fill the empty room with distance to its nearest gate.</span></a>
<a class="sourceLine" id="cb1-406" title="406"><span class="co">If it is impossible to reach a gate, it should be filled with INF.</span></a>
<a class="sourceLine" id="cb1-407" title="407"></a>
<a class="sourceLine" id="cb1-408" title="408"><span class="co">For example, given the 2D grid:</span></a>
<a class="sourceLine" id="cb1-409" title="409"><span class="co">    INF -1  0   INF</span></a>
<a class="sourceLine" id="cb1-410" title="410"><span class="co">    INF INF INF -1</span></a>
<a class="sourceLine" id="cb1-411" title="411"><span class="co">    INF -1  INF -1</span></a>
<a class="sourceLine" id="cb1-412" title="412"><span class="co">    0   -1  INF INF</span></a>
<a class="sourceLine" id="cb1-413" title="413"><span class="co">After running your function, the 2D grid should be:</span></a>
<a class="sourceLine" id="cb1-414" title="414"><span class="co">    3   -1  0   1</span></a>
<a class="sourceLine" id="cb1-415" title="415"><span class="co">    2   2   1   -1</span></a>
<a class="sourceLine" id="cb1-416" title="416"><span class="co">    1   -1  2   -1</span></a>
<a class="sourceLine" id="cb1-417" title="417"><span class="co">    0   -1  3   4</span></a>
<a class="sourceLine" id="cb1-418" title="418"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-419" title="419"></a>
<a class="sourceLine" id="cb1-420" title="420"></a>
<a class="sourceLine" id="cb1-421" title="421"><span class="kw">def</span> walls_and_gates(rooms):</a>
<a class="sourceLine" id="cb1-422" title="422">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(rooms)):</a>
<a class="sourceLine" id="cb1-423" title="423">        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(rooms[<span class="dv">0</span>])):</a>
<a class="sourceLine" id="cb1-424" title="424">            <span class="cf">if</span> rooms[i][j] <span class="op">==</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb1-425" title="425">                dfs(rooms, i, j, <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb1-426" title="426"></a>
<a class="sourceLine" id="cb1-427" title="427"></a>
<a class="sourceLine" id="cb1-428" title="428"><span class="kw">def</span> dfs(rooms, i, j, depth):</a>
<a class="sourceLine" id="cb1-429" title="429">    <span class="cf">if</span> (i <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">or</span> i <span class="op">&gt;=</span> <span class="bu">len</span>(rooms)) <span class="kw">or</span> (j <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">or</span> j <span class="op">&gt;=</span> <span class="bu">len</span>(rooms[<span class="dv">0</span>])):</a>
<a class="sourceLine" id="cb1-430" title="430">        <span class="cf">return</span>  <span class="co"># out of bounds</span></a>
<a class="sourceLine" id="cb1-431" title="431">    <span class="cf">if</span> rooms[i][j] <span class="op">&lt;</span> depth:</a>
<a class="sourceLine" id="cb1-432" title="432">        <span class="cf">return</span>  <span class="co"># crossed</span></a>
<a class="sourceLine" id="cb1-433" title="433">    rooms[i][j] <span class="op">=</span> depth</a>
<a class="sourceLine" id="cb1-434" title="434">    dfs(rooms, i <span class="op">+</span> <span class="dv">1</span>, j, depth <span class="op">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-435" title="435">    dfs(rooms, i <span class="op">-</span> <span class="dv">1</span>, j, depth <span class="op">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-436" title="436">    dfs(rooms, i, j <span class="op">+</span> <span class="dv">1</span>, depth <span class="op">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-437" title="437">    dfs(rooms, i, j <span class="op">-</span> <span class="dv">1</span>, depth <span class="op">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-438" title="438"></a></code></pre>
    </div>
    <p>{% endtab %}</p>
    <p>{% tab title=“Second Tab” %}</p>
    <p>{% endtab %} {% endtabs %}</p>
    <h4 id="introduction">Introduction <a id="introduction"></a></h4>
    <p>
      Originating from mathematics, graphs are now widely used data structures
      in Computer Science. One of the first problems we encounter when
      constructing any algorithm regarding Graph processing or traversal, is
      <em>how we represent the graph</em> and then, how to
      <em>traverse that representation</em>.
    </p>
    <blockquote>
      <p>
        Graph traversal is not a trivial problem, and given the difficulty of
        the task - many algorithms have been devised for efficient (yet not
        perfect) graph traversal.
      </p>
    </blockquote>
    <p>
      In this guide, we’ll take a look at one of the two fundamental and
      simplest algorithms for Graph traversal -
      <em><strong>Depth-First Search (DFS).</strong></em> It’s the most commonly
      used algorithm alongside the related
      <em><strong>Breadth-First Search (BFS)</strong></em> given their
      simplicity. After going over the main idea used for DFS, we’ll implement
      it in Python on a Graph representation - an
      <em><strong>adjacency list</strong></em
      >.
    </p>
    <h4 id="depth-first-search---theory">
      Depth-First Search - Theory <a id="depthfirstsearchtheory"></a>
    </h4>
    <p>
      <em><strong>Depth-First Search (DFS)</strong></em> is an algorithm used to
      <em><strong>traverse</strong></em> or locate a
      <em><strong>target</strong></em> node in a graph or tree data structure.
      It priorities <em>depth</em> and searches along one branch, as far as it
      can go - until the end of that branch. Once there, it
      <strong>backtracks</strong> to the first possible divergence from that
      branch, and searches until the end of <em>that</em> branch, repeating the
      process.
    </p>
    <p>
      Given the nature of the algorithm, you can easily implement it recursively
      - and you can always implement a recursive algorithm iteratively as well:
    </p>
    <p>
      <img
        src="https://stackabuse.s3.amazonaws.com/media/graph-traversal-in-java-depth-first-search-dfs-1.gif"
      />
    </p>
    <p>
      The <em><strong>start node</strong></em> is the
      <em><strong>root node</strong></em> for <em>tree data structures</em>,
      while with more generic graphs - it can be any node.
    </p>
    <p>
      DFS is widely-used as a part of many other algorithms that resolve
      graph-represented problems. From cycle searches, path finding, topological
      sorting, to finding articulation points and strongly connected components.
      The reason behind this widespread use of the DFS algorithm lays in its
      overall simplicity and easy recursive implementation.
    </p>
    <h4 id="the-dfs-algorithm">
      The DFS Algorithm <a id="thedfsalgorithm"></a>
    </h4>
    <p>
      The DFS algorithm is pretty simple and consists of the following steps:
    </p>
    <ol type="1">
      <li>Mark the current node as <strong>visited</strong>.</li>
      <li>
        Traverse the <strong>neighbouring</strong> nodes that
        <em>aren’t visited</em> and recursively call the DFS function for that
        node.
      </li>
    </ol>
    <p>
      The algorithm stops either when the target node is found, or the whole
      graph has been <strong>traversed</strong> (all nodes are visited).
    </p>
    <blockquote>
      <p>
        Since graphs can have <strong>cycles</strong>, we’ll need a system to
        avoid them so we don’t fall into infinity loops. That’s why we “mark”
        every node we pass as <strong>visited</strong> by adding them to a
        <code>Set</code> containing only unique entries.
      </p>
    </blockquote>
    <p>
      By marking nodes as “visited”, if we ever encounter that node again -
      we’re in a loop! Endless computational power and time has been wasted on
      loops, lost in the aether.
    </p>
    <p><strong>Pseudocode</strong></p>
    <p>Given these steps, we can summarize DFS in pseudocode:</p>
    <div class="sourceCode" id="cb2">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1">DFS(G, u):</a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="co"># Input processing</span></a>
<a class="sourceLine" id="cb2-3" title="3">    u.visited <span class="op">=</span> true</a>
<a class="sourceLine" id="cb2-4" title="4">    <span class="cf">for</span> each v <span class="kw">in</span> G.adj[u]:</a>
<a class="sourceLine" id="cb2-5" title="5">        <span class="cf">if</span> <span class="op">!</span>v.visited:</a>
<a class="sourceLine" id="cb2-6" title="6">            DFS(G, v)</a>
<a class="sourceLine" id="cb2-7" title="7">            <span class="co"># Output processing</span></a></code></pre>
    </div>
    <p>
      <strong>Input</strong> and <strong>output</strong> processing are
      performed depending on the purpose of the graph search. Our input
      processing for DFS will be checking if the <strong>current</strong> node
      is equal to the <strong>target</strong> node.
    </p>
    <p>
      With this view, you can really start to appreciate just how simple yet
      useful this algorithm is.
    </p>
    <h4 id="depth-first-search---implementation">
      Depth-First Search - Implementation
      <a id="depthfirstsearchimplementation"></a>
    </h4>
    <p>
      Depth-First Search implementation is usually <strong>recursive</strong> in
      code given how natural of a pair that is, but it can also be easily
      implemented non-recursively. We’ll be using the recursive method as it’s
      simpler and more fitting:
    </p>
    <div class="sourceCode" id="cb3">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">def</span> dfs(adj_list, start, target, path, visited <span class="op">=</span> <span class="bu">set</span>()):</a>
<a class="sourceLine" id="cb3-2" title="2">    path.append(start)</a>
<a class="sourceLine" id="cb3-3" title="3">    visited.add(start)</a>
<a class="sourceLine" id="cb3-4" title="4">    <span class="cf">if</span> start <span class="op">==</span> target:</a>
<a class="sourceLine" id="cb3-5" title="5">        <span class="cf">return</span> path</a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="cf">for</span> neighbour <span class="kw">in</span> adj_list[start]:</a>
<a class="sourceLine" id="cb3-7" title="7">        <span class="cf">if</span> neighbour <span class="kw">not</span> <span class="kw">in</span> visited:</a>
<a class="sourceLine" id="cb3-8" title="8">            result <span class="op">=</span> dfs(adj_list, neighbour, target, path, visited)</a>
<a class="sourceLine" id="cb3-9" title="9">            <span class="cf">if</span> result <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</a>
<a class="sourceLine" id="cb3-10" title="10">                <span class="cf">return</span> result</a>
<a class="sourceLine" id="cb3-11" title="11">      path.pop()</a>
<a class="sourceLine" id="cb3-12" title="12">    <span class="cf">return</span> <span class="va">None</span></a></code></pre>
    </div>
    <p>
      We added the start node to the beginning of our traversal path and marked
      it as <strong>visited</strong> by adding it to a set of
      <code>visited</code> nodes. Then, we traversed the start node’s neighbours
      that <strong>aren’t</strong> already visited and called the function
      recursively for each of them. Recursive calls result in going as deep as
      we can along one “branch”.
    </p>
    <p>
      We saved the recursion result in a variable - in the case it returns
      <code>None</code> that means that the target node was not found in this
      branch and that we should try another. If the recursive call, in fact,
      does not return <code>None</code>, that means we have found our target
      node and we return the traversal path as result.
    </p>
    <p>
      In the end, if we find ourselves outside of the <code>for</code> loop, it
      means that all the neighbour branches of the current node have been
      visited and none of them lead to our target node. So, we remove the
      current node from the path, and return <code>None</code> as result.
    </p>
    <h4 id="running-dfs">Running DFS <a id="runningdfs"></a></h4>
    <p>
      Let’s illustrate how the code works through an example. We’ll be using a
      Python <strong>dictionary</strong> to represent the graph as an adjacency
      list. Here’s the graph we’ll be using in the following example:
    </p>
    <div class="sourceCode" id="cb4">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1">adj_list <span class="op">=</span> {</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="dv">0</span> : [<span class="dv">1</span>, <span class="dv">2</span>],</a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="dv">1</span> : [<span class="dv">0</span>, <span class="dv">3</span>],</a>
<a class="sourceLine" id="cb4-4" title="4">    <span class="dv">2</span> : [<span class="dv">0</span>, <span class="dv">3</span>],</a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="dv">3</span> : [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>],</a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="dv">4</span> : [<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb4-7" title="7">}</a></code></pre>
    </div>
    <blockquote>
      <p>
        An adjacency list is a type of graph representation in code, it consists
        of <strong>keys</strong> which represent each node, and a
        <strong>list</strong> of values for each of them containing nodes that
        are connected to the key node with an edge.
      </p>
    </blockquote>
    <p>
      Using a dictionary for this is the easiest way to quickly represent a
      graph in Python, though you could also define your own
      <code>Node</code> classes and add them to a <code>Graph</code> instance.
    </p>
    <p>Here’s what our example graph looks like:</p>
    <figure>
      <img
        src="https://s3.amazonaws.com/s3.stackabuse.com/media/articles/depth-first-search-dfs-in-python-theory-and-implementation-1.jpg"
        alt="graph"
      />
      <figcaption>graph</figcaption>
    </figure>
    <p>
      We’re searching for a path from node <code>0</code> to node
      <code>3</code>, if it exists, the path will be saved into a set of visited
      nodes, called <code>traversal_path</code> so we can reconstruct it for
      printing:
    </p>
    <pre><code>traversal_path = []</code></pre>
    <div class="sourceCode" id="cb6">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb6-1" title="1">traversal_path <span class="op">=</span> dfs(adj_list, <span class="dv">0</span>, <span class="dv">3</span>, traversal_path)</a>
<a class="sourceLine" id="cb6-2" title="2"><span class="bu">print</span>(traversal_path)</a></code></pre>
    </div>
    <p>The steps our algorithm will take are as follows:</p>
    <ul>
      <li>
        Add node <code>0</code> to the traversal path and mark it as visited.
        Check if node <code>0</code> is equal to target node <code>3</code>,
        since it’s not, continue and traverse it’s neighbours (<code>1</code>
        and <code>2</code>).
      </li>
      <li>
        Is neighbour <code>1</code> visited? - No. Then, the algorithm calls the
        function recursively for that node.
        <ul>
          <li>
            Recursive call for node <code>1</code>: Add node <code>1</code> to
            the traversal path and mark it as visited, . Is <code>1</code> equal
            to our target node <code>3</code>? - No, continue and traverse it’s
            neighbours (<code>0</code> and <code>3</code>).
          </li>
          <li>
            Is neighbour <code>0</code> visited? - Yes, move onto the next one.
          </li>
          <li>
            Is neighbour <code>3</code> visited? - No, call the function
            recursively for this node.
            <ul>
              <li>
                Recursive call for node <code>3</code>: Add node
                <code>3</code> to the traversal path and mark it as visited. Is
                <code>3</code> equal to our target node <code>3</code>? - Yes,
                target node has been found, return the traversal path.
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
    <table>
      <thead>
        <tr class="header">
          <th style="text-align: left">Current Node</th>
          <th style="text-align: left">Path</th>
          <th style="text-align: left">Visited</th>
        </tr>
      </thead>
      <tbody>
        <tr class="odd">
          <td style="text-align: left"><code>0</code></td>
          <td style="text-align: left">[<code>0</code>]</td>
          <td style="text-align: left">{<code>0</code>}</td>
        </tr>
        <tr class="even">
          <td style="text-align: left"><code>1</code></td>
          <td style="text-align: left">[<code>0</code>, <code>1</code>]</td>
          <td style="text-align: left">{<code>0</code>, <code>1</code>}</td>
        </tr>
        <tr class="odd">
          <td style="text-align: left"><code>3</code></td>
          <td style="text-align: left">
            [<code>0</code>, <code>1</code>, <code>3</code>]
          </td>
          <td style="text-align: left">
            {<code>0</code>, <code>1</code>, <code>3</code>}
          </td>
        </tr>
      </tbody>
    </table>
    <p>
      The algorithm stops and our program prints out the resulting traversal
      path from node <code>0</code> to node <code>3</code>:
    </p>
    <div class="sourceCode" id="cb7">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb7-1" title="1">[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">3</span>]</a></code></pre>
    </div>
    <p>
      After the search, the marked nodes on the graph represent the path we took
      to get to the target node:
    </p>
    <figure>
      <img
        src="https://s3.amazonaws.com/s3.stackabuse.com/media/articles/depth-first-search-dfs-in-python-theory-and-implementation-2.png"
        alt="marked graph"
      />
      <figcaption>marked graph</figcaption>
    </figure>
    <p>
      In case there was no path between the start and target node, the traversal
      path would be <strong>empty</strong>.
    </p>
    <p>
      <strong>Note</strong>: Graphs can also be <strong>disconnected</strong>,
      meaning that there are at least two nodes that cannot be connected by a
      path. In this case, DFS would ignore the nodes that it can’t get to:
    </p>
    <figure>
      <img
        src="https://s3.amazonaws.com/s3.stackabuse.com/media/articles/depth-first-search-dfs-in-python-theory-and-implementation-3.png"
        alt="disconnected graph"
      />
      <figcaption>disconnected graph</figcaption>
    </figure>
    <p>
      For example in this graph, if we were to start DFS from node
      <code>0</code> to node <code>4</code>, there would be no such path because
      it has no way of getting to the target node.
    </p>
    <h4 id="conclusion">Conclusion <a id="conclusion"></a></h4>
    <p>
      In this article we’ve explained the theory behind the Depth-First Search
      algorithm. We’ve depicted the widely-used recursive Python implementation,
      and went over the borderline cases for which the algorithm will not work
      properly.
    </p>
  </body>
</html>
