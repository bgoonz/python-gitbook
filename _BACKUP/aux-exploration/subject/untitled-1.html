<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>untitled-1</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="general-data-structures">General Data Structures</h1>
<p>****</p>
<p>Data structures are <strong>vital building blocks</strong> for efficient, real-world problem solving. Data structures are proven and optimized tools that give you an easy frame to organize your programs. After all, there’s no need for you to remake the wheel (or structure) every time you need it.</p>
<p>Each data structure has a task or situation it is <strong>most suited to solve</strong>. Python has 4 built-in data structures, lists, dictionaries, tuples, and sets. These built-in data structures come with default methods and behind the scenes optimizations that make them easy to use.</p>
<p>Most data structures in Python are modified forms of these or use the built-in structures as their backbone.</p>
<ul>
<li><strong>List</strong>: Array-like structures that let you save a set of mutable objects of the same type to a variable.</li>
<li><strong>Tuple</strong>: Tuples are immutable lists, meaning the elements cannot be changed. It’s declared with parenthesis instead of square brackets.</li>
<li><strong>Set</strong>: Sets are unordered collections, meaning that elements are unindexed and have no set sequence. They’re declared with curly braces.</li>
<li><strong>Dictionary (dict)</strong>: Similar to hashmap or hash tables in other languages, a dictionary is a collection of key/value pairs. You initialize an empty dictionary with empty curly braces and fill it with colon separated keys and values. All keys are unique, immutable objects.</li>
</ul>
<p>Now, let’s see how we can use these structures to create all the advanced structures interviewers are looking for.</p>
<h3 id="arrays-lists-in-python">Arrays (Lists) in Python</h3>
<p>Python does not have a built in <a href="https://www.educative.io/blog/data-structures-arrays-javascript-tutorial">array</a> type, but you can use lists for all of the same tasks. An array is a collection of values of the <strong>same type saved under the same name</strong>.</p>
<p>Each value in the array is called an “element” and indexing that represents its position. You can access specific elements by calling the array name with the desired element’s index. You can also get the length of an array using the <code>len()</code> method.<img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTE2MDAiIGhlaWdodD0iMjc0NSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4=" /><img src="https://www.educative.io/cdn-cgi/image/f=auto,fit=contain,w=600/api/page/4827483893923840/image/download/4556366281179136" alt="widget" /><img src="https://www.educative.io/cdn-cgi/image/f=auto,fit=contain,w=300,q=10/api/page/4827483893923840/image/download/4556366281179136" alt="widget" /></p>
<p>Unlike programming languages like Java that have static arrays after declaration, Python’s arrays <strong>automatically scale up or down</strong> when elements are added/subtracted.</p>
<p>For example, we could use the <code>append()</code> method to add an additional element on the end of an existing array instead of declaring a new array.</p>
<p>This makes Python arrays particularly easy to use and adaptable on the fly.1234567cars = [“Toyota”, “Tesla”, “Hyundai”]print(len(cars))cars.append(“Honda”)cars.pop(1)for x in cars: print(x)Run</p>
<p><strong>Advantages:</strong></p>
<ul>
<li>Simple to create and use data sequences</li>
<li>Automatically scale to meet changing size requirements</li>
<li>Used to create more complex data structures</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Not optimized for scientific data (unlike NumPy’s array)</li>
<li>Can only manipulate the rightmost end of the list</li>
</ul>
<p><strong>Applications:</strong></p>
<ul>
<li>Shared storage of related values or objects, i.e. <code>myDogs</code></li>
<li>Data collections you’ll loop through</li>
<li>Collections of data structures, such as a list of tuples</li>
</ul>
<h4 id="common-arrays-interview-questions-in-python">Common arrays interview questions in Python</h4>
<ul>
<li>Remove even integers from list</li>
<li>Merge two sorted lists</li>
<li>Find minimum value in a list</li>
<li>Maximum sum sublist</li>
<li>Print products of all elements</li>
</ul>
<h3 id="queues-in-python">Queues in Python</h3>
<p><a href="https://www.educative.io/blog/data-structures-stack-queue-java-tutorial">Queues</a> are a linear data structure that store data in a “first in, first out” (FIFO) order. Unlike arrays, you cannot access elements by index and instead can <strong>only pull the next oldest element</strong>. This makes it great for order-sensitive tasks like online order processing or voicemail storage.</p>
<p>You can think of a queue as a line at the grocery store; the cashier does not choose who to check out next but rather processes the person who has stood in line the longest.</p>
<p>We could use a Python list with <code>append()</code> and <code>pop()</code> methods to implement a queue. However, this is inefficient because lists must shift all elements by one index whenever you add a new element to the beginning.</p>
<p>Instead, it’s best practice to use the <code>deque</code> class from Python’s <code>collections</code> module. Deques are optimized for the append and pop operations. The deque implementation also allows you to create double-ended queues, which can access both sides of the queue through the <code>popleft()</code> and <code>popright()</code> methods.1234567891011121314151617181920212223242526from collections import deque # Initializing a queueq = deque() # Adding elements to a queueq.append(‘a’)q.append(‘b’)q.append(‘c’) print(“Initial queue”)print(q) # Removing elements from a queueprint(“dequeued from the queue”)print(q.popleft())print(q.popleft())print(q.popleft()) print(“after removing elements”)print(q) # Uncommenting q.popleft()# will raise an IndexError# as queue is now emptyRun</p>
<p><strong>Advantages:</strong></p>
<ul>
<li>Automatically orders data chronologically</li>
<li>Scales to meet size requirements</li>
<li>Time efficient with <code>deque</code> class</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Can only access data on the ends</li>
</ul>
<p><strong>Applications:</strong></p>
<ul>
<li>Operations on a shared resource like a printer or <a href="https://www.educative.io/blog/beginners-guide-to-computers-and-programming">CPU core</a></li>
<li>Serve as temporary storage for batch systems</li>
<li>Provides an easy default order for tasks of equal importance</li>
</ul>
<h4 id="common-queue-interview-questions-in-python">Common queue interview questions in Python</h4>
<ul>
<li>Reverse first k elements of a queue</li>
<li>Implement a queue using a linked list</li>
<li>Implement a stack using a queue</li>
</ul>
<h3 id="stacks-in-python">Stacks in Python</h3>
<p><a href="https://www.educative.io/blog/data-structures-stack-queue-java-tutorial">Stacks</a> are a sequential data structure that act as the Last-in, First-out (LIFO) version of queues. The last element inserted in a stack is considered at the <strong>top of the stack</strong> and is the only accessible element. To access a middle element, you must first remove enough elements to make the desired element the top of the stack.</p>
<p>Many developers imagine stacks as a stack of dinner plates; you can add or remove plates to the top of the stack but must move the whole stack to place one at the bottom.</p>
<p>Adding elements is known as a <strong>push,</strong> and removing elements is known as a <strong>pop</strong>. You can implement stacks in Python using the built-in list structure. With list implementation, push operations use the <code>append()</code> method, and pop operations use <code>pop()</code>.1234567891011121314151617181920212223242526stack = [] # append() function to push# element in the stackstack.append(‘a’)stack.append(‘b’)stack.append(‘c’) print(‘Initial stack’)print(stack) # pop() function to pop# element from stack in # LIFO orderprint(‘popped from stack:’)print(stack.pop())print(stack.pop())print(stack.pop()) print(‘after elements are popped:’)print(stack) # uncommenting print(stack.pop()) # will cause an IndexError # as the stack is now emptyRun</p>
<p><strong>Advantages:</strong></p>
<ul>
<li>Offers LIFO data management that’s impossible with arrays</li>
<li>Automatic scaling and object cleanup</li>
<li>Simple and reliable data storage system</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Stack memory is limited</li>
<li>Too many objects on the stack leads to a stack overflow error</li>
</ul>
<p><strong>Applications:</strong></p>
<ul>
<li>Used for making highly reactive systems</li>
<li>Memory management systems use stacks to handle the most recent requests first</li>
<li>Helpful for questions like parenthesis matching</li>
</ul>
<h4 id="common-stacks-interview-questions-in-python">Common stacks interview questions in Python</h4>
<ul>
<li>Implement a queue using stacks</li>
<li>Evaluate a Postfix expression with a stack</li>
<li>Next greatest element using a stack</li>
<li>Create a <code>min()</code> function using a stack</li>
</ul>
<h3 id="linked-lists-in-python">Linked lists in Python</h3>
<p><a href="https://www.educative.io/blog/data-structures-linked-list-java-tutorial">Linked lists</a> are a sequential collection of data that uses <strong>relational pointers on each data node</strong> to link to the next node in the list.</p>
<p>Unlike arrays, linked lists do not have objective positions in the list. Instead, they have relational positions based on their surrounding nodes.</p>
<p>The first node in a linked list is called the <strong>head node,</strong> and the final is called the <strong>tail node</strong>, which has a <code>null</code> pointer.<img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNzI4MCIgaGVpZ2h0PSI0NzM1IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIvPg==" /><img src="https://www.educative.io/cdn-cgi/image/f=auto,fit=contain,w=600/api/page/4827483893923840/image/download/5638844823633920" alt="widget" /><img src="https://www.educative.io/cdn-cgi/image/f=auto,fit=contain,w=300,q=10/api/page/4827483893923840/image/download/5638844823633920" alt="widget" /></p>
<p>Linked lists can be singly or doubly linked depending if each node has just a single pointer to the next node or if it also has a second pointer to the previous node.</p>
<p>You can think of linked lists like a chain; individual links only have a connection to their immediate neighbors but all the links together form a larger structure.</p>
<p>Python does not have a built-in implementation of linked lists and therefore requires that you implement a <code>Node</code> class to hold a data value and one or more pointers.12345678910111213141516171819class Node: def __init__(self, dataval=None): self.dataval = dataval self.nextval = None class SLinkedList: def __init__(self): self.headval = None list1 = SLinkedList()list1.headval = Node(“Mon”)e2 = Node(“Tue”)e3 = Node(“Wed”)# Link first Node to second nodelist1.headval.nextval = e2 # Link second Node to third nodee2.nextval = e3Run</p>
<p>Linked lists are primarily used to create advanced data structures like graphs and trees or for tasks that require frequent addition/deletion of elements across the structure.</p>
<p><strong>Advantages:</strong></p>
<ul>
<li>Efficient insertion and deletion of new elements</li>
<li>Simpler to reorganize than arrays</li>
<li>Useful as a starting point for advanced data structures like graphs or trees</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Storage of pointers with each data point increases memory usage</li>
<li>Must always traverse the linked list from Head node to find a specific element</li>
</ul>
<p><strong>Applications:</strong></p>
<ul>
<li>Building block for advanced data structures</li>
<li>Solutions that call for frequent addition and removal of data</li>
</ul>
<h4 id="common-linked-list-interview-questions-in-python">Common linked list interview questions in Python</h4>
<ul>
<li>Print the middle element of a given linked list</li>
<li>Remove duplicate elements from a sorted linked list</li>
<li>Check if a singly linked list is a palindrome</li>
<li>Merge K sorted linked lists</li>
<li>Find the intersection point of two linked lists</li>
</ul>
<h3 id="circular-linked-lists-in-python">Circular linked lists in Python</h3>
<p>The primary downside of the standard linked list is that you always have to start at the Head node.</p>
<p>The circular linked list fixes this problem by replacing the Tail node’s <code>null</code> pointer with a pointer <strong>back to the Head node</strong>. When traversing, the program will follow pointers until it reaches the node it started on.</p>
<p>The advantage of this setup is that you can start at any node and traverse the whole list. It also allows you to use linked lists as a loopable structure by setting a desired number of cycles through the structure.</p>
<p>Circular linked lists are great for processes that loop for a long time like CPU allocation in operating systems.</p>
<p><strong>Advantages:</strong></p>
<ul>
<li>Can traverse whole list starting from any node</li>
<li>Makes linked lists more suited to looping structures</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>More difficult to find the Head and Tail nodes of the list without a <code>null</code> marker</li>
</ul>
<p><strong>Applications:</strong></p>
<ul>
<li>Regularly looping solutions like CPU scheduling</li>
<li>Solutions where you want the freedom to start traversal at any node</li>
</ul>
<h4 id="common-circular-linked-list-interview-questions-in-python">Common circular linked list interview questions in Python</h4>
<ul>
<li>Detect loop in a linked lists</li>
<li>Reverse a circular linked list</li>
<li>Reverse circular linked list in groups of give size</li>
</ul>
<p><strong>Keep brushing up on Python Data Structures</strong></p>
<p>Practiced knowledge of data structures is essential for any interviewee. Educative’s text-based courses give you hundreds of hands-on practice problems to ensure you’re ready when the time comes.</p>
<p><a href="https://www.educative.io/path/ace-python-coding-interview"><strong>Ace the Python Coding Interview</strong></a></p>
<h3 id="trees-in-python">Trees in Python</h3>
<p><a href="https://www.educative.io/blog/data-structures-trees-java">Trees</a> are another relation-based data structure, which specialize in representing hierarchical structures. Like a linked list, they’re populated with <code>Node</code> objects that contain a data value and one or more pointers to define its relation to immediate nodes.</p>
<p>Each tree has a <strong>root</strong> node that all other nodes branch off from. The root contains pointers to all elements directly below it, which are known as its <strong>child nodes</strong>. These child nodes can then have child nodes of their own. Binary trees cannot have nodes with more than two child nodes.</p>
<p>Any nodes on the same level are called <strong>sibling nodes</strong>. Nodes with no connected child nodes are known as <strong>leaf nodes</strong>.<img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODE4NSIgaGVpZ2h0PSI2NTgwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIvPg==" /><img src="https://www.educative.io/cdn-cgi/image/f=auto,fit=contain,w=600/api/page/4827483893923840/image/download/6470804819148800" alt="widget" /><img src="https://www.educative.io/cdn-cgi/image/f=auto,fit=contain,w=300,q=10/api/page/4827483893923840/image/download/6470804819148800" alt="widget" /></p>
<p>The most common application of the binary tree is a <strong>binary search tree</strong>. Binary search trees excel at searching large collections of data, as the time complexity depends on the depth of the tree rather than the number of nodes.</p>
<blockquote>
<p><strong>Binary search trees have four strict rules:</strong></p>
<ul>
<li>The left subtree contains only nodes with elements lesser than the root.</li>
<li>The right subtree contains only nodes with elements greater than the root.</li>
<li>Left and right subtrees must also be a binary search tree. They must follow the above rules with the “root” of their tree.</li>
<li>There can be no duplicate nodes, i.e. no two nodes can have the same value.</li>
</ul>
</blockquote>
<p>12345678910111213141516171819202122232425262728293031class Node: def __init__(self, data): self.left = None self.right = None self.data = data def insert(self, data):# Compare the new value with the parent node if self.data: if data &lt; self.data: if self.left is None: self.left = Node(data) else: self.left.insert(data) elif data &gt; self.data: if self.right is None: self.right = Node(data) else: self.right.insert(data) else: self.data = data # Print the tree def PrintTree(self): if self.left: self.left.PrintTree() print( self.data), if self.right: self.right.PrintTree()Run</p>
<p><strong>Advantages:</strong></p>
<ul>
<li>Good for representing hierarchical relationships</li>
<li>Dynamic size, great at scale</li>
<li>Quick insert and delete operations</li>
<li>In a binary search tree, inserted nodes are sequenced immediately.</li>
<li>Binary search trees are efficient at searches; length is only O(height)O(height).</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Time expensive, O(logn)4O(logn)4, to modify or “balance” trees or retrieve elements from a known location</li>
<li>Child nodes hold no information on their parent node and can be hard to traverse backwards</li>
<li>Only works for lists that are sorted. Unsorted data degrades into linear search.</li>
</ul>
<p><strong>Applications:</strong></p>
<ul>
<li>Great for storing hierarchical data such as a file location</li>
<li>Used to implement top searching and sorting algorithms like binary search trees and binary heaps</li>
</ul>
<h4 id="common-tree-interview-questions-in-python">Common tree interview questions in Python</h4>
<ul>
<li>Check if two binary trees are identical</li>
<li><a href="https://www.educative.io/blog/tree-traversal-algorithms">Implement level order traversal of a binary tree</a></li>
<li>Print the perimeter of a binary search tree</li>
<li>Sum all nodes along a path</li>
<li>Connect all siblings of a binary tree</li>
</ul>
<h3 id="graphs-in-python">Graphs in Python</h3>
<p><a href="https://www.educative.io/blog/graph-algorithms-tutorial">Graphs</a> are a data structure used to represent a visual of relationships between data <strong>vertices</strong> (the Nodes of a graph). The links that connect vertices together are called <strong>edges</strong>.</p>
<p>Edges define which vertices are connected but does not indicate a direction flow between them. Each vertex has connections to other vertices which are saved on the vertex as a comma-separated list.Undirected</p>
<p>There are also special graphs called <strong>directed graphs</strong> that define a direction of the relationship, similar to a linked list. Directed graphs are helpful when modeling one-way relationships or a flowchart-like structure.Directed</p>
<p>They’re primarily used to convey visual web-structure networks in code form. These structures can model many different types of relationships like hierarchies, branching structures, or simply be an unordered relational web. The versatility and intuitiveness of graphs makes them a favorite for <a href="https://www.educative.io/blog/python-pandas-tutorial">data science</a>.</p>
<p>When written in plain text, graphs have a list of vertices and edges:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1">V <span class="op">=</span> {a, b, c, d, e}</a>
<a class="sourceLine" id="cb1-2" title="2">E <span class="op">=</span> {ab, ac, bd, cd, de}</a></code></pre></div>
<p>In Python, graphs are best implemented using a dictionary with the name of each vertex as a key and the edges list as the values.12345678910# Create the dictionary with graph elementsgraph = { “a” : [“b”,“c”], “b” : [“a”, “d”], “c” : [“a”, “d”], “d” : [“e”], “e” : [“d”] } # Print the graph print(graph)Run</p>
<p><strong>Advantages:</strong></p>
<ul>
<li>Quickly convey visual information through code</li>
<li>Usable for modeling a wide range of real world problems</li>
<li>Simple to learn syntax</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Vertex links are difficult to understand in large graphs</li>
<li>Time expensive to parse data from a graph</li>
</ul>
<p><strong>Applications:</strong></p>
<ul>
<li>Excellent for modeling networks or web-like structures</li>
<li>Used to model social network sites like <a href="https://www.educative.io/blog/cracking-top-facebook-coding-interview-questions">Facebook</a></li>
</ul>
<h4 id="common-graph-interview-questions-in-python">Common graph interview questions in Python</h4>
<ul>
<li>Detect cycle in a directed graph</li>
<li>Find a “Mother Vertex” in a directed graph</li>
<li>Count number of edges in an undirected graph</li>
<li>Check if a path exists between two vertices</li>
<li>Find the shortest path between two vertices</li>
</ul>
<h3 id="hash-tables-in-python">Hash tables in Python</h3>
<p><a href="https://www.educative.io/blog/data-strucutres-hash-table-javascript">Hash tables</a> are a complex data structure capable of storing large amounts of information and retrieving specific elements efficiently.</p>
<p>This data structure uses key/value pairs, where the key is the name of the desired element and the value is the data stored under that name.<img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNzcwNSIgaGVpZ2h0PSIzMzIwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIvPg==" /><img src="https://www.educative.io/cdn-cgi/image/f=auto,fit=contain,w=600/api/page/4827483893923840/image/download/6321108700102656" alt="widget" /><img src="https://www.educative.io/cdn-cgi/image/f=auto,fit=contain,w=300,q=10/api/page/4827483893923840/image/download/6321108700102656" alt="widget" /></p>
<p>Each input key goes through a <strong>hash function</strong> that converts it from its starting form into an integer value, called a <strong>hash</strong>. Hash functions must always produce the same hash from the same input, must compute quickly, and produce fixed-length values. Python includes a built-in <code>hash()</code> function that speeds up implementation.</p>
<p>The table then uses the hash to find the general location of the desired value, called a <strong>storage bucket</strong>. The program then only has to search this subgroup for the desired value rather than the entire data pool.</p>
<p>Beyond this general framework, hash tables can be very different depending on the application. Some may allow keys from different data types, while some may have differently setup buckets or different hash functions.</p>
<p>Here is an example of a hash table in Python code:12345678910111213141516171819202122232425262728293031import pprintclass Hashtable: def __init__(self, elements): self.bucket_size = len(elements) self.buckets = [[] for i in range(self.bucket_size)] self._assign_buckets(elements) def _assign_buckets(self, elements): for key, value in elements: #calculates the hash of each key hashed_value = hash(key) index = hashed_value % self.bucket_size # positions the element in the bucket using hash self.buckets[index].append((key, value)) #adds a tuple in the bucket def get_value(self, input_key): hashed_value = hash(input_key) index = hashed_value % self.bucket_size bucket = self.buckets[index] for key, value in bucket: if key == input_key: return(value) return None def __str__(self): return pprint.pformat(self.buckets) # pformat returns a printable representation of the objectif __name__ == “__main__”: capitals = [ (‘France’, ‘Paris’), (‘United States’, ‘Washington D.C.’), (‘Italy’, ‘Rome’), (‘Canada’, ‘Ottawa’) ]hashtable = Hashtable(capitals)print(hashtable)print(f“The capital of Italy is {hashtable.get_value(‘Italy’)}”)Run</p>
<p><strong>Advantages:</strong></p>
<ul>
<li>Can covert keys in any form to integer indices</li>
<li>Extremely effective for large data sets</li>
<li>Very effective search function</li>
<li>Constant number of steps for each search and constant efficiency for adding or deleting elements</li>
<li>Optimized in <a href="https://www.educative.io/blog/python3-guide">Python 3</a></li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Hashes must be unique, two keys converting to the same hash causes a collision error</li>
<li>Collision errors require full overhaul of hash function</li>
<li>Difficult to build for beginners</li>
</ul>
<p><strong>Applications:</strong></p>
<ul>
<li>Used for large, frequently-searched databases</li>
<li>Retrieval systems that use input keys</li>
</ul>
<h4 id="common-hash-table-interview-questions-in-python">Common hash table interview questions in Python</h4>
<ul>
<li>Build a hash table from scratch (without built-in functions)</li>
<li>Word formation using a hash table</li>
<li>Find two numbers that add up to “k”</li>
<li>Implement open addressing for collision handling</li>
<li>Detect if a list is cyclical using a hash table</li>
</ul>
<p>****</p>
<p>****</p>
<p><strong>Data structures</strong> are the fundamental constructs around which you build your programs. Each data structure provides a particular way of organizing data so it can be accessed efficiently, depending on your use case. Python ships with an extensive set of data structures in its <a href="https://docs.python.org/3/library/index.html">standard library</a>.</p>
<p>However, Python’s naming convention doesn’t provide the same level of clarity that you’ll find in other languages. In <a href="https://realpython.com/oop-in-python-vs-java/">Java</a>, a list isn’t just a <code>list</code>—it’s either a <code>LinkedList</code> or an <code>ArrayList</code>. Not so in Python. Even experienced Python developers sometimes wonder whether the built-in <code>list</code> type is implemented as a <a href="https://realpython.com/linked-lists-python/">linked list</a> or a dynamic array.</p>
<p><strong>In this tutorial, you’ll learn:</strong></p>
<ul>
<li>Which common <strong>abstract data types</strong> are built into the Python standard library</li>
<li>How the most common abstract data types map to Python’s <strong>naming scheme</strong></li>
<li>How to put abstract data types to <strong>practical use</strong> in various algorithms</li>
</ul>
<p><strong>Note:</strong> This tutorial is adapted from the chapter “Common Data Structures in Python” in <a href="https://realpython.com/products/python-tricks-book/"><em>Python Tricks: The Book</em></a>. If you enjoy what you read below, then be sure to check out <a href="https://realpython.com/products/python-tricks-book/">the rest of the book</a>.</p>
<h3 id="dictionaries-maps-and-hash-tables">Dictionaries, Maps, and Hash Tables</h3>
<p>In Python, <a href="https://realpython.com/python-dicts/">dictionaries</a> (or <strong>dicts</strong> for short) are a central data structure. Dicts store an arbitrary number of objects, each identified by a unique dictionary <strong>key</strong>.</p>
<p>Dictionaries are also often called <strong>maps</strong>, <strong>hashmaps</strong>, <strong>lookup tables</strong>, or <strong>associative arrays</strong>. They allow for the efficient lookup, insertion, and deletion of any object associated with a given key.</p>
<p>Phone books make a decent real-world analog for dictionary objects. They allow you to quickly retrieve the information (phone number) associated with a given key (a person’s name). Instead of having to read a phone book front to back to find someone’s number, you can jump more or less directly to a name and look up the associated information.</p>
<p>This analogy breaks down somewhat when it comes to <em>how</em> the information is organized to allow for fast lookups. But the fundamental performance characteristics hold. Dictionaries allow you to quickly find the information associated with a given key.</p>
<p>Dictionaries are one of the most important and frequently used data structures in computer science. So, how does Python handle dictionaries? Let’s take a tour of the dictionary implementations available in core Python and the Python standard library.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1"><span class="co">### `dict`: Your Go-To Dictionary[](https://realpython.com/python-data-structures/#dict-your-go-to-dictionary &quot;Permanent link&quot;)</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3">Because dictionaries are so important, Python features a robust dictionary implementation that’s built directly into the core language: the [`dict`](https:<span class="op">//</span>docs.python.org<span class="op">/</span><span class="dv">3</span><span class="op">/</span>library<span class="op">/</span>stdtypes.html<span class="co">#mapping-types-dict) data type.</span></a>
<a class="sourceLine" id="cb2-4" title="4"></a>
<a class="sourceLine" id="cb2-5" title="5">Python also provides some useful <span class="op">**</span>syntactic sugar<span class="op">**</span> <span class="cf">for</span> working <span class="cf">with</span> dictionaries <span class="kw">in</span> your programs. For example, the curly<span class="op">-</span>brace ({ }) dictionary expression syntax <span class="kw">and</span> [dictionary comprehensions](https:<span class="op">//</span>realpython.com<span class="op">/</span>iterate<span class="op">-</span>through<span class="op">-</span>dictionary<span class="op">-</span>python<span class="op">/</span><span class="co">#using-comprehensions) allow you to conveniently define new dictionary objects:</span></a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7"></a>
<a class="sourceLine" id="cb2-8" title="8"></a>
<a class="sourceLine" id="cb2-9" title="9"></a>
<a class="sourceLine" id="cb2-10" title="10">```py</a>
<a class="sourceLine" id="cb2-11" title="11"> phonebook <span class="op">=</span> {</a>
<a class="sourceLine" id="cb2-12" title="12">     <span class="st">&quot;bob&quot;</span>: <span class="dv">7387</span>,</a>
<a class="sourceLine" id="cb2-13" title="13">     <span class="st">&quot;alice&quot;</span>: <span class="dv">3719</span>,</a>
<a class="sourceLine" id="cb2-14" title="14">     <span class="st">&quot;jack&quot;</span>: <span class="dv">7052</span>,</a>
<a class="sourceLine" id="cb2-15" title="15"> }</a>
<a class="sourceLine" id="cb2-16" title="16"></a>
<a class="sourceLine" id="cb2-17" title="17"></a>
<a class="sourceLine" id="cb2-18" title="18"> squares <span class="op">=</span> {x: x <span class="op">*</span> x <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">6</span>)}</a>
<a class="sourceLine" id="cb2-19" title="19"></a>
<a class="sourceLine" id="cb2-20" title="20"></a>
<a class="sourceLine" id="cb2-21" title="21"> phonebook[<span class="st">&quot;alice&quot;</span>]</a>
<a class="sourceLine" id="cb2-22" title="22"><span class="dv">3719</span></a>
<a class="sourceLine" id="cb2-23" title="23"></a>
<a class="sourceLine" id="cb2-24" title="24"></a>
<a class="sourceLine" id="cb2-25" title="25"> squares</a>
<a class="sourceLine" id="cb2-26" title="26">{<span class="dv">0</span>: <span class="dv">0</span>, <span class="dv">1</span>: <span class="dv">1</span>, <span class="dv">2</span>: <span class="dv">4</span>, <span class="dv">3</span>: <span class="dv">9</span>, <span class="dv">4</span>: <span class="dv">16</span>, <span class="dv">5</span>: <span class="dv">25</span>}`</a>
<a class="sourceLine" id="cb2-27" title="27"></a></code></pre></div>
<h4 id="section">``</h4>
<p>There are some restrictions on which objects can be used as valid keys.</p>
<p>Python’s dictionaries are indexed by keys that can be of any <a href="https://docs.python.org/3/glossary.html#term-hashable">hashable</a> type. A <strong>hashable</strong> object has a hash value that never changes during its lifetime (see <code>__hash__</code>), and it can be compared to other objects (see <code>__eq__</code>). Hashable objects that compare as equal must have the same hash value.</p>
<p><a href="https://realpython.com/courses/immutability-python/"><strong>Immutable</strong> types</a> like <a href="https://realpython.com/python-strings/">strings</a> and <a href="https://realpython.com/python-data-types/">numbers</a> are hashable and work well as dictionary keys. You can also use <a href="https://realpython.com/python-lists-tuples/#python-tuples"><code>tuple</code> objects</a> as dictionary keys as long as they contain only hashable types themselves.</p>
<p>For most use cases, Python’s built-in dictionary implementation will do everything you need. Dictionaries are highly optimized and underlie many parts of the language. For example, <a href="https://realpython.com/python-scope-legb-rule/#class-and-instance-attributes-scope">class attributes</a> and variables in a <a href="https://en.wikipedia.org/wiki/Call_stack#Structure">stack frame</a> are both stored internally in dictionaries.</p>
<p>Python dictionaries are based on a well-tested and finely tuned hash table implementation that provides the performance characteristics you’d expect: <em>O</em>(1) time complexity for lookup, insert, update, and delete operations in the average case.</p>
<p>There’s little reason not to use the standard <code>dict</code> implementation included with Python. However, specialized third-party dictionary implementations exist, such as <a href="https://en.wikipedia.org/wiki/Skip_list">skip lists</a> or <a href="https://en.wikipedia.org/wiki/B-tree">B-tree–based</a> dictionaries.</p>
<p>Besides plain <code>dict</code> objects, Python’s standard library also includes a number of specialized dictionary implementations. These specialized dictionaries are all based on the built-in dictionary class (and share its performance characteristics) but also include some additional convenience features.</p>
<p>Let’s take a look at them.</p>
<p>``</p>
<h4 id="section-1">``</h4>
<h4 id="collections.ordereddict-remember-the-insertion-order-of-keys"><code>collections.OrderedDict</code>: Remember the Insertion Order of Keys</h4>
<p>Python includes a specialized <code>dict</code> subclass that remembers the insertion order of keys added to it: <a href="https://realpython.com/python-ordereddict/"><code>collections.OrderedDict</code></a>.</p>
<p><strong>Note:</strong> <code>OrderedDict</code> is not a built-in part of the core language and must be imported from the <code>collections</code> module in the standard library.</p>
<p>While standard <code>dict</code> instances preserve the insertion order of keys in CPython 3.6 and above, this was simply a <a href="https://mail.python.org/pipermail/python-dev/2016-September/146327.html">side effect</a> of the CPython implementation and was not defined in the language spec until Python 3.7. So, if key order is important for your algorithm to work, then it’s best to communicate this clearly by explicitly using the <code>OrderedDict</code> class:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1"> <span class="im">import</span> collections</a>
<a class="sourceLine" id="cb3-2" title="2"></a>
<a class="sourceLine" id="cb3-3" title="3"> d <span class="op">=</span> collections.OrderedDict(one<span class="op">=</span><span class="dv">1</span>, two<span class="op">=</span><span class="dv">2</span>, three<span class="op">=</span><span class="dv">3</span>)</a>
<a class="sourceLine" id="cb3-4" title="4"></a>
<a class="sourceLine" id="cb3-5" title="5"></a>
<a class="sourceLine" id="cb3-6" title="6"> d</a>
<a class="sourceLine" id="cb3-7" title="7">OrderedDict([(<span class="st">&#39;one&#39;</span>, <span class="dv">1</span>), (<span class="st">&#39;two&#39;</span>, <span class="dv">2</span>), (<span class="st">&#39;three&#39;</span>, <span class="dv">3</span>)])</a>
<a class="sourceLine" id="cb3-8" title="8"></a>
<a class="sourceLine" id="cb3-9" title="9"></a>
<a class="sourceLine" id="cb3-10" title="10"> d[<span class="st">&quot;four&quot;</span>] <span class="op">=</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb3-11" title="11"></a>
<a class="sourceLine" id="cb3-12" title="12"> d</a>
<a class="sourceLine" id="cb3-13" title="13">OrderedDict([(<span class="st">&#39;one&#39;</span>, <span class="dv">1</span>), (<span class="st">&#39;two&#39;</span>, <span class="dv">2</span>),</a>
<a class="sourceLine" id="cb3-14" title="14"> (<span class="st">&#39;three&#39;</span>, <span class="dv">3</span>), (<span class="st">&#39;four&#39;</span>, <span class="dv">4</span>)])</a>
<a class="sourceLine" id="cb3-15" title="15"></a>
<a class="sourceLine" id="cb3-16" title="16"></a>
<a class="sourceLine" id="cb3-17" title="17"> d.keys()</a>
<a class="sourceLine" id="cb3-18" title="18">odict_keys([<span class="st">&#39;one&#39;</span>, <span class="st">&#39;two&#39;</span>, <span class="st">&#39;three&#39;</span>, <span class="st">&#39;four&#39;</span>])`</a>
<a class="sourceLine" id="cb3-19" title="19"></a>
<a class="sourceLine" id="cb3-20" title="20">Until [Python <span class="fl">3.8</span>](https:<span class="op">//</span>realpython.com<span class="op">/</span>python38<span class="op">-</span>new<span class="op">-</span>features<span class="op">/</span>), you couldn’t iterate over dictionary items <span class="kw">in</span> reverse order using `reversed()`. Only `OrderedDict` instances offered that functionality. Even <span class="kw">in</span> Python <span class="fl">3.8</span>, `dict` <span class="kw">and</span> `OrderedDict` objects aren’t exactly the same. `OrderedDict` instances have a [`.move_to_end()` method](https:<span class="op">//</span>realpython.com<span class="op">/</span>python<span class="op">-</span>data<span class="op">-</span>types<span class="op">/</span>) that <span class="kw">is</span> unavailable on plain `dict` instance, <span class="im">as</span> well <span class="im">as</span> a more customizable [`.popitem()` method](https:<span class="op">//</span>docs.python.org<span class="op">/</span><span class="dv">3</span><span class="op">/</span>library<span class="op">/</span>collections.html<span class="co">#collections.OrderedDict.popitem) than the one plain `dict` instances.</span></a></code></pre></div>
<h4 id="collections.defaultdict-return-default-values-for-missing-keys"><code>collections.defaultdict</code>: Return Default Values for Missing Keys</h4>
<p>The <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict"><code>defaultdict</code></a> class is another dictionary subclass that accepts a callable in its constructor whose return value will be used if a requested key cannot be found.</p>
<p>This can save you some typing and make your intentions clearer as compared to using <code>get()</code> or catching a <a href="https://realpython.com/python-keyerror/"><code>KeyError</code> exception</a> in regular dictionaries:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1"> <span class="im">from</span> collections <span class="im">import</span> defaultdict</a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"> dd <span class="op">=</span> defaultdict(<span class="bu">list</span>)</a>
<a class="sourceLine" id="cb4-4" title="4"></a>
<a class="sourceLine" id="cb4-5" title="5"></a>
<a class="sourceLine" id="cb4-6" title="6"> <span class="co"># Accessing a missing key creates it and</span></a>
<a class="sourceLine" id="cb4-7" title="7"></a>
<a class="sourceLine" id="cb4-8" title="8"> <span class="co"># initializes it using the default factory,</span></a>
<a class="sourceLine" id="cb4-9" title="9"></a>
<a class="sourceLine" id="cb4-10" title="10"> <span class="co"># i.e. list() in this example:</span></a>
<a class="sourceLine" id="cb4-11" title="11"></a>
<a class="sourceLine" id="cb4-12" title="12"> dd[<span class="st">&quot;dogs&quot;</span>].append(<span class="st">&quot;Rufus&quot;</span>)</a>
<a class="sourceLine" id="cb4-13" title="13"></a>
<a class="sourceLine" id="cb4-14" title="14"> dd[<span class="st">&quot;dogs&quot;</span>].append(<span class="st">&quot;Kathrin&quot;</span>)</a>
<a class="sourceLine" id="cb4-15" title="15"></a>
<a class="sourceLine" id="cb4-16" title="16"> dd[<span class="st">&quot;dogs&quot;</span>].append(<span class="st">&quot;Mr Sniffles&quot;</span>)</a>
<a class="sourceLine" id="cb4-17" title="17"></a>
<a class="sourceLine" id="cb4-18" title="18"></a>
<a class="sourceLine" id="cb4-19" title="19"> dd[<span class="st">&quot;dogs&quot;</span>]</a>
<a class="sourceLine" id="cb4-20" title="20">[<span class="st">&#39;Rufus&#39;</span>, <span class="st">&#39;Kathrin&#39;</span>, <span class="st">&#39;Mr Sniffles&#39;</span>]`</a></code></pre></div>
<h4 id="collections.chainmap-search-multiple-dictionaries-as-a-single-mapping"><code>collections.ChainMap</code>: Search Multiple Dictionaries as a Single Mapping</h4>
<p>The <a href="https://docs.python.org/3/library/collections.html#collections.ChainMap"><code>collections.ChainMap</code></a> data structure groups multiple dictionaries into a single mapping. Lookups search the underlying mappings one by one until a key is found. Insertions, updates, and deletions only affect the first mapping added to the chain:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" title="1"> <span class="im">from</span> collections <span class="im">import</span> ChainMap</a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"> dict1 <span class="op">=</span> {<span class="st">&quot;one&quot;</span>: <span class="dv">1</span>, <span class="st">&quot;two&quot;</span>: <span class="dv">2</span>}</a>
<a class="sourceLine" id="cb5-4" title="4"></a>
<a class="sourceLine" id="cb5-5" title="5"> dict2 <span class="op">=</span> {<span class="st">&quot;three&quot;</span>: <span class="dv">3</span>, <span class="st">&quot;four&quot;</span>: <span class="dv">4</span>}</a>
<a class="sourceLine" id="cb5-6" title="6"></a>
<a class="sourceLine" id="cb5-7" title="7"> chain <span class="op">=</span> ChainMap(dict1, dict2)</a>
<a class="sourceLine" id="cb5-8" title="8"></a>
<a class="sourceLine" id="cb5-9" title="9"></a>
<a class="sourceLine" id="cb5-10" title="10"> chain</a>
<a class="sourceLine" id="cb5-11" title="11">ChainMap({<span class="st">&#39;one&#39;</span>: <span class="dv">1</span>, <span class="st">&#39;two&#39;</span>: <span class="dv">2</span>}, {<span class="st">&#39;three&#39;</span>: <span class="dv">3</span>, <span class="st">&#39;four&#39;</span>: <span class="dv">4</span>})</a>
<a class="sourceLine" id="cb5-12" title="12"></a>
<a class="sourceLine" id="cb5-13" title="13"></a>
<a class="sourceLine" id="cb5-14" title="14"> <span class="co"># ChainMap searches each collection in the chain</span></a>
<a class="sourceLine" id="cb5-15" title="15"></a>
<a class="sourceLine" id="cb5-16" title="16"> <span class="co"># from left to right until it finds the key (or fails):</span></a>
<a class="sourceLine" id="cb5-17" title="17"></a>
<a class="sourceLine" id="cb5-18" title="18"> chain[<span class="st">&quot;three&quot;</span>]</a>
<a class="sourceLine" id="cb5-19" title="19"><span class="dv">3</span></a>
<a class="sourceLine" id="cb5-20" title="20"></a>
<a class="sourceLine" id="cb5-21" title="21"> chain[<span class="st">&quot;one&quot;</span>]</a>
<a class="sourceLine" id="cb5-22" title="22"><span class="dv">1</span></a>
<a class="sourceLine" id="cb5-23" title="23"></a>
<a class="sourceLine" id="cb5-24" title="24"> chain[<span class="st">&quot;missing&quot;</span>]</a>
<a class="sourceLine" id="cb5-25" title="25">Traceback (most recent call last):</a>
<a class="sourceLine" id="cb5-26" title="26">  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb5-27" title="27"><span class="pp">KeyError</span>: <span class="st">&#39;missing&#39;</span>`</a></code></pre></div>
<h4 id="types.mappingproxytype-a-wrapper-for-making-read-only-dictionaries"><code>types.MappingProxyType</code>: A Wrapper for Making Read-Only Dictionaries</h4>
<p><a href="https://docs.python.org/3/library/types.html#types.MappingProxyType"><code>MappingProxyType</code></a> is a wrapper around a standard dictionary that provides a read-only view into the wrapped dictionary’s data. This class was added in Python 3.3 and can be used to create immutable proxy versions of dictionaries.</p>
<p>``<code>pyMappingProxyType</code> can be helpful if, for example, you’d like to return a dictionary carrying internal state from a class or module while discouraging write access to this object. Using <code>MappingProxyType</code> allows you to put these restrictions in place without first having to create a full copy of the dictionary:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" title="1"> <span class="im">from</span> types <span class="im">import</span> MappingProxyType</a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3"> writable <span class="op">=</span> {<span class="st">&quot;one&quot;</span>: <span class="dv">1</span>, <span class="st">&quot;two&quot;</span>: <span class="dv">2</span>}</a>
<a class="sourceLine" id="cb6-4" title="4"></a>
<a class="sourceLine" id="cb6-5" title="5"> read_only <span class="op">=</span> MappingProxyType(writable)</a>
<a class="sourceLine" id="cb6-6" title="6"></a>
<a class="sourceLine" id="cb6-7" title="7"></a>
<a class="sourceLine" id="cb6-8" title="8"> <span class="co"># The proxy is read-only:</span></a>
<a class="sourceLine" id="cb6-9" title="9"></a>
<a class="sourceLine" id="cb6-10" title="10"> read_only[<span class="st">&quot;one&quot;</span>]</a>
<a class="sourceLine" id="cb6-11" title="11"><span class="dv">1</span></a>
<a class="sourceLine" id="cb6-12" title="12"></a>
<a class="sourceLine" id="cb6-13" title="13"> read_only[<span class="st">&quot;one&quot;</span>] <span class="op">=</span> <span class="dv">23</span></a>
<a class="sourceLine" id="cb6-14" title="14">Traceback (most recent call last):</a>
<a class="sourceLine" id="cb6-15" title="15">  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb6-16" title="16"><span class="pp">TypeError</span>: <span class="st">&#39;mappingproxy&#39;</span> <span class="bu">object</span> does <span class="kw">not</span> support item assignment</a>
<a class="sourceLine" id="cb6-17" title="17"></a>
<a class="sourceLine" id="cb6-18" title="18"></a>
<a class="sourceLine" id="cb6-19" title="19"> <span class="co"># Updates to the original are reflected in the proxy:</span></a>
<a class="sourceLine" id="cb6-20" title="20"></a>
<a class="sourceLine" id="cb6-21" title="21"> writable[<span class="st">&quot;one&quot;</span>] <span class="op">=</span> <span class="dv">42</span></a>
<a class="sourceLine" id="cb6-22" title="22"></a>
<a class="sourceLine" id="cb6-23" title="23"> read_only</a>
<a class="sourceLine" id="cb6-24" title="24">mappingproxy({<span class="st">&#39;one&#39;</span>: <span class="dv">42</span>, <span class="st">&#39;two&#39;</span>: <span class="dv">2</span>})`</a></code></pre></div>
<h4 id="dictionaries-in-python-summary">Dictionaries in Python: Summary</h4>
<p>All the Python dictionary implementations listed in this tutorial are valid implementations that are built into the Python standard library.</p>
<p>If you’re looking for a general recommendation on which mapping type to use in your programs, I’d point you to the built-in <code>dict</code> data type. It’s a versatile and optimized hash table implementation that’s built directly into the core language.</p>
<p>I would recommend that you use one of the other data types listed here only if you have special requirements that go beyond what’s provided by <code>dict</code>.</p>
<p>All the implementations are valid options, but your code will be clearer and easier to maintain if it relies on standard Python dictionaries most of the time.</p>
<h3 id="array-data-structures">Array Data Structures</h3>
<p>An <strong>array</strong> is a fundamental data structure available in most programming languages, and it has a wide range of uses across different algorithms.</p>
<p>In this section, you’ll take a look at array implementations in Python that use only core language features or functionality that’s included in the Python standard library. You’ll see the strengths and weaknesses of each approach so you can decide which implementation is right for your use case.</p>
<p>But before we jump in, let’s cover some of the basics first. How do arrays work, and what are they used for? Arrays consist of fixed-size data records that allow each element to be efficiently located based on its index:</p>
<p><a href="https://files.realpython.com/media/python-linked-list-array-visualization.5b9f4c4040cb.jpeg"><img src="https://files.realpython.com/media/python-linked-list-array-visualization.5b9f4c4040cb.jpeg" alt="Visual representation of an array" /></a></p>
<p>Because arrays store information in adjoining blocks of memory, they’re considered <strong>contiguous</strong> data structures (as opposed to <strong>linked</strong> data structures like linked lists, for example).</p>
<p>A real-world analogy for an array data structure is a parking lot. You can look at the parking lot as a whole and treat it as a single object, but inside the lot there are parking spots indexed by a unique number. Parking spots are containers for vehicles—each parking spot can either be empty or have a car, a motorbike, or some other vehicle parked on it.</p>
<p>But not all parking lots are the same. Some parking lots may be restricted to only one type of vehicle. For example, a motor home parking lot wouldn’t allow bikes to be parked on it. A restricted parking lot corresponds to a <strong>typed</strong> array data structure that allows only elements that have the same data type stored in them.</p>
<p>Performance-wise, it’s very fast to look up an element contained in an array given the element’s index. A proper array implementation guarantees a constant <em>O</em>(1) access time for this case.</p>
<p>Python includes several array-like data structures in its standard library that each have slightly different characteristics. Let’s take a look.</p>
<h3 id="list-mutable-dynamic-arrays"><code>list</code>: Mutable Dynamic Arrays</h3>
<p><a href="https://docs.python.org/3.6/library/stdtypes.html#lists">Lists</a> are a part of the core Python language. Despite their name, Python’s lists are implemented as <strong>dynamic arrays</strong> behind the scenes.</p>
<p>This means a list allows elements to be added or removed, and the list will automatically adjust the backing store that holds these elements by allocating or releasing memory.</p>
<p>Python lists can hold arbitrary elements—everything is an object in Python, including functions. Therefore, you can mix and match different kinds of data types and store them all in a single list.</p>
<p>This can be a powerful feature, but the downside is that supporting multiple data types at the same time means that data is generally less tightly packed. As a result, the whole structure takes up more space:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" title="1"></a>
<a class="sourceLine" id="cb7-2" title="2"></a>
<a class="sourceLine" id="cb7-3" title="3"> arr <span class="op">=</span> [<span class="st">&quot;one&quot;</span>, <span class="st">&quot;two&quot;</span>, <span class="st">&quot;three&quot;</span>]</a>
<a class="sourceLine" id="cb7-4" title="4"></a>
<a class="sourceLine" id="cb7-5" title="5"> arr[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb7-6" title="6"><span class="co">&#39;one&#39;</span></a>
<a class="sourceLine" id="cb7-7" title="7"></a>
<a class="sourceLine" id="cb7-8" title="8"></a>
<a class="sourceLine" id="cb7-9" title="9"> <span class="co"># Lists have a nice repr:</span></a>
<a class="sourceLine" id="cb7-10" title="10"></a>
<a class="sourceLine" id="cb7-11" title="11"> arr</a>
<a class="sourceLine" id="cb7-12" title="12">[<span class="st">&#39;one&#39;</span>, <span class="st">&#39;two&#39;</span>, <span class="st">&#39;three&#39;</span>]</a>
<a class="sourceLine" id="cb7-13" title="13"></a>
<a class="sourceLine" id="cb7-14" title="14"></a>
<a class="sourceLine" id="cb7-15" title="15"> <span class="co"># Lists are mutable:</span></a>
<a class="sourceLine" id="cb7-16" title="16"></a>
<a class="sourceLine" id="cb7-17" title="17"> arr[<span class="dv">1</span>] <span class="op">=</span> <span class="st">&quot;hello&quot;</span></a>
<a class="sourceLine" id="cb7-18" title="18"></a>
<a class="sourceLine" id="cb7-19" title="19"> arr</a>
<a class="sourceLine" id="cb7-20" title="20">[<span class="st">&#39;one&#39;</span>, <span class="st">&#39;hello&#39;</span>, <span class="st">&#39;three&#39;</span>]</a>
<a class="sourceLine" id="cb7-21" title="21"></a>
<a class="sourceLine" id="cb7-22" title="22"></a>
<a class="sourceLine" id="cb7-23" title="23"> <span class="kw">del</span> arr[<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb7-24" title="24"></a>
<a class="sourceLine" id="cb7-25" title="25"> arr</a>
<a class="sourceLine" id="cb7-26" title="26">[<span class="st">&#39;one&#39;</span>, <span class="st">&#39;three&#39;</span>]</a>
<a class="sourceLine" id="cb7-27" title="27"></a>
<a class="sourceLine" id="cb7-28" title="28"></a>
<a class="sourceLine" id="cb7-29" title="29"> <span class="co"># Lists can hold arbitrary data types:</span></a>
<a class="sourceLine" id="cb7-30" title="30"></a>
<a class="sourceLine" id="cb7-31" title="31"> arr.append(<span class="dv">23</span>)</a>
<a class="sourceLine" id="cb7-32" title="32"></a>
<a class="sourceLine" id="cb7-33" title="33"> arr</a>
<a class="sourceLine" id="cb7-34" title="34">[<span class="st">&#39;one&#39;</span>, <span class="st">&#39;three&#39;</span>, <span class="dv">23</span>]`</a></code></pre></div>
<h4 id="tuple-immutable-containers"><code>tuple</code>: Immutable Containers</h4>
<p>Just like lists, <a href="https://docs.python.org/3/library/stdtypes.html#tuple">tuples</a> are part of the Python core language. Unlike lists, however, Python’s <code>tuple</code> objects are immutable. This means elements can’t be added or removed dynamically—all elements in a tuple must be defined at creation time.</p>
<p>Tuples are another data structure that can hold elements of arbitrary data types. Having this flexibility is powerful, but again, it also means that data is less tightly packed than it would be in a typed array:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb8-1" title="1"> arr <span class="op">=</span> (<span class="st">&quot;one&quot;</span>, <span class="st">&quot;two&quot;</span>, <span class="st">&quot;three&quot;</span>)</a>
<a class="sourceLine" id="cb8-2" title="2"></a>
<a class="sourceLine" id="cb8-3" title="3"> arr[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb8-4" title="4"><span class="co">&#39;one&#39;</span></a>
<a class="sourceLine" id="cb8-5" title="5"></a>
<a class="sourceLine" id="cb8-6" title="6"></a>
<a class="sourceLine" id="cb8-7" title="7"> <span class="co"># Tuples have a nice repr:</span></a>
<a class="sourceLine" id="cb8-8" title="8"></a>
<a class="sourceLine" id="cb8-9" title="9"> arr</a>
<a class="sourceLine" id="cb8-10" title="10">(<span class="st">&#39;one&#39;</span>, <span class="st">&#39;two&#39;</span>, <span class="st">&#39;three&#39;</span>)</a>
<a class="sourceLine" id="cb8-11" title="11"></a>
<a class="sourceLine" id="cb8-12" title="12"></a>
<a class="sourceLine" id="cb8-13" title="13"> <span class="co"># Tuples are immutable:</span></a>
<a class="sourceLine" id="cb8-14" title="14"></a>
<a class="sourceLine" id="cb8-15" title="15"> arr[<span class="dv">1</span>] <span class="op">=</span> <span class="st">&quot;hello&quot;</span></a>
<a class="sourceLine" id="cb8-16" title="16">Traceback (most recent call last):</a>
<a class="sourceLine" id="cb8-17" title="17">  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb8-18" title="18"><span class="pp">TypeError</span>: <span class="st">&#39;tuple&#39;</span> <span class="bu">object</span> does <span class="kw">not</span> support item assignment</a>
<a class="sourceLine" id="cb8-19" title="19"></a>
<a class="sourceLine" id="cb8-20" title="20"></a>
<a class="sourceLine" id="cb8-21" title="21"> <span class="kw">del</span> arr[<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb8-22" title="22">Traceback (most recent call last):</a>
<a class="sourceLine" id="cb8-23" title="23">  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb8-24" title="24"><span class="pp">TypeError</span>: <span class="st">&#39;tuple&#39;</span> <span class="bu">object</span> doesn<span class="st">&#39;t support item deletion</span></a>
<a class="sourceLine" id="cb8-25" title="25"></a>
<a class="sourceLine" id="cb8-26" title="26"></a>
<a class="sourceLine" id="cb8-27" title="27"><span class="st"> # Tuples can hold arbitrary data types:</span></a>
<a class="sourceLine" id="cb8-28" title="28"></a>
<a class="sourceLine" id="cb8-29" title="29"><span class="st"> # (Adding elements creates a copy of the tuple)</span></a>
<a class="sourceLine" id="cb8-30" title="30"></a>
<a class="sourceLine" id="cb8-31" title="31"><span class="st"> arr + (23,)</span></a>
<a class="sourceLine" id="cb8-32" title="32"><span class="st">(&#39;</span>one<span class="st">&#39;, &#39;</span>two<span class="st">&#39;, &#39;</span>three<span class="st">&#39;, 23)`</span></a></code></pre></div>
<pre><code>
#### `array.array`: Basic Typed Arrays

Python’s `array` module provides space-efficient storage of basic C-style data types like bytes, 32-bit integers, floating-point numbers, and so on.

Arrays created with the [`array.array`](https://docs.python.org/3/library/array.html) class are mutable and behave similarly to lists except for one important difference: they’re **typed arrays** constrained to a single data type.

Because of this constraint, `array.array` objects with many elements are more space efficient than lists and tuples. The elements stored in them are tightly packed, and this can be useful if you need to store many elements of the same type.

Also, arrays support many of the same methods as regular lists, and you might be able to use them as a drop-in replacement without requiring other changes to your application code.

```python
 import array

 arr = array.array(&quot;f&quot;, (1.0, 1.5, 2.0, 2.5))

 arr[1]
1.5


 # Arrays have a nice repr:

 arr
array(&#39;f&#39;, [1.0, 1.5, 2.0, 2.5])


 # Arrays are mutable:

 arr[1] = 23.0

 arr
array(&#39;f&#39;, [1.0, 23.0, 2.0, 2.5])


 del arr[1]

 arr
array(&#39;f&#39;, [1.0, 2.0, 2.5])


 arr.append(42.0)

 arr
array(&#39;f&#39;, [1.0, 2.0, 2.5, 42.0])


 # Arrays are &quot;typed&quot;:

 arr[1] = &quot;hello&quot;
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: must be real number, not str`</code></pre>
<pre><code>
#### `str`: Immutable Arrays of Unicode Characters

Python 3.x uses [`str`](https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str) objects to store textual data as immutable sequences of [Unicode characters](https://realpython.com/python-encodings-guide/). Practically speaking, that means a `str` is an immutable array of characters. Oddly enough, it’s also a [recursive](https://realpython.com/python-thinking-recursively/) data structure—each character in a string is itself a `str` object of length 1.

String objects are space efficient because they’re tightly packed and they specialize in a single data type. If you’re storing Unicode text, then you should use a string.

Because strings are immutable in Python, modifying a string requires creating a modified copy. The closest equivalent to a mutable string is storing individual characters inside a list:

```python
 arr = &quot;abcd&quot;

 arr[1]
&#39;b&#39;


 arr
&#39;abcd&#39;


 # Strings are immutable:

 arr[1] = &quot;e&quot;
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: &#39;str&#39; object does not support item assignment


 del arr[1]
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: &#39;str&#39; object doesn&#39;t support item deletion


 # Strings can be unpacked into a list to

 # get a mutable representation:

 list(&quot;abcd&quot;)
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]

 &quot;&quot;.join(list(&quot;abcd&quot;))
&#39;abcd&#39;


 # Strings are recursive data structures:

 type(&quot;abc&quot;)
&quot;&lt;class &#39;str&#39;&gt;&quot;

 type(&quot;abc&quot;[0])
&quot;&lt;class &#39;str&#39;&gt;&quot;`</code></pre>
<pre><code>
#### `bytes`: Immutable Arrays of Single Bytes

[`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes-objects) objects are immutable sequences of single bytes, or integers in the range 0 ≤ _x_ ≤ 255. Conceptually, `bytes` objects are similar to `str` objects, and you can also think of them as immutable arrays of bytes.

Like strings, `bytes` have their own literal syntax for creating objects and are space efficient. `bytes` objects are immutable, but unlike strings, there’s a dedicated mutable byte array data type called `bytearray` that they can be unpacked into:

```python
 arr = bytes((0, 1, 2, 3))

 arr[1]
1


 # Bytes literals have their own syntax:

 arr
b&#39;\x00\x01\x02\x03&#39;

 arr = b&quot;\x00\x01\x02\x03&quot;


 # Only valid `bytes` are allowed:

 bytes((0, 300))
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ValueError: bytes must be in range(0, 256)


 # Bytes are immutable:

 arr[1] = 23
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: &#39;bytes&#39; object does not support item assignment


 del arr[1]
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: &#39;bytes&#39; object doesn&#39;t support item deletion``</code></pre>
<h4 id="bytearray-mutable-arrays-of-single-bytes"><code>bytearray</code>: Mutable Arrays of Single Bytes</h4>
<p>The <a href="https://docs.python.org/3.1/library/functions.html#bytearray"><code>bytearray</code></a> type is a mutable sequence of integers in the range 0 ≤ <em>x</em> ≤ 255. The <code>bytearray</code> object is closely related to the <code>bytes</code> object, with the main difference being that a <code>bytearray</code> can be modified freely—you can overwrite elements, remove existing elements, or add new ones. The <code>bytearray</code> object will grow and shrink accordingly.</p>
<p>A <code>bytearray</code> can be converted back into immutable <code>bytes</code> objects, but this involves copying the stored data in full—a slow operation taking <em>O</em>(<em>n</em>) time:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb12-1" title="1"> arr <span class="op">=</span> <span class="bu">bytearray</span>((<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>))</a>
<a class="sourceLine" id="cb12-2" title="2"></a>
<a class="sourceLine" id="cb12-3" title="3"> arr[<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb12-4" title="4"><span class="dv">1</span></a>
<a class="sourceLine" id="cb12-5" title="5"></a>
<a class="sourceLine" id="cb12-6" title="6"></a>
<a class="sourceLine" id="cb12-7" title="7"> <span class="co"># The bytearray repr:</span></a>
<a class="sourceLine" id="cb12-8" title="8"></a>
<a class="sourceLine" id="cb12-9" title="9"> arr</a>
<a class="sourceLine" id="cb12-10" title="10"><span class="bu">bytearray</span>(b<span class="st">&#39;</span><span class="ch">\x00\x01\x02\x03</span><span class="st">&#39;</span>)</a>
<a class="sourceLine" id="cb12-11" title="11"></a>
<a class="sourceLine" id="cb12-12" title="12"></a>
<a class="sourceLine" id="cb12-13" title="13"> <span class="co"># Bytearrays are mutable:</span></a>
<a class="sourceLine" id="cb12-14" title="14"></a>
<a class="sourceLine" id="cb12-15" title="15"> arr[<span class="dv">1</span>] <span class="op">=</span> <span class="dv">23</span></a>
<a class="sourceLine" id="cb12-16" title="16"></a>
<a class="sourceLine" id="cb12-17" title="17"> arr</a>
<a class="sourceLine" id="cb12-18" title="18"><span class="bu">bytearray</span>(b<span class="st">&#39;</span><span class="ch">\x00\x17\x02\x03</span><span class="st">&#39;</span>)</a>
<a class="sourceLine" id="cb12-19" title="19"></a>
<a class="sourceLine" id="cb12-20" title="20"></a>
<a class="sourceLine" id="cb12-21" title="21"> arr[<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb12-22" title="22"><span class="dv">23</span></a>
<a class="sourceLine" id="cb12-23" title="23"></a>
<a class="sourceLine" id="cb12-24" title="24"></a>
<a class="sourceLine" id="cb12-25" title="25"> <span class="co"># Bytearrays can grow and shrink in size:</span></a>
<a class="sourceLine" id="cb12-26" title="26"></a>
<a class="sourceLine" id="cb12-27" title="27"> <span class="kw">del</span> arr[<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb12-28" title="28"></a>
<a class="sourceLine" id="cb12-29" title="29"> arr</a>
<a class="sourceLine" id="cb12-30" title="30"><span class="bu">bytearray</span>(b<span class="st">&#39;</span><span class="ch">\x00\x02\x03</span><span class="st">&#39;</span>)</a>
<a class="sourceLine" id="cb12-31" title="31"></a>
<a class="sourceLine" id="cb12-32" title="32"></a>
<a class="sourceLine" id="cb12-33" title="33"> arr.append(<span class="dv">42</span>)</a>
<a class="sourceLine" id="cb12-34" title="34"></a>
<a class="sourceLine" id="cb12-35" title="35"> arr</a>
<a class="sourceLine" id="cb12-36" title="36"><span class="bu">bytearray</span>(b<span class="st">&#39;</span><span class="ch">\x00\x02\x03</span><span class="st">*&#39;</span>)</a>
<a class="sourceLine" id="cb12-37" title="37"></a>
<a class="sourceLine" id="cb12-38" title="38"></a>
<a class="sourceLine" id="cb12-39" title="39"> <span class="co"># Bytearrays can only hold `bytes`</span></a>
<a class="sourceLine" id="cb12-40" title="40"></a>
<a class="sourceLine" id="cb12-41" title="41"> <span class="co"># (integers in the range 0 &lt;= x &lt;= 255)</span></a>
<a class="sourceLine" id="cb12-42" title="42"></a>
<a class="sourceLine" id="cb12-43" title="43"> arr[<span class="dv">1</span>] <span class="op">=</span> <span class="st">&quot;hello&quot;</span></a>
<a class="sourceLine" id="cb12-44" title="44">Traceback (most recent call last):</a>
<a class="sourceLine" id="cb12-45" title="45">  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb12-46" title="46"><span class="pp">TypeError</span>: <span class="st">&#39;str&#39;</span> <span class="bu">object</span> cannot be interpreted <span class="im">as</span> an integer</a>
<a class="sourceLine" id="cb12-47" title="47"></a>
<a class="sourceLine" id="cb12-48" title="48"></a>
<a class="sourceLine" id="cb12-49" title="49"> arr[<span class="dv">1</span>] <span class="op">=</span> <span class="dv">300</span></a>
<a class="sourceLine" id="cb12-50" title="50">Traceback (most recent call last):</a>
<a class="sourceLine" id="cb12-51" title="51">  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb12-52" title="52"><span class="pp">ValueError</span>: byte must be <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">256</span>)</a>
<a class="sourceLine" id="cb12-53" title="53"></a>
<a class="sourceLine" id="cb12-54" title="54"></a>
<a class="sourceLine" id="cb12-55" title="55"> <span class="co"># Bytearrays can be converted back into bytes objects:</span></a>
<a class="sourceLine" id="cb12-56" title="56"></a>
<a class="sourceLine" id="cb12-57" title="57"> <span class="co"># (This will copy the data)</span></a>
<a class="sourceLine" id="cb12-58" title="58"></a>
<a class="sourceLine" id="cb12-59" title="59"> <span class="bu">bytes</span>(arr)</a>
<a class="sourceLine" id="cb12-60" title="60">b<span class="st">&#39;</span><span class="ch">\x00\x02\x03</span><span class="st">*&#39;</span>``</a></code></pre></div>
<h4 id="arrays-in-python-summary">Arrays in Python: Summary</h4>
<p>There are a number of built-in data structures you can choose from when it comes to implementing arrays in Python. In this section, you’ve focused on core language features and data structures included in the standard library.</p>
<p>If you’re willing to go beyond the Python standard library, then third-party packages like <a href="https://realpython.com/numpy-array-programming/">NumPy</a> and <a href="https://realpython.com/pandas-dataframe/">pandas</a> offer a wide range of fast array implementations for scientific computing and data science.</p>
<p>If you want to restrict yourself to the array data structures included with Python, then here are a few guidelines:</p>
<ul>
<li>If you need to store arbitrary objects, potentially with mixed data types, then use a <code>list</code> or a <code>tuple</code>, depending on whether or not you want an immutable data structure.</li>
<li>If you have numeric (integer or floating-point) data and tight packing and performance is important, then try out <code>array.array</code>.</li>
<li>If you have textual data represented as Unicode characters, then use Python’s built-in <code>str</code>. If you need a mutable string-like data structure, then use a <code>list</code> of characters.</li>
<li>If you want to store a contiguous block of bytes, then use the immutable <code>bytes</code> type or a <code>bytearray</code> if you need a mutable data structure.</li>
</ul>
<p>In most cases, I like to start out with a simple <code>list</code>. I’ll only specialize later on if performance or storage space becomes an issue. Most of the time, using a general-purpose array data structure like <code>list</code> gives you the fastest development speed and the most programming convenience.</p>
<p>I’ve found that this is usually much more important in the beginning than trying to squeeze out every last drop of performance right from the start.</p>
<h3 id="records-structs-and-data-transfer-objects">Records, Structs, and Data Transfer Objects</h3>
<p>Compared to arrays, <strong>record</strong> data structures provide a fixed number of fields. Each field can have a name and may also have a different type.</p>
<p>In this section, you’ll see how to implement records, structs, and plain old data objects in Python using only built-in data types and classes from the standard library.</p>
<p><strong>Note:</strong> I’m using the definition of a record loosely here. For example, I’m also going to discuss types like Python’s built-in <code>tuple</code> that may or may not be considered records in a strict sense because they don’t provide named fields.</p>
<p>Python offers several data types that you can use to implement records, structs, and data transfer objects. In this section, you’ll get a quick look at each implementation and its unique characteristics. At the end, you’ll find a summary and a decision-making guide that will help you make your own picks.</p>
<p><strong>Note:</strong> This tutorial is adapted from the chapter “Common Data Structures in Python” in <a href="https://realpython.com/products/python-tricks-book/"><em>Python Tricks: The Book</em></a>. If you enjoy what you’re reading, then be sure to check out <a href="https://realpython.com/products/python-tricks-book/">the rest of the book</a>.</p>
<p>Alright, let’s get started!</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb13-1" title="1"><span class="co">### `dict`: Simple Data Objects[](https://realpython.com/python-data-structures/#dict-simple-data-objects &quot;Permanent link&quot;)</span></a>
<a class="sourceLine" id="cb13-2" title="2"></a>
<a class="sourceLine" id="cb13-3" title="3">As mentioned [previously](https:<span class="op">//</span>realpython.com<span class="op">/</span>python<span class="op">-</span>data<span class="op">-</span>structures<span class="op">/</span><span class="co">#dictionaries-maps-and-hash-tables), Python dictionaries store an arbitrary number of objects, each identified by a unique key. Dictionaries are also often called **maps** or **associative arrays** and allow for efficient lookup, insertion, and deletion of any object associated with a given key.</span></a>
<a class="sourceLine" id="cb13-4" title="4"></a>
<a class="sourceLine" id="cb13-5" title="5">Using dictionaries <span class="im">as</span> a record data <span class="bu">type</span> <span class="kw">or</span> data <span class="bu">object</span> <span class="kw">in</span> Python <span class="kw">is</span> possible. Dictionaries are easy to create <span class="kw">in</span> Python <span class="im">as</span> they have their own syntactic sugar built into the language <span class="kw">in</span> the form of <span class="op">**</span>dictionary literals<span class="op">**</span>. The dictionary syntax <span class="kw">is</span> concise <span class="kw">and</span> quite convenient to <span class="bu">type</span>.</a>
<a class="sourceLine" id="cb13-6" title="6"></a>
<a class="sourceLine" id="cb13-7" title="7">Data objects created using dictionaries are mutable, <span class="kw">and</span> there’s little protection against misspelled field names <span class="im">as</span> fields can be added <span class="kw">and</span> removed freely at <span class="bu">any</span> time. Both of these properties can introduce surprising bugs, <span class="kw">and</span> there’s always a trade<span class="op">-</span>off to be made between convenience <span class="kw">and</span> error resilience:</a>
<a class="sourceLine" id="cb13-8" title="8"></a>
<a class="sourceLine" id="cb13-9" title="9"></a>
<a class="sourceLine" id="cb13-10" title="10"></a>
<a class="sourceLine" id="cb13-11" title="11"></a>
<a class="sourceLine" id="cb13-12" title="12">```py</a>
<a class="sourceLine" id="cb13-13" title="13"> car1 <span class="op">=</span> {</a>
<a class="sourceLine" id="cb13-14" title="14">     <span class="st">&quot;color&quot;</span>: <span class="st">&quot;red&quot;</span>,</a>
<a class="sourceLine" id="cb13-15" title="15">     <span class="st">&quot;mileage&quot;</span>: <span class="fl">3812.4</span>,</a>
<a class="sourceLine" id="cb13-16" title="16">     <span class="st">&quot;automatic&quot;</span>: <span class="va">True</span>,</a>
<a class="sourceLine" id="cb13-17" title="17"> }</a>
<a class="sourceLine" id="cb13-18" title="18"></a>
<a class="sourceLine" id="cb13-19" title="19"> car2 <span class="op">=</span> {</a>
<a class="sourceLine" id="cb13-20" title="20">     <span class="st">&quot;color&quot;</span>: <span class="st">&quot;blue&quot;</span>,</a>
<a class="sourceLine" id="cb13-21" title="21">     <span class="st">&quot;mileage&quot;</span>: <span class="dv">40231</span>,</a>
<a class="sourceLine" id="cb13-22" title="22">     <span class="st">&quot;automatic&quot;</span>: <span class="va">False</span>,</a>
<a class="sourceLine" id="cb13-23" title="23"> }</a>
<a class="sourceLine" id="cb13-24" title="24"></a>
<a class="sourceLine" id="cb13-25" title="25"></a>
<a class="sourceLine" id="cb13-26" title="26"> <span class="co"># Dicts have a nice repr:</span></a>
<a class="sourceLine" id="cb13-27" title="27"></a>
<a class="sourceLine" id="cb13-28" title="28"> car2</a>
<a class="sourceLine" id="cb13-29" title="29">{<span class="st">&#39;color&#39;</span>: <span class="st">&#39;blue&#39;</span>, <span class="st">&#39;automatic&#39;</span>: <span class="va">False</span>, <span class="st">&#39;mileage&#39;</span>: <span class="dv">40231</span>}</a>
<a class="sourceLine" id="cb13-30" title="30"></a>
<a class="sourceLine" id="cb13-31" title="31"></a>
<a class="sourceLine" id="cb13-32" title="32"> <span class="co"># Get mileage:</span></a>
<a class="sourceLine" id="cb13-33" title="33"></a>
<a class="sourceLine" id="cb13-34" title="34"> car2[<span class="st">&quot;mileage&quot;</span>]</a>
<a class="sourceLine" id="cb13-35" title="35"><span class="dv">40231</span></a>
<a class="sourceLine" id="cb13-36" title="36"></a>
<a class="sourceLine" id="cb13-37" title="37"></a>
<a class="sourceLine" id="cb13-38" title="38"> <span class="co"># Dicts are mutable:</span></a>
<a class="sourceLine" id="cb13-39" title="39"></a>
<a class="sourceLine" id="cb13-40" title="40"> car2[<span class="st">&quot;mileage&quot;</span>] <span class="op">=</span> <span class="dv">12</span></a>
<a class="sourceLine" id="cb13-41" title="41"></a>
<a class="sourceLine" id="cb13-42" title="42"> car2[<span class="st">&quot;windshield&quot;</span>] <span class="op">=</span> <span class="st">&quot;broken&quot;</span></a>
<a class="sourceLine" id="cb13-43" title="43"></a>
<a class="sourceLine" id="cb13-44" title="44"> car2</a>
<a class="sourceLine" id="cb13-45" title="45">{<span class="st">&#39;windshield&#39;</span>: <span class="st">&#39;broken&#39;</span>, <span class="st">&#39;color&#39;</span>: <span class="st">&#39;blue&#39;</span>,</a>
<a class="sourceLine" id="cb13-46" title="46"> <span class="st">&#39;automatic&#39;</span>: <span class="va">False</span>, <span class="st">&#39;mileage&#39;</span>: <span class="dv">12</span>}</a>
<a class="sourceLine" id="cb13-47" title="47"></a>
<a class="sourceLine" id="cb13-48" title="48"></a>
<a class="sourceLine" id="cb13-49" title="49"> <span class="co"># No protection against wrong field names,</span></a>
<a class="sourceLine" id="cb13-50" title="50"></a>
<a class="sourceLine" id="cb13-51" title="51"> <span class="co"># or missing/extra fields:</span></a>
<a class="sourceLine" id="cb13-52" title="52"></a>
<a class="sourceLine" id="cb13-53" title="53"> car3 <span class="op">=</span> {</a>
<a class="sourceLine" id="cb13-54" title="54">     <span class="st">&quot;colr&quot;</span>: <span class="st">&quot;green&quot;</span>,</a>
<a class="sourceLine" id="cb13-55" title="55">     <span class="st">&quot;automatic&quot;</span>: <span class="va">False</span>,</a>
<a class="sourceLine" id="cb13-56" title="56">     <span class="st">&quot;windshield&quot;</span>: <span class="st">&quot;broken&quot;</span>,</a>
<a class="sourceLine" id="cb13-57" title="57"> }`</a></code></pre></div>
<h4 id="tuple-immutable-groups-of-objects"><code>tuple</code>: Immutable Groups of Objects</h4>
<p>Python’s tuples are a straightforward data structure for grouping arbitrary objects. Tuples are immutable—they can’t be modified once they’ve been created.</p>
<p>Performance-wise, tuples take up <a href="https://github.com/python/cpython/blob/1a5856bf9295fa73995898d576e0bedf016aee1f/Include/tupleobject.h#L10-L34">slightly less memory</a> than <a href="https://github.com/python/cpython/blob/b879fe82e7e5c3f7673c9a7fa4aad42bd05445d8/Include/listobject.h#L4-L41">lists in CPython</a>, and they’re also faster to construct.</p>
<p>As you can see in the bytecode disassembly below, constructing a tuple constant takes a single <code>LOAD_CONST</code> opcode, while constructing a list object with the same contents requires several more operations:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb14-1" title="1"> <span class="im">import</span> dis</a>
<a class="sourceLine" id="cb14-2" title="2"></a>
<a class="sourceLine" id="cb14-3" title="3"> dis.dis(<span class="bu">compile</span>(<span class="st">&quot;(23, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;)&quot;</span>, <span class="st">&quot;&quot;</span>, <span class="st">&quot;eval&quot;</span>))</a>
<a class="sourceLine" id="cb14-4" title="4"> <span class="dv">0</span> LOAD_CONST           <span class="dv">4</span> ((<span class="dv">23</span>, <span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>))</a>
<a class="sourceLine" id="cb14-5" title="5"> <span class="dv">3</span> RETURN_VALUE</a>
<a class="sourceLine" id="cb14-6" title="6"></a>
<a class="sourceLine" id="cb14-7" title="7"></a>
<a class="sourceLine" id="cb14-8" title="8"> dis.dis(<span class="bu">compile</span>(<span class="st">&quot;[23, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]&quot;</span>, <span class="st">&quot;&quot;</span>, <span class="st">&quot;eval&quot;</span>))</a>
<a class="sourceLine" id="cb14-9" title="9"> <span class="dv">0</span> LOAD_CONST           <span class="dv">0</span> (<span class="dv">23</span>)</a>
<a class="sourceLine" id="cb14-10" title="10"> <span class="dv">3</span> LOAD_CONST           <span class="dv">1</span> (<span class="st">&#39;a&#39;</span>)</a>
<a class="sourceLine" id="cb14-11" title="11"> <span class="dv">6</span> LOAD_CONST           <span class="dv">2</span> (<span class="st">&#39;b&#39;</span>)</a>
<a class="sourceLine" id="cb14-12" title="12"> <span class="dv">9</span> LOAD_CONST           <span class="dv">3</span> (<span class="st">&#39;c&#39;</span>)</a>
<a class="sourceLine" id="cb14-13" title="13"> <span class="dv">12</span> BUILD_LIST           <span class="dv">4</span></a>
<a class="sourceLine" id="cb14-14" title="14"> <span class="dv">15</span> RETURN_VALUE`</a>
<a class="sourceLine" id="cb14-15" title="15"></a>
<a class="sourceLine" id="cb14-16" title="16">However, you shouldn’t place too much emphasis on these differences. In practice, the performance difference will often be negligible, <span class="kw">and</span> trying to squeeze extra performance out of a program by switching <span class="im">from</span> lists to tuples will likely be the wrong approach.</a>
<a class="sourceLine" id="cb14-17" title="17"></a>
<a class="sourceLine" id="cb14-18" title="18">A potential downside of plain tuples <span class="kw">is</span> that the data you store <span class="kw">in</span> them can only be pulled out by accessing it through integer indexes. You can’t give names to individual properties stored <span class="kw">in</span> a <span class="bu">tuple</span>. This can impact code readability.</a>
<a class="sourceLine" id="cb14-19" title="19"></a>
<a class="sourceLine" id="cb14-20" title="20">Also, a <span class="bu">tuple</span> <span class="kw">is</span> always an ad<span class="op">-</span>hoc structure: it’s difficult to ensure that two tuples have the same number of fields <span class="kw">and</span> the same properties stored <span class="kw">in</span> them.</a>
<a class="sourceLine" id="cb14-21" title="21"></a>
<a class="sourceLine" id="cb14-22" title="22">This makes it easy to introduce slip<span class="op">-</span>of<span class="op">-</span>the<span class="op">-</span>mind bugs, such <span class="im">as</span> mixing up the field order. Therefore, I would recommend that you keep the number of fields stored <span class="kw">in</span> a <span class="bu">tuple</span> <span class="im">as</span> low <span class="im">as</span> possible:</a>
<a class="sourceLine" id="cb14-23" title="23"></a>
<a class="sourceLine" id="cb14-24" title="24"></a>
<a class="sourceLine" id="cb14-25" title="25"></a>
<a class="sourceLine" id="cb14-26" title="26"></a>
<a class="sourceLine" id="cb14-27" title="27">```py</a>
<a class="sourceLine" id="cb14-28" title="28"> <span class="co"># Fields: color, mileage, automatic</span></a>
<a class="sourceLine" id="cb14-29" title="29"></a>
<a class="sourceLine" id="cb14-30" title="30"> car1 <span class="op">=</span> (<span class="st">&quot;red&quot;</span>, <span class="fl">3812.4</span>, <span class="va">True</span>)</a>
<a class="sourceLine" id="cb14-31" title="31"></a>
<a class="sourceLine" id="cb14-32" title="32"> car2 <span class="op">=</span> (<span class="st">&quot;blue&quot;</span>, <span class="fl">40231.0</span>, <span class="va">False</span>)</a>
<a class="sourceLine" id="cb14-33" title="33"></a>
<a class="sourceLine" id="cb14-34" title="34"></a>
<a class="sourceLine" id="cb14-35" title="35"> <span class="co"># Tuple instances have a nice repr:</span></a>
<a class="sourceLine" id="cb14-36" title="36"></a>
<a class="sourceLine" id="cb14-37" title="37"> car1</a>
<a class="sourceLine" id="cb14-38" title="38">(<span class="st">&#39;red&#39;</span>, <span class="fl">3812.4</span>, <span class="va">True</span>)</a>
<a class="sourceLine" id="cb14-39" title="39"></a>
<a class="sourceLine" id="cb14-40" title="40"> car2</a>
<a class="sourceLine" id="cb14-41" title="41">(<span class="st">&#39;blue&#39;</span>, <span class="fl">40231.0</span>, <span class="va">False</span>)</a>
<a class="sourceLine" id="cb14-42" title="42"></a>
<a class="sourceLine" id="cb14-43" title="43"></a>
<a class="sourceLine" id="cb14-44" title="44"> <span class="co"># Get mileage:</span></a>
<a class="sourceLine" id="cb14-45" title="45"></a>
<a class="sourceLine" id="cb14-46" title="46"> car2[<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb14-47" title="47"><span class="fl">40231.0</span></a>
<a class="sourceLine" id="cb14-48" title="48"></a>
<a class="sourceLine" id="cb14-49" title="49"></a>
<a class="sourceLine" id="cb14-50" title="50"> <span class="co"># Tuples are immutable:</span></a>
<a class="sourceLine" id="cb14-51" title="51"></a>
<a class="sourceLine" id="cb14-52" title="52"> car2[<span class="dv">1</span>] <span class="op">=</span> <span class="dv">12</span></a>
<a class="sourceLine" id="cb14-53" title="53">Traceback (most recent call last):</a>
<a class="sourceLine" id="cb14-54" title="54">  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb14-55" title="55"><span class="pp">TypeError</span>: <span class="st">&#39;tuple&#39;</span> <span class="bu">object</span> does <span class="kw">not</span> support item assignment</a>
<a class="sourceLine" id="cb14-56" title="56"></a>
<a class="sourceLine" id="cb14-57" title="57"></a>
<a class="sourceLine" id="cb14-58" title="58"> <span class="co"># No protection against missing or extra fields</span></a>
<a class="sourceLine" id="cb14-59" title="59"></a>
<a class="sourceLine" id="cb14-60" title="60"> <span class="co"># or a wrong order:</span></a>
<a class="sourceLine" id="cb14-61" title="61"></a>
<a class="sourceLine" id="cb14-62" title="62"> car3 <span class="op">=</span> (<span class="fl">3431.5</span>, <span class="st">&quot;green&quot;</span>, <span class="va">True</span>, <span class="st">&quot;silver&quot;</span>)`</a></code></pre></div>
<h4 id="write-a-custom-class-more-work-more-control">Write a Custom Class: More Work, More Control</h4>
<p><strong>Classes</strong> allow you to define reusable blueprints for data objects to ensure each object provides the same set of fields.</p>
<p>Using regular Python classes as record data types is feasible, but it also takes manual work to get the convenience features of other implementations. For example, adding new fields to the <code>__init__</code> constructor is verbose and takes time.</p>
<p>Also, the default string representation for objects instantiated from custom classes isn’t very helpful. To fix that, you may have to add your own <a href="https://docs.python.org/3.4/reference/datamodel.html#object.__repr__"><code>__repr__</code></a> method, which again is usually quite verbose and must be updated each time you add a new field.</p>
<p>Fields stored on classes are mutable, and new fields can be added freely, which you may or may not like. It’s possible to provide more access control and to create read-only fields using the <a href="https://docs.python.org/3/library/functions.html#property"><code>@property</code></a> decorator, but once again, this requires writing more glue code.</p>
<p>Writing a custom class is a great option whenever you’d like to add business logic and behavior to your record objects using methods. However, this means that these objects are technically no longer plain data objects:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb15-1" title="1"> <span class="kw">class</span> Car:</a>
<a class="sourceLine" id="cb15-2" title="2">     <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, color, mileage, automatic):</a>
<a class="sourceLine" id="cb15-3" title="3">         <span class="va">self</span>.color <span class="op">=</span> color</a>
<a class="sourceLine" id="cb15-4" title="4">         <span class="va">self</span>.mileage <span class="op">=</span> mileage</a>
<a class="sourceLine" id="cb15-5" title="5">         <span class="va">self</span>.automatic <span class="op">=</span> automatic</a>
<a class="sourceLine" id="cb15-6" title="6"></a>
<a class="sourceLine" id="cb15-7" title="7"></a>
<a class="sourceLine" id="cb15-8" title="8"> car1 <span class="op">=</span> Car(<span class="st">&quot;red&quot;</span>, <span class="fl">3812.4</span>, <span class="va">True</span>)</a>
<a class="sourceLine" id="cb15-9" title="9"></a>
<a class="sourceLine" id="cb15-10" title="10"> car2 <span class="op">=</span> Car(<span class="st">&quot;blue&quot;</span>, <span class="fl">40231.0</span>, <span class="va">False</span>)</a>
<a class="sourceLine" id="cb15-11" title="11"></a>
<a class="sourceLine" id="cb15-12" title="12"></a>
<a class="sourceLine" id="cb15-13" title="13"> <span class="co"># Get the mileage:</span></a>
<a class="sourceLine" id="cb15-14" title="14"></a>
<a class="sourceLine" id="cb15-15" title="15"> car2.mileage</a>
<a class="sourceLine" id="cb15-16" title="16"><span class="fl">40231.0</span></a>
<a class="sourceLine" id="cb15-17" title="17"></a>
<a class="sourceLine" id="cb15-18" title="18"></a>
<a class="sourceLine" id="cb15-19" title="19"> <span class="co"># Classes are mutable:</span></a>
<a class="sourceLine" id="cb15-20" title="20"></a>
<a class="sourceLine" id="cb15-21" title="21"> car2.mileage <span class="op">=</span> <span class="dv">12</span></a>
<a class="sourceLine" id="cb15-22" title="22"></a>
<a class="sourceLine" id="cb15-23" title="23"> car2.windshield <span class="op">=</span> <span class="st">&quot;broken&quot;</span></a>
<a class="sourceLine" id="cb15-24" title="24"></a>
<a class="sourceLine" id="cb15-25" title="25"></a>
<a class="sourceLine" id="cb15-26" title="26"> <span class="co"># String representation is not very useful</span></a>
<a class="sourceLine" id="cb15-27" title="27"></a>
<a class="sourceLine" id="cb15-28" title="28"> <span class="co"># (must add a manually written __repr__ method):</span></a>
<a class="sourceLine" id="cb15-29" title="29"></a>
<a class="sourceLine" id="cb15-30" title="30"> car1</a>
<a class="sourceLine" id="cb15-31" title="31"><span class="op">&lt;</span>Car <span class="bu">object</span> at <span class="bn">0x1081e69e8</span><span class="op">&gt;</span>`</a></code></pre></div>
<h4 id="dataclasses.dataclass-python-3.7-data-classes"><code>dataclasses.dataclass</code>: Python 3.7+ Data Classes</h4>
<p><a href="https://realpython.com/python-data-classes/">Data classes</a> are available in Python 3.7 and above. They provide an excellent alternative to defining your own data storage classes from scratch.</p>
<p>By writing a data class instead of a plain Python class, your object instances get a few useful features out of the box that will save you some typing and manual implementation work:</p>
<ul>
<li>The syntax for defining instance variables is shorter, since you don’t need to implement the <code>.__init__()</code> method.</li>
<li>Instances of your data class automatically get nice-looking string representation via an auto-generated <code>.__repr__()</code> method.</li>
<li>Instance variables accept type annotations, making your data class self-documenting to a degree. Keep in mind that type annotations are just hints that are not enforced without a separate <a href="https://realpython.com/python-type-checking/">type-checking</a> tool.</li>
</ul>
<p>Data classes are typically created using the <code>@dataclass</code> <a href="https://realpython.com/primer-on-python-decorators/">decorator</a>, as you’ll see in the code example below:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb16-1" title="1"> <span class="im">from</span> dataclasses <span class="im">import</span> dataclass</a>
<a class="sourceLine" id="cb16-2" title="2"></a>
<a class="sourceLine" id="cb16-3" title="3"> <span class="at">@dataclass</span></a>
<a class="sourceLine" id="cb16-4" title="4"> <span class="kw">class</span> Car:</a>
<a class="sourceLine" id="cb16-5" title="5">     color: <span class="bu">str</span></a>
<a class="sourceLine" id="cb16-6" title="6">     mileage: <span class="bu">float</span></a>
<a class="sourceLine" id="cb16-7" title="7">     automatic: <span class="bu">bool</span></a>
<a class="sourceLine" id="cb16-8" title="8"></a>
<a class="sourceLine" id="cb16-9" title="9"></a>
<a class="sourceLine" id="cb16-10" title="10"> car1 <span class="op">=</span> Car(<span class="st">&quot;red&quot;</span>, <span class="fl">3812.4</span>, <span class="va">True</span>)</a>
<a class="sourceLine" id="cb16-11" title="11"></a>
<a class="sourceLine" id="cb16-12" title="12"></a>
<a class="sourceLine" id="cb16-13" title="13"> <span class="co"># Instances have a nice repr:</span></a>
<a class="sourceLine" id="cb16-14" title="14"></a>
<a class="sourceLine" id="cb16-15" title="15"> car1</a>
<a class="sourceLine" id="cb16-16" title="16">Car(color<span class="op">=</span><span class="st">&#39;red&#39;</span>, mileage<span class="op">=</span><span class="fl">3812.4</span>, automatic<span class="op">=</span><span class="va">True</span>)</a>
<a class="sourceLine" id="cb16-17" title="17"></a>
<a class="sourceLine" id="cb16-18" title="18"></a>
<a class="sourceLine" id="cb16-19" title="19"> <span class="co"># Accessing fields:</span></a>
<a class="sourceLine" id="cb16-20" title="20"></a>
<a class="sourceLine" id="cb16-21" title="21"> car1.mileage</a>
<a class="sourceLine" id="cb16-22" title="22"><span class="fl">3812.4</span></a>
<a class="sourceLine" id="cb16-23" title="23"></a>
<a class="sourceLine" id="cb16-24" title="24"></a>
<a class="sourceLine" id="cb16-25" title="25"> <span class="co"># Fields are mutable:</span></a>
<a class="sourceLine" id="cb16-26" title="26"></a>
<a class="sourceLine" id="cb16-27" title="27"> car1.mileage <span class="op">=</span> <span class="dv">12</span></a>
<a class="sourceLine" id="cb16-28" title="28"></a>
<a class="sourceLine" id="cb16-29" title="29"> car1.windshield <span class="op">=</span> <span class="st">&quot;broken&quot;</span></a>
<a class="sourceLine" id="cb16-30" title="30"></a>
<a class="sourceLine" id="cb16-31" title="31"></a>
<a class="sourceLine" id="cb16-32" title="32"> <span class="co"># Type annotations are not enforced without</span></a>
<a class="sourceLine" id="cb16-33" title="33"></a>
<a class="sourceLine" id="cb16-34" title="34"> <span class="co"># a separate type checking tool like mypy:</span></a>
<a class="sourceLine" id="cb16-35" title="35"></a>
<a class="sourceLine" id="cb16-36" title="36"> Car(<span class="st">&quot;red&quot;</span>, <span class="st">&quot;NOT_A_FLOAT&quot;</span>, <span class="dv">99</span>)</a>
<a class="sourceLine" id="cb16-37" title="37">Car(color<span class="op">=</span><span class="st">&#39;red&#39;</span>, mileage<span class="op">=</span><span class="st">&#39;NOT_A_FLOAT&#39;</span>, automatic<span class="op">=</span><span class="dv">99</span>)`</a>
<a class="sourceLine" id="cb16-38" title="38"></a>
<a class="sourceLine" id="cb16-39" title="39"><span class="co">#To learn more about Python data classes, check out the [The Ultimate Guide to Data Classes in Python 3.7](https://realpython.com/python-data-classes/).</span></a></code></pre></div>
<h4 id="collections.namedtuple-convenient-data-objects"><code>collections.namedtuple</code>: Convenient Data Objects</h4>
<p>The <a href="https://dbader.org/blog/writing-clean-python-with-namedtuples"><code>namedtuple</code></a> class available in Python 2.6+ provides an extension of the built-in <code>tuple</code> data type. Similar to defining a custom class, using <code>namedtuple</code> allows you to define reusable blueprints for your records that ensure the correct field names are used.</p>
<p>``<code>pynamedtuple</code> objects are immutable, just like regular tuples. This means you can’t add new fields or modify existing fields after the <code>namedtuple</code> instance is created.</p>
<p>Besides that, <code>namedtuple</code> objects are, well . . . named tuples. Each object stored in them can be accessed through a unique identifier. This frees you from having to remember integer indexes or resort to workarounds like defining <strong>integer constants</strong> as mnemonics for your indexes.</p>
<p>``<code>pynamedtuple</code> objects are implemented as regular Python classes internally. When it comes to memory usage, they’re also better than regular classes and just as memory efficient as regular tuples:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb17-1" title="1"> <span class="im">from</span> collections <span class="im">import</span> namedtuple</a>
<a class="sourceLine" id="cb17-2" title="2"></a>
<a class="sourceLine" id="cb17-3" title="3"> <span class="im">from</span> sys <span class="im">import</span> getsizeof</a>
<a class="sourceLine" id="cb17-4" title="4"></a>
<a class="sourceLine" id="cb17-5" title="5"></a>
<a class="sourceLine" id="cb17-6" title="6"> p1 <span class="op">=</span> namedtuple(<span class="st">&quot;Point&quot;</span>, <span class="st">&quot;x y z&quot;</span>)(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb17-7" title="7"></a>
<a class="sourceLine" id="cb17-8" title="8"> p2 <span class="op">=</span> (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb17-9" title="9"></a>
<a class="sourceLine" id="cb17-10" title="10"></a>
<a class="sourceLine" id="cb17-11" title="11"> getsizeof(p1)</a>
<a class="sourceLine" id="cb17-12" title="12"><span class="dv">64</span></a>
<a class="sourceLine" id="cb17-13" title="13"></a>
<a class="sourceLine" id="cb17-14" title="14"> getsizeof(p2)</a>
<a class="sourceLine" id="cb17-15" title="15"><span class="dv">64</span>`</a></code></pre></div>
<blockquote>
<p>pynamedtuple` objects can be an easy way to clean up your code and make it more readable by enforcing a better structure for your data.</p>
</blockquote>
<p>I find that going from ad-hoc data types like dictionaries with a fixed format to <code>namedtuple</code> objects helps me to express the intent of my code more clearly. Often when I apply this refactoring, I magically come up with a better solution for the problem I’m facing.</p>
<p>Using <code>namedtuple</code> objects over regular (unstructured) tuples and dicts can also make your coworkers’ lives easier by making the data that’s being passed around self-documenting, at least to a degree:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb18-1" title="1"> <span class="im">from</span> collections <span class="im">import</span> namedtuple</a>
<a class="sourceLine" id="cb18-2" title="2"></a>
<a class="sourceLine" id="cb18-3" title="3"> Car <span class="op">=</span> namedtuple(<span class="st">&quot;Car&quot;</span> , <span class="st">&quot;color mileage automatic&quot;</span>)</a>
<a class="sourceLine" id="cb18-4" title="4"></a>
<a class="sourceLine" id="cb18-5" title="5"> car1 <span class="op">=</span> Car(<span class="st">&quot;red&quot;</span>, <span class="fl">3812.4</span>, <span class="va">True</span>)</a>
<a class="sourceLine" id="cb18-6" title="6"></a>
<a class="sourceLine" id="cb18-7" title="7"></a>
<a class="sourceLine" id="cb18-8" title="8"> <span class="co"># Instances have a nice repr:</span></a>
<a class="sourceLine" id="cb18-9" title="9"></a>
<a class="sourceLine" id="cb18-10" title="10"> car1</a>
<a class="sourceLine" id="cb18-11" title="11">Car(color<span class="op">=</span><span class="st">&quot;red&quot;</span>, mileage<span class="op">=</span><span class="fl">3812.4</span>, automatic<span class="op">=</span><span class="va">True</span>)</a>
<a class="sourceLine" id="cb18-12" title="12"></a>
<a class="sourceLine" id="cb18-13" title="13"></a>
<a class="sourceLine" id="cb18-14" title="14"> <span class="co"># Accessing fields:</span></a>
<a class="sourceLine" id="cb18-15" title="15"></a>
<a class="sourceLine" id="cb18-16" title="16"> car1.mileage</a>
<a class="sourceLine" id="cb18-17" title="17"><span class="fl">3812.4</span></a>
<a class="sourceLine" id="cb18-18" title="18"></a>
<a class="sourceLine" id="cb18-19" title="19"></a>
<a class="sourceLine" id="cb18-20" title="20"> <span class="co"># Fields are immtuable:</span></a>
<a class="sourceLine" id="cb18-21" title="21"></a>
<a class="sourceLine" id="cb18-22" title="22"> car1.mileage <span class="op">=</span> <span class="dv">12</span></a>
<a class="sourceLine" id="cb18-23" title="23">Traceback (most recent call last):</a>
<a class="sourceLine" id="cb18-24" title="24">  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb18-25" title="25"><span class="pp">AttributeError</span>: can<span class="st">&#39;t set attribute</span></a>
<a class="sourceLine" id="cb18-26" title="26"></a>
<a class="sourceLine" id="cb18-27" title="27"></a>
<a class="sourceLine" id="cb18-28" title="28"><span class="st"> car1.windshield = &quot;broken&quot;</span></a>
<a class="sourceLine" id="cb18-29" title="29"><span class="st">Traceback (most recent call last):</span></a>
<a class="sourceLine" id="cb18-30" title="30"><span class="st">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span></a>
<a class="sourceLine" id="cb18-31" title="31"><span class="st">AttributeError: &#39;</span>Car<span class="st">&#39; object has no attribute &#39;</span>windshield<span class="st">&#39;`</span></a></code></pre></div>
<h4 id="typing.namedtuple-improved-namedtuples"><code>typing.NamedTuple</code>: Improved Namedtuples</h4>
<p>Added in Python 3.6, <a href="https://docs.python.org/3/library/typing.html#typing.NamedTuple"><code>typing.NamedTuple</code></a> is the younger sibling of the <code>namedtuple</code> class in the <code>collections</code> module. It’s very similar to <code>namedtuple</code>, with the main difference being an updated syntax for defining new record types and added support for <a href="https://docs.python.org/3/library/typing.html">type hints</a>.</p>
<p>Please note that type annotations are not enforced without a separate type-checking tool like <a href="http://mypy-lang.org/">mypy</a>. But even without tool support, they can provide useful hints for other programmers (or be terribly confusing if the type hints become out of date):</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb19-1" title="1"> <span class="im">from</span> typing <span class="im">import</span> NamedTuple</a>
<a class="sourceLine" id="cb19-2" title="2"></a>
<a class="sourceLine" id="cb19-3" title="3"></a>
<a class="sourceLine" id="cb19-4" title="4"> <span class="kw">class</span> Car(NamedTuple):</a>
<a class="sourceLine" id="cb19-5" title="5">     color: <span class="bu">str</span></a>
<a class="sourceLine" id="cb19-6" title="6">     mileage: <span class="bu">float</span></a>
<a class="sourceLine" id="cb19-7" title="7">     automatic: <span class="bu">bool</span></a>
<a class="sourceLine" id="cb19-8" title="8"></a>
<a class="sourceLine" id="cb19-9" title="9"></a>
<a class="sourceLine" id="cb19-10" title="10"> car1 <span class="op">=</span> Car(<span class="st">&quot;red&quot;</span>, <span class="fl">3812.4</span>, <span class="va">True</span>)</a>
<a class="sourceLine" id="cb19-11" title="11"></a>
<a class="sourceLine" id="cb19-12" title="12"></a>
<a class="sourceLine" id="cb19-13" title="13"> <span class="co"># Instances have a nice repr:</span></a>
<a class="sourceLine" id="cb19-14" title="14"></a>
<a class="sourceLine" id="cb19-15" title="15"> car1</a>
<a class="sourceLine" id="cb19-16" title="16">Car(color<span class="op">=</span><span class="st">&#39;red&#39;</span>, mileage<span class="op">=</span><span class="fl">3812.4</span>, automatic<span class="op">=</span><span class="va">True</span>)</a>
<a class="sourceLine" id="cb19-17" title="17"></a>
<a class="sourceLine" id="cb19-18" title="18"></a>
<a class="sourceLine" id="cb19-19" title="19"> <span class="co"># Accessing fields:</span></a>
<a class="sourceLine" id="cb19-20" title="20"></a>
<a class="sourceLine" id="cb19-21" title="21"> car1.mileage</a>
<a class="sourceLine" id="cb19-22" title="22"><span class="fl">3812.4</span></a>
<a class="sourceLine" id="cb19-23" title="23"></a>
<a class="sourceLine" id="cb19-24" title="24"></a>
<a class="sourceLine" id="cb19-25" title="25"> <span class="co"># Fields are immutable:</span></a>
<a class="sourceLine" id="cb19-26" title="26"></a>
<a class="sourceLine" id="cb19-27" title="27"> car1.mileage <span class="op">=</span> <span class="dv">12</span></a>
<a class="sourceLine" id="cb19-28" title="28">Traceback (most recent call last):</a>
<a class="sourceLine" id="cb19-29" title="29">  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb19-30" title="30"><span class="pp">AttributeError</span>: can<span class="st">&#39;t set attribute</span></a>
<a class="sourceLine" id="cb19-31" title="31"></a>
<a class="sourceLine" id="cb19-32" title="32"></a>
<a class="sourceLine" id="cb19-33" title="33"><span class="st"> car1.windshield = &quot;broken&quot;</span></a>
<a class="sourceLine" id="cb19-34" title="34"><span class="st">Traceback (most recent call last):</span></a>
<a class="sourceLine" id="cb19-35" title="35"><span class="st">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span></a>
<a class="sourceLine" id="cb19-36" title="36"><span class="st">AttributeError: &#39;</span>Car<span class="st">&#39; object has no attribute &#39;</span>windshield<span class="st">&#39;</span></a>
<a class="sourceLine" id="cb19-37" title="37"></a>
<a class="sourceLine" id="cb19-38" title="38"></a>
<a class="sourceLine" id="cb19-39" title="39"><span class="st"> # Type annotations are not enforced without</span></a>
<a class="sourceLine" id="cb19-40" title="40"></a>
<a class="sourceLine" id="cb19-41" title="41"><span class="st"> # a separate type checking tool like mypy:</span></a>
<a class="sourceLine" id="cb19-42" title="42"></a>
<a class="sourceLine" id="cb19-43" title="43"><span class="st"> Car(&quot;red&quot;, &quot;NOT_A_FLOAT&quot;, 99)</span></a>
<a class="sourceLine" id="cb19-44" title="44"><span class="st">Car(color=&#39;</span>red<span class="st">&#39;, mileage=&#39;</span>NOT_A_FLOAT<span class="st">&#39;, automatic=99)`</span></a></code></pre></div>
<h4 id="struct.struct-serialized-c-structs"><code>struct.Struct</code>: Serialized C Structs</h4>
<p>The <a href="https://docs.python.org/3/library/struct.html#struct.Struct"><code>struct.Struct</code></a> class converts between Python values and C structs serialized into Python <code>bytes</code> objects. For example, it can be used to handle binary data stored in files or coming in from network connections.</p>
<p>Structs are defined using a mini language based on <a href="https://docs.python.org/3/library/struct.html#struct-format-strings">format strings</a> that allows you to define the arrangement of various C data types like <code>char</code>, <code>int</code>, and <code>long</code> as well as their <code>unsigned</code> variants.</p>
<p>Serialized structs are seldom used to represent data objects meant to be handled purely inside Python code. They’re intended primarily as a data exchange format rather than as a way of holding data in memory that’s only used by Python code.</p>
<p>In some cases, packing primitive data into structs may use less memory than keeping it in other data types. However, in most cases that would be quite an advanced (and probably unnecessary) optimization:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb20-1" title="1"> <span class="im">from</span> struct <span class="im">import</span> Struct</a>
<a class="sourceLine" id="cb20-2" title="2"></a>
<a class="sourceLine" id="cb20-3" title="3"> MyStruct <span class="op">=</span> Struct(<span class="st">&quot;i?f&quot;</span>)</a>
<a class="sourceLine" id="cb20-4" title="4"></a>
<a class="sourceLine" id="cb20-5" title="5"> data <span class="op">=</span> MyStruct.pack(<span class="dv">23</span>, <span class="va">False</span>, <span class="fl">42.0</span>)</a>
<a class="sourceLine" id="cb20-6" title="6"></a>
<a class="sourceLine" id="cb20-7" title="7"></a>
<a class="sourceLine" id="cb20-8" title="8"> <span class="co"># All you get is a blob of data:</span></a>
<a class="sourceLine" id="cb20-9" title="9"></a>
<a class="sourceLine" id="cb20-10" title="10"> data</a>
<a class="sourceLine" id="cb20-11" title="11">b<span class="st">&#39;</span><span class="ch">\x17\x00\x00\x00\x00\x00\x00\x00\x00\x00</span><span class="st">(B&#39;</span></a>
<a class="sourceLine" id="cb20-12" title="12"></a>
<a class="sourceLine" id="cb20-13" title="13"></a>
<a class="sourceLine" id="cb20-14" title="14"> <span class="co"># Data blobs can be unpacked again:</span></a>
<a class="sourceLine" id="cb20-15" title="15"></a>
<a class="sourceLine" id="cb20-16" title="16"> MyStruct.unpack(data)</a>
<a class="sourceLine" id="cb20-17" title="17">(<span class="dv">23</span>, <span class="va">False</span>, <span class="fl">42.0</span>)`</a></code></pre></div>
<h4 id="types.simplenamespace-fancy-attribute-access"><code>types.SimpleNamespace</code>: Fancy Attribute Access</h4>
<p>Here’s one more slightly obscure choice for implementing data objects in Python: <a href="https://docs.python.org/3/library/types.html#types.SimpleNamespace"><code>types.SimpleNamespace</code></a>. This class was added in Python 3.3 and provides <strong>attribute access</strong> to its namespace.</p>
<p>This means <code>SimpleNamespace</code> instances expose all of their keys as class attributes. You can use <code>obj.key</code> dotted attribute access instead of the <code>obj['key']</code> square-bracket indexing syntax that’s used by regular dicts. All instances also include a meaningful <code>__repr__</code> by default.</p>
<p>As its name proclaims, <code>SimpleNamespace</code> is simple! It’s basically a dictionary that allows attribute access and prints nicely. Attributes can be added, modified, and deleted freely:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb21-1" title="1"> <span class="im">from</span> types <span class="im">import</span> SimpleNamespace</a>
<a class="sourceLine" id="cb21-2" title="2"></a>
<a class="sourceLine" id="cb21-3" title="3"> car1 <span class="op">=</span> SimpleNamespace(color<span class="op">=</span><span class="st">&quot;red&quot;</span>, mileage<span class="op">=</span><span class="fl">3812.4</span>, automatic<span class="op">=</span><span class="va">True</span>)</a>
<a class="sourceLine" id="cb21-4" title="4"></a>
<a class="sourceLine" id="cb21-5" title="5"></a>
<a class="sourceLine" id="cb21-6" title="6"> <span class="co"># The default repr:</span></a>
<a class="sourceLine" id="cb21-7" title="7"></a>
<a class="sourceLine" id="cb21-8" title="8"> car1</a>
<a class="sourceLine" id="cb21-9" title="9">namespace(automatic<span class="op">=</span><span class="va">True</span>, color<span class="op">=</span><span class="st">&#39;red&#39;</span>, mileage<span class="op">=</span><span class="fl">3812.4</span>)</a>
<a class="sourceLine" id="cb21-10" title="10"></a>
<a class="sourceLine" id="cb21-11" title="11"></a>
<a class="sourceLine" id="cb21-12" title="12"> <span class="co"># Instances support attribute access and are mutable:</span></a>
<a class="sourceLine" id="cb21-13" title="13"></a>
<a class="sourceLine" id="cb21-14" title="14"> car1.mileage <span class="op">=</span> <span class="dv">12</span></a>
<a class="sourceLine" id="cb21-15" title="15"></a>
<a class="sourceLine" id="cb21-16" title="16"> car1.windshield <span class="op">=</span> <span class="st">&quot;broken&quot;</span></a>
<a class="sourceLine" id="cb21-17" title="17"></a>
<a class="sourceLine" id="cb21-18" title="18"> <span class="kw">del</span> car1.automatic</a>
<a class="sourceLine" id="cb21-19" title="19"></a>
<a class="sourceLine" id="cb21-20" title="20"> car1</a>
<a class="sourceLine" id="cb21-21" title="21">namespace(color<span class="op">=</span><span class="st">&#39;red&#39;</span>, mileage<span class="op">=</span><span class="dv">12</span>, windshield<span class="op">=</span><span class="st">&#39;broken&#39;</span>)`</a></code></pre></div>
<h4 id="records-structs-and-data-objects-in-python-summary">Records, Structs, and Data Objects in Python: Summary</h4>
<p>As you’ve seen, there’s quite a number of different options for implementing records or data objects. Which type should you use for data objects in Python? Generally your decision will depend on your use case:</p>
<ul>
<li>If you have only a few fields, then using a plain tuple object may be okay if the field order is easy to remember or field names are superfluous. For example, think of an <code>(x, y, z)</code> point in three-dimensional space.</li>
<li>If you need immutable fields, then plain tuples, <code>collections.namedtuple</code>, and <code>typing.NamedTuple</code> are all good options.</li>
<li>If you need to lock down field names to avoid typos, then <code>collections.namedtuple</code> and <code>typing.NamedTuple</code> are your friends.</li>
<li>If you want to keep things simple, then a plain dictionary object might be a good choice due to the convenient syntax that closely resembles <a href="https://realpython.com/python-json/">JSON</a>.</li>
<li>If you need full control over your data structure, then it’s time to write a custom class with <code>@property</code> setters and getters.</li>
<li>If you need to add behavior (methods) to the object, then you should write a custom class, either from scratch, or using the <code>dataclass</code> decorator, or by extending <code>collections.namedtuple</code> or <code>typing.NamedTuple</code>.</li>
<li>If you need to pack data tightly to serialize it to disk or to send it over the network, then it’s time to read up on <code>struct.Struct</code> because this is a great use case for it!</li>
</ul>
<p>If you’re looking for a safe default choice, then my general recommendation for implementing a plain record, struct, or data object in Python would be to use <code>collections.namedtuple</code> in Python 2.x and its younger sibling, <code>typing.NamedTuple</code> in Python 3.</p>
<h3 id="sets-and-multisets">Sets and Multisets</h3>
<p>In this section, you’ll see how to implement mutable and immutable <a href="https://realpython.com/python-sets/">set</a> and multiset (bag) data structures in Python using built-in data types and classes from the standard library.</p>
<p>A <strong>set</strong> is an unordered collection of objects that doesn’t allow duplicate elements. Typically, sets are used to quickly test a value for membership in the set, to insert or delete new values from a set, and to compute the union or intersection of two sets.</p>
<p>In a proper set implementation, membership tests are expected to run in fast <em>O</em>(1) time. Union, intersection, difference, and subset operations should take <em>O</em>(<em>n</em>) time on average. The set implementations included in Python’s standard library <a href="https://wiki.python.org/moin/TimeComplexity">follow these performance characteristics</a>.</p>
<p>Just like dictionaries, sets get special treatment in Python and have some syntactic sugar that makes them easy to create. For example, the curly-brace set expression syntax and <a href="https://realpython.com/list-comprehension-python/#using-set-and-dictionary-comprehensions">set comprehensions</a> allow you to conveniently define new set instances:</p>
<p>``<code>pyvowels = {"a", "e", "i", "o", "u"} squares = {x * x for x in range(10)}</code></p>
<p>But be careful: To create an empty set you’ll need to call the <code>set()</code> constructor. Using empty curly-braces (<code>{}</code>) is ambiguous and will create an empty dictionary instead.</p>
<p>Python and its standard library provide several set implementations. Let’s have a look at them.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb22-1" title="1"><span class="co">### `set`: Your Go-To Set[](https://realpython.com/python-data-structures/#set-your-go-to-set &quot;Permanent link&quot;)</span></a>
<a class="sourceLine" id="cb22-2" title="2"></a>
<a class="sourceLine" id="cb22-3" title="3">The [`set`](https:<span class="op">//</span>docs.python.org<span class="op">/</span><span class="dv">3</span><span class="op">/</span>library<span class="op">/</span>stdtypes.html<span class="co">#set-types-set-frozenset) type is the built-in set implementation in Python. It’s mutable and allows for the dynamic insertion and deletion of elements.</span></a>
<a class="sourceLine" id="cb22-4" title="4"></a>
<a class="sourceLine" id="cb22-5" title="5">Python’s sets are backed by the `dict` data <span class="bu">type</span> <span class="kw">and</span> share the same performance characteristics. Any [hashable](https:<span class="op">//</span>docs.python.org<span class="op">/</span><span class="dv">3</span><span class="op">/</span>glossary.html<span class="co">#term-hashable) object can be stored in a set:</span></a>
<a class="sourceLine" id="cb22-6" title="6"></a>
<a class="sourceLine" id="cb22-7" title="7"></a>
<a class="sourceLine" id="cb22-8" title="8"></a>
<a class="sourceLine" id="cb22-9" title="9"></a>
<a class="sourceLine" id="cb22-10" title="10">```py</a>
<a class="sourceLine" id="cb22-11" title="11"> vowels <span class="op">=</span> {<span class="st">&quot;a&quot;</span>, <span class="st">&quot;e&quot;</span>, <span class="st">&quot;i&quot;</span>, <span class="st">&quot;o&quot;</span>, <span class="st">&quot;u&quot;</span>}</a>
<a class="sourceLine" id="cb22-12" title="12"></a>
<a class="sourceLine" id="cb22-13" title="13"> <span class="st">&quot;e&quot;</span> <span class="kw">in</span> vowels</a>
<a class="sourceLine" id="cb22-14" title="14"><span class="va">True</span></a>
<a class="sourceLine" id="cb22-15" title="15"></a>
<a class="sourceLine" id="cb22-16" title="16"></a>
<a class="sourceLine" id="cb22-17" title="17"> letters <span class="op">=</span> <span class="bu">set</span>(<span class="st">&quot;alice&quot;</span>)</a>
<a class="sourceLine" id="cb22-18" title="18"></a>
<a class="sourceLine" id="cb22-19" title="19"> letters.intersection(vowels)</a>
<a class="sourceLine" id="cb22-20" title="20">{<span class="st">&#39;a&#39;</span>, <span class="st">&#39;e&#39;</span>, <span class="st">&#39;i&#39;</span>}</a>
<a class="sourceLine" id="cb22-21" title="21"></a>
<a class="sourceLine" id="cb22-22" title="22"></a>
<a class="sourceLine" id="cb22-23" title="23"> vowels.add(<span class="st">&quot;x&quot;</span>)</a>
<a class="sourceLine" id="cb22-24" title="24"></a>
<a class="sourceLine" id="cb22-25" title="25"> vowels</a>
<a class="sourceLine" id="cb22-26" title="26">{<span class="st">&#39;i&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;u&#39;</span>, <span class="st">&#39;o&#39;</span>, <span class="st">&#39;x&#39;</span>, <span class="st">&#39;e&#39;</span>}</a>
<a class="sourceLine" id="cb22-27" title="27"></a>
<a class="sourceLine" id="cb22-28" title="28"></a>
<a class="sourceLine" id="cb22-29" title="29"> <span class="bu">len</span>(vowels)</a>
<a class="sourceLine" id="cb22-30" title="30"><span class="dv">6</span>`</a></code></pre></div>
<h4 id="frozenset-immutable-sets"><code>frozenset</code>: Immutable Sets</h4>
<p>The <a href="https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset"><code>frozenset</code></a> class implements an immutable version of <code>set</code> that can’t be changed after it’s been constructed.</p>
<p>``<code>pyfrozenset</code> objects are static and allow only query operations on their elements, not inserts or deletions. Because <code>frozenset</code> objects are static and hashable, they can be used as dictionary keys or as elements of another set, something that isn’t possible with regular (mutable) <code>set</code> objects:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb23-1" title="1"> vowels <span class="op">=</span> <span class="bu">frozenset</span>({<span class="st">&quot;a&quot;</span>, <span class="st">&quot;e&quot;</span>, <span class="st">&quot;i&quot;</span>, <span class="st">&quot;o&quot;</span>, <span class="st">&quot;u&quot;</span>})</a>
<a class="sourceLine" id="cb23-2" title="2"></a>
<a class="sourceLine" id="cb23-3" title="3"> vowels.add(<span class="st">&quot;p&quot;</span>)</a>
<a class="sourceLine" id="cb23-4" title="4">Traceback (most recent call last):</a>
<a class="sourceLine" id="cb23-5" title="5">  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb23-6" title="6"><span class="pp">AttributeError</span>: <span class="st">&#39;frozenset&#39;</span> <span class="bu">object</span> has no attribute <span class="st">&#39;add&#39;</span></a>
<a class="sourceLine" id="cb23-7" title="7"></a>
<a class="sourceLine" id="cb23-8" title="8"></a>
<a class="sourceLine" id="cb23-9" title="9"> <span class="co"># Frozensets are hashable and can</span></a>
<a class="sourceLine" id="cb23-10" title="10"></a>
<a class="sourceLine" id="cb23-11" title="11"> <span class="co"># be used as dictionary keys:</span></a>
<a class="sourceLine" id="cb23-12" title="12"></a>
<a class="sourceLine" id="cb23-13" title="13"> d <span class="op">=</span> { <span class="bu">frozenset</span>({<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>}): <span class="st">&quot;hello&quot;</span> }</a>
<a class="sourceLine" id="cb23-14" title="14"></a>
<a class="sourceLine" id="cb23-15" title="15"> d[<span class="bu">frozenset</span>({<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>})]</a>
<a class="sourceLine" id="cb23-16" title="16"><span class="co">&#39;hello&#39;</span>`</a></code></pre></div>
<h4 id="collections.counter-multisets"><code>collections.Counter</code>: Multisets</h4>
<p>The <a href="https://docs.python.org/3/library/collections.html#collections.Counter"><code>collections.Counter</code></a> class in the Python standard library implements a multiset, or bag, type that allows elements in the set to have more than one occurrence.</p>
<p>This is useful if you need to keep track of not only <em>if</em> an element is part of a set, but also <em>how many times</em> it’s included in the set:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb24-1" title="1"> <span class="im">from</span> collections <span class="im">import</span> Counter</a>
<a class="sourceLine" id="cb24-2" title="2"></a>
<a class="sourceLine" id="cb24-3" title="3"> inventory <span class="op">=</span> Counter()</a>
<a class="sourceLine" id="cb24-4" title="4"></a>
<a class="sourceLine" id="cb24-5" title="5"></a>
<a class="sourceLine" id="cb24-6" title="6"> loot <span class="op">=</span> {<span class="st">&quot;sword&quot;</span>: <span class="dv">1</span>, <span class="st">&quot;bread&quot;</span>: <span class="dv">3</span>}</a>
<a class="sourceLine" id="cb24-7" title="7"></a>
<a class="sourceLine" id="cb24-8" title="8"> inventory.update(loot)</a>
<a class="sourceLine" id="cb24-9" title="9"></a>
<a class="sourceLine" id="cb24-10" title="10"> inventory</a>
<a class="sourceLine" id="cb24-11" title="11">Counter({<span class="st">&#39;bread&#39;</span>: <span class="dv">3</span>, <span class="st">&#39;sword&#39;</span>: <span class="dv">1</span>})</a>
<a class="sourceLine" id="cb24-12" title="12"></a>
<a class="sourceLine" id="cb24-13" title="13"></a>
<a class="sourceLine" id="cb24-14" title="14"> more_loot <span class="op">=</span> {<span class="st">&quot;sword&quot;</span>: <span class="dv">1</span>, <span class="st">&quot;apple&quot;</span>: <span class="dv">1</span>}</a>
<a class="sourceLine" id="cb24-15" title="15"></a>
<a class="sourceLine" id="cb24-16" title="16"> inventory.update(more_loot)</a>
<a class="sourceLine" id="cb24-17" title="17"></a>
<a class="sourceLine" id="cb24-18" title="18"> inventory</a>
<a class="sourceLine" id="cb24-19" title="19">Counter({<span class="st">&#39;bread&#39;</span>: <span class="dv">3</span>, <span class="st">&#39;sword&#39;</span>: <span class="dv">2</span>, <span class="st">&#39;apple&#39;</span>: <span class="dv">1</span>})`</a>
<a class="sourceLine" id="cb24-20" title="20"></a>
<a class="sourceLine" id="cb24-21" title="21">One caveat <span class="cf">for</span> the `Counter` <span class="kw">class</span> <span class="kw">is</span> that you’ll want to be careful when counting the number of elements <span class="kw">in</span> a `Counter` <span class="bu">object</span>. Calling `len()` returns the number of _unique_ elements <span class="kw">in</span> the multiset, whereas the _total_ number of elements can be retrieved using `sum()`:</a>
<a class="sourceLine" id="cb24-22" title="22"></a>
<a class="sourceLine" id="cb24-23" title="23"></a>
<a class="sourceLine" id="cb24-24" title="24"></a>
<a class="sourceLine" id="cb24-25" title="25"></a>
<a class="sourceLine" id="cb24-26" title="26">```py</a>
<a class="sourceLine" id="cb24-27" title="27"> <span class="bu">len</span>(inventory)</a>
<a class="sourceLine" id="cb24-28" title="28"><span class="dv">3</span>  <span class="co"># Unique elements</span></a>
<a class="sourceLine" id="cb24-29" title="29"></a>
<a class="sourceLine" id="cb24-30" title="30"></a>
<a class="sourceLine" id="cb24-31" title="31"> <span class="bu">sum</span>(inventory.values())</a>
<a class="sourceLine" id="cb24-32" title="32"><span class="dv">6</span>  <span class="co"># Total no. of elements`</span></a></code></pre></div>
<h4 id="sets-and-multisets-in-python-summary">Sets and Multisets in Python: Summary</h4>
<p>Sets are another useful and commonly used data structure included with Python and its standard library. Here are a few guidelines for deciding which one to use:</p>
<ul>
<li>If you need a mutable set, then use the built-in <code>set</code> type.</li>
<li>If you need hashable objects that can be used as dictionary or set keys, then use a <code>frozenset</code>.</li>
<li>If you need a multiset, or bag, data structure, then use <code>collections.Counter</code>.</li>
</ul>
<h3 id="stacks-lifos">Stacks (LIFOs)</h3>
<p>A <strong>stack</strong> is a collection of objects that supports fast <strong>Last-In/First-Out</strong> (LIFO) semantics for inserts and deletes. Unlike lists or arrays, stacks typically don’t allow for random access to the objects they contain. The insert and delete operations are also often called <strong>push</strong> and <strong>pop</strong>.</p>
<p>A useful real-world analogy for a stack data structure is a stack of plates. New plates are added to the top of the stack, and because the plates are precious and heavy, only the topmost plate can be moved. In other words, the last plate on the stack must be the first one removed (LIFO). To reach the plates that are lower down in the stack, the topmost plates must be removed one by one.</p>
<p>Performance-wise, a proper <a href="https://realpython.com/how-to-implement-python-stack/">stack implementation</a> is expected to take <em>O</em>(1) time for insert and delete operations.</p>
<p>Stacks have a wide range of uses in algorithms. For example, they’re used in language parsing as well as runtime memory management, which relies on a <strong>call stack</strong>. A short and beautiful algorithm using a stack is <a href="https://en.wikipedia.org/wiki/Depth-first_search">depth-first search</a> (DFS) on a tree or graph data structure.</p>
<p>Python ships with several stack implementations that each have slightly different characteristics. Let’s take a look at them and compare their characteristics.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb25-1" title="1"><span class="co">### `list`: Simple, Built-In Stacks[](https://realpython.com/python-data-structures/#list-simple-built-in-stacks &quot;Permanent link&quot;)</span></a>
<a class="sourceLine" id="cb25-2" title="2"></a>
<a class="sourceLine" id="cb25-3" title="3">Python’s built<span class="op">-</span><span class="kw">in</span> `list` <span class="bu">type</span> [makes a decent stack data structure](https:<span class="op">//</span>docs.python.org<span class="op">/</span><span class="dv">3</span><span class="op">/</span>tutorial<span class="op">/</span>datastructures.html<span class="co">#using-lists-as-stacks) as it supports push and pop operations in [amortized](https://en.wikipedia.org/wiki/Amortized_analysis) _O_(1) time.</span></a>
<a class="sourceLine" id="cb25-4" title="4"></a>
<a class="sourceLine" id="cb25-5" title="5">Python’s lists are implemented <span class="im">as</span> dynamic arrays internally, which means they occasionally need to resize the storage space <span class="cf">for</span> elements stored <span class="kw">in</span> them when elements are added <span class="kw">or</span> removed. The <span class="bu">list</span> over<span class="op">-</span>allocates its backing storage so that <span class="kw">not</span> every push <span class="kw">or</span> pop requires resizing. As a result, you get an amortized _O_(<span class="dv">1</span>) time complexity <span class="cf">for</span> these operations.</a>
<a class="sourceLine" id="cb25-6" title="6"></a>
<a class="sourceLine" id="cb25-7" title="7">The downside <span class="kw">is</span> that this makes their performance less consistent than the stable _O_(<span class="dv">1</span>) inserts <span class="kw">and</span> deletes provided by a linked list–based implementation (<span class="im">as</span> you’ll see below <span class="cf">with</span> `collections.deque`). On the other hand, lists do provide fast _O_(<span class="dv">1</span>) time random access to elements on the stack, <span class="kw">and</span> this can be an added benefit.</a>
<a class="sourceLine" id="cb25-8" title="8"></a>
<a class="sourceLine" id="cb25-9" title="9">There’s an important performance caveat that you should be aware of when using lists <span class="im">as</span> stacks: To get the amortized _O_(<span class="dv">1</span>) performance <span class="cf">for</span> inserts <span class="kw">and</span> deletes, new items must be added to the _end_ of the <span class="bu">list</span> <span class="cf">with</span> the `append()` method <span class="kw">and</span> removed again <span class="im">from</span> the end using `pop()`. For optimum performance, stacks based on Python lists should grow towards higher indexes <span class="kw">and</span> shrink towards lower ones.</a>
<a class="sourceLine" id="cb25-10" title="10"></a>
<a class="sourceLine" id="cb25-11" title="11">Adding <span class="kw">and</span> removing <span class="im">from</span> the front <span class="kw">is</span> much slower <span class="kw">and</span> takes _O_(_n_) time, <span class="im">as</span> the existing elements must be shifted around to make room <span class="cf">for</span> the new element. This <span class="kw">is</span> a performance [antipattern](https:<span class="op">//</span>en.wikipedia.org<span class="op">/</span>wiki<span class="op">/</span>Anti<span class="op">-</span>pattern) that you should avoid <span class="im">as</span> much <span class="im">as</span> possible:</a>
<a class="sourceLine" id="cb25-12" title="12"></a>
<a class="sourceLine" id="cb25-13" title="13"></a>
<a class="sourceLine" id="cb25-14" title="14"></a>
<a class="sourceLine" id="cb25-15" title="15"></a>
<a class="sourceLine" id="cb25-16" title="16">```py</a>
<a class="sourceLine" id="cb25-17" title="17"> s <span class="op">=</span> []</a>
<a class="sourceLine" id="cb25-18" title="18"></a>
<a class="sourceLine" id="cb25-19" title="19"> s.append(<span class="st">&quot;eat&quot;</span>)</a>
<a class="sourceLine" id="cb25-20" title="20"></a>
<a class="sourceLine" id="cb25-21" title="21"> s.append(<span class="st">&quot;sleep&quot;</span>)</a>
<a class="sourceLine" id="cb25-22" title="22"></a>
<a class="sourceLine" id="cb25-23" title="23"> s.append(<span class="st">&quot;code&quot;</span>)</a>
<a class="sourceLine" id="cb25-24" title="24"></a>
<a class="sourceLine" id="cb25-25" title="25"></a>
<a class="sourceLine" id="cb25-26" title="26"> s</a>
<a class="sourceLine" id="cb25-27" title="27">[<span class="st">&#39;eat&#39;</span>, <span class="st">&#39;sleep&#39;</span>, <span class="st">&#39;code&#39;</span>]</a>
<a class="sourceLine" id="cb25-28" title="28"></a>
<a class="sourceLine" id="cb25-29" title="29"></a>
<a class="sourceLine" id="cb25-30" title="30"> s.pop()</a>
<a class="sourceLine" id="cb25-31" title="31"><span class="st">&#39;code&#39;</span></a>
<a class="sourceLine" id="cb25-32" title="32"></a>
<a class="sourceLine" id="cb25-33" title="33"> s.pop()</a>
<a class="sourceLine" id="cb25-34" title="34"><span class="st">&#39;sleep&#39;</span></a>
<a class="sourceLine" id="cb25-35" title="35"></a>
<a class="sourceLine" id="cb25-36" title="36"> s.pop()</a>
<a class="sourceLine" id="cb25-37" title="37"><span class="st">&#39;eat&#39;</span></a>
<a class="sourceLine" id="cb25-38" title="38"></a>
<a class="sourceLine" id="cb25-39" title="39"></a>
<a class="sourceLine" id="cb25-40" title="40"> s.pop()</a>
<a class="sourceLine" id="cb25-41" title="41">Traceback (most recent call last):</a>
<a class="sourceLine" id="cb25-42" title="42">  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb25-43" title="43"><span class="pp">IndexError</span>: pop <span class="im">from</span> empty list`</a></code></pre></div>
<h4 id="collections.deque-fast-and-robust-stacks"><code>collections.deque</code>: Fast and Robust Stacks</h4>
<p>The <a href="https://docs.python.org/3/library/collections.html#collections.deque"><code>deque</code></a> class implements a double-ended queue that supports adding and removing elements from either end in <em>O</em>(1) time (non-amortized). Because deques support adding and removing elements from either end equally well, they can serve both as queues and as stacks.</p>
<p>Python’s <code>deque</code> objects are implemented as <a href="https://github.com/python/cpython/blob/6e8128f02e1d36e38e5866f9dc36e051caa47bc9/Modules/_collectionsmodule.c#L33-L35">doubly-linked lists</a>, which gives them excellent and consistent performance for inserting and deleting elements but poor <em>O</em>(<em>n</em>) performance for randomly accessing elements in the middle of a stack.</p>
<p>Overall, <a href="https://realpython.com/linked-lists-python/#introducing-collectionsdeque"><code>collections.deque</code> is a great choice</a> if you’re looking for a stack data structure in Python’s standard library that has the performance characteristics of a linked-list implementation:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb26-1" title="1"> <span class="im">from</span> collections <span class="im">import</span> deque</a>
<a class="sourceLine" id="cb26-2" title="2"></a>
<a class="sourceLine" id="cb26-3" title="3"> s <span class="op">=</span> deque()</a>
<a class="sourceLine" id="cb26-4" title="4"></a>
<a class="sourceLine" id="cb26-5" title="5"> s.append(<span class="st">&quot;eat&quot;</span>)</a>
<a class="sourceLine" id="cb26-6" title="6"></a>
<a class="sourceLine" id="cb26-7" title="7"> s.append(<span class="st">&quot;sleep&quot;</span>)</a>
<a class="sourceLine" id="cb26-8" title="8"></a>
<a class="sourceLine" id="cb26-9" title="9"> s.append(<span class="st">&quot;code&quot;</span>)</a>
<a class="sourceLine" id="cb26-10" title="10"></a>
<a class="sourceLine" id="cb26-11" title="11"></a>
<a class="sourceLine" id="cb26-12" title="12"> s</a>
<a class="sourceLine" id="cb26-13" title="13">deque([<span class="st">&#39;eat&#39;</span>, <span class="st">&#39;sleep&#39;</span>, <span class="st">&#39;code&#39;</span>])</a>
<a class="sourceLine" id="cb26-14" title="14"></a>
<a class="sourceLine" id="cb26-15" title="15"></a>
<a class="sourceLine" id="cb26-16" title="16"> s.pop()</a>
<a class="sourceLine" id="cb26-17" title="17"><span class="co">&#39;code&#39;</span></a>
<a class="sourceLine" id="cb26-18" title="18"></a>
<a class="sourceLine" id="cb26-19" title="19"> s.pop()</a>
<a class="sourceLine" id="cb26-20" title="20"><span class="co">&#39;sleep&#39;</span></a>
<a class="sourceLine" id="cb26-21" title="21"></a>
<a class="sourceLine" id="cb26-22" title="22"> s.pop()</a>
<a class="sourceLine" id="cb26-23" title="23"><span class="co">&#39;eat&#39;</span></a>
<a class="sourceLine" id="cb26-24" title="24"></a>
<a class="sourceLine" id="cb26-25" title="25"></a>
<a class="sourceLine" id="cb26-26" title="26"> s.pop()</a>
<a class="sourceLine" id="cb26-27" title="27">Traceback (most recent call last):</a>
<a class="sourceLine" id="cb26-28" title="28">  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb26-29" title="29"><span class="pp">IndexError</span>: pop <span class="im">from</span> an empty deque`</a></code></pre></div>
<h4 id="queue.lifoqueue-locking-semantics-for-parallel-computing"><code>queue.LifoQueue</code>: Locking Semantics for Parallel Computing</h4>
<p>The <a href="https://docs.python.org/3/library/queue.html#queue.LifoQueue"><code>LifoQueue</code></a> stack implementation in the Python standard library is synchronized and provides <strong>locking semantics</strong> to support multiple concurrent producers and consumers.</p>
<p>Besides <code>LifoQueue</code>, the <code>queue</code> module contains several other classes that implement multi-producer, multi-consumer queues that are useful for parallel computing.</p>
<p>Depending on your use case, the locking semantics might be helpful, or they might just incur unneeded overhead. In this case, you’d be better off using a <code>list</code> or a <code>deque</code> as a general-purpose stack:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb27-1" title="1"> <span class="im">from</span> queue <span class="im">import</span> LifoQueue</a>
<a class="sourceLine" id="cb27-2" title="2"></a>
<a class="sourceLine" id="cb27-3" title="3"> s <span class="op">=</span> LifoQueue()</a>
<a class="sourceLine" id="cb27-4" title="4"></a>
<a class="sourceLine" id="cb27-5" title="5"> s.put(<span class="st">&quot;eat&quot;</span>)</a>
<a class="sourceLine" id="cb27-6" title="6"></a>
<a class="sourceLine" id="cb27-7" title="7"> s.put(<span class="st">&quot;sleep&quot;</span>)</a>
<a class="sourceLine" id="cb27-8" title="8"></a>
<a class="sourceLine" id="cb27-9" title="9"> s.put(<span class="st">&quot;code&quot;</span>)</a>
<a class="sourceLine" id="cb27-10" title="10"></a>
<a class="sourceLine" id="cb27-11" title="11"></a>
<a class="sourceLine" id="cb27-12" title="12"> s</a>
<a class="sourceLine" id="cb27-13" title="13"><span class="op">&lt;</span>queue.LifoQueue <span class="bu">object</span> at <span class="bn">0x108298dd8</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb27-14" title="14"></a>
<a class="sourceLine" id="cb27-15" title="15"></a>
<a class="sourceLine" id="cb27-16" title="16"> s.get()</a>
<a class="sourceLine" id="cb27-17" title="17"><span class="co">&#39;code&#39;</span></a>
<a class="sourceLine" id="cb27-18" title="18"></a>
<a class="sourceLine" id="cb27-19" title="19"> s.get()</a>
<a class="sourceLine" id="cb27-20" title="20"><span class="co">&#39;sleep&#39;</span></a>
<a class="sourceLine" id="cb27-21" title="21"></a>
<a class="sourceLine" id="cb27-22" title="22"> s.get()</a>
<a class="sourceLine" id="cb27-23" title="23"><span class="co">&#39;eat&#39;</span></a>
<a class="sourceLine" id="cb27-24" title="24"></a>
<a class="sourceLine" id="cb27-25" title="25"></a>
<a class="sourceLine" id="cb27-26" title="26"> s.get_nowait()</a>
<a class="sourceLine" id="cb27-27" title="27">queue.Empty</a>
<a class="sourceLine" id="cb27-28" title="28"></a>
<a class="sourceLine" id="cb27-29" title="29"></a>
<a class="sourceLine" id="cb27-30" title="30"> s.get()  <span class="co"># Blocks/waits forever`</span></a></code></pre></div>
<h4 id="stack-implementations-in-python-summary">Stack Implementations in Python: Summary</h4>
<p>As you’ve seen, Python ships with several implementations for a stack data structure. All of them have slightly different characteristics as well as performance and usage trade-offs.</p>
<p>If you’re not looking for parallel processing support (or if you don’t want to handle locking and unlocking manually), then your choice comes down to the built-in <code>list</code> type or <code>collections.deque</code>. The difference lies in the data structure used behind the scenes and overall ease of use.</p>
<p><strong><code>list</code></strong> is backed by a dynamic array, which makes it great for fast random access but requires occasional resizing when elements are added or removed.</p>
<p>The list over-allocates its backing storage so that not every push or pop requires resizing, and you get an amortized <em>O</em>(1) time complexity for these operations. But you do need to be careful to only insert and remove items using <code>append()</code> and <code>pop()</code>. Otherwise, performance slows down to <em>O</em>(<em>n</em>).</p>
<p><strong><code>collections.deque</code></strong> is backed by a doubly-linked list, which optimizes appends and deletes at both ends and provides consistent <em>O</em>(1) performance for these operations. Not only is its performance more stable, the <code>deque</code> class is also easier to use because you don’t have to worry about adding or removing items from the wrong end.</p>
<p>In summary, <code>collections.deque</code> is an excellent choice for implementing a stack (LIFO queue) in Python.</p>
<h3 id="queues-fifos">Queues (FIFOs)</h3>
<p>In this section, you’ll see how to implement a <strong>First-In/First-Out</strong> (FIFO) queue data structure using only built-in data types and classes from the Python standard library.</p>
<p>A <strong>queue</strong> is a collection of objects that supports fast FIFO semantics for inserts and deletes. The insert and delete operations are sometimes called <strong>enqueue</strong> and <strong>dequeue</strong>. Unlike lists or arrays, queues typically don’t allow for random access to the objects they contain.</p>
<p>Here’s a real-world analogy for a FIFO queue:</p>
<p>Imagine a line of Pythonistas waiting to pick up their conference badges on day one of PyCon registration. As new people enter the conference venue and queue up to receive their badges, they join the line (enqueue) at the back of the queue. Developers receive their badges and conference swag bags and then exit the line (dequeue) at the front of the queue.</p>
<p>Another way to memorize the characteristics of a queue data structure is to think of it as a pipe. You add ping-pong balls to one end, and they travel to the other end, where you remove them. While the balls are in the queue (a solid metal pipe) you can’t get at them. The only way to interact with the balls in the queue is to add new ones at the back of the pipe (enqueue) or to remove them at the front (dequeue).</p>
<p>Queues are similar to stacks. The difference between them lies in how items are removed. With a <strong>queue</strong>, you remove the item <em>least</em> recently added (FIFO) but with a <strong>stack</strong>, you remove the item <em>most</em> recently added (LIFO).</p>
<p>Performance-wise, a proper queue implementation is expected to take <em>O</em>(1) time for insert and delete operations. These are the two main operations performed on a queue, and in a correct implementation, they should be fast.</p>
<p>Queues have a wide range of applications in algorithms and often help solve scheduling and parallel programming problems. A short and beautiful algorithm using a queue is <a href="https://en.wikipedia.org/wiki/Breadth-first_search">breadth-first search</a> (BFS) on a tree or graph data structure.</p>
<p>Scheduling algorithms often use <strong>priority queues</strong> internally. These are specialized queues. Instead of retrieving the next element by insertion time, a <a href="https://realpython.com/python-heapq-module/#data-structures-heaps-and-priority-queues">priority queue</a> retrieves the <em>highest-priority</em> element. The priority of individual elements is decided by the queue based on the ordering applied to their keys.</p>
<p>A regular queue, however, won’t reorder the items it carries. Just like in the pipe example, you get out what you put in, and in exactly that order.</p>
<p>Python ships with several queue implementations that each have slightly different characteristics. Let’s review them.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb28-1" title="1"><span class="co">### `list`: Terribly Sloooow Queues[](https://realpython.com/python-data-structures/#list-terribly-sloooow-queues &quot;Permanent link&quot;)</span></a>
<a class="sourceLine" id="cb28-2" title="2"></a>
<a class="sourceLine" id="cb28-3" title="3">It’s possible to [use a regular `list` <span class="im">as</span> a queue](https:<span class="op">//</span>docs.python.org<span class="op">/</span><span class="dv">3</span><span class="op">/</span>tutorial<span class="op">/</span>datastructures.html<span class="co">#using-lists-as-queues), but this is not ideal from a performance perspective. Lists are quite slow for this purpose because inserting or deleting an element at the beginning requires shifting all the other elements by one, requiring _O_(_n_) time.</span></a>
<a class="sourceLine" id="cb28-4" title="4"></a>
<a class="sourceLine" id="cb28-5" title="5">Therefore, I would _not_ recommend using a `list` <span class="im">as</span> a makeshift queue <span class="kw">in</span> Python unless you’re dealing <span class="cf">with</span> only a small number of elements:</a>
<a class="sourceLine" id="cb28-6" title="6"></a>
<a class="sourceLine" id="cb28-7" title="7"></a>
<a class="sourceLine" id="cb28-8" title="8"></a>
<a class="sourceLine" id="cb28-9" title="9"></a>
<a class="sourceLine" id="cb28-10" title="10">```py</a>
<a class="sourceLine" id="cb28-11" title="11"> q <span class="op">=</span> []</a>
<a class="sourceLine" id="cb28-12" title="12"></a>
<a class="sourceLine" id="cb28-13" title="13"> q.append(<span class="st">&quot;eat&quot;</span>)</a>
<a class="sourceLine" id="cb28-14" title="14"></a>
<a class="sourceLine" id="cb28-15" title="15"> q.append(<span class="st">&quot;sleep&quot;</span>)</a>
<a class="sourceLine" id="cb28-16" title="16"></a>
<a class="sourceLine" id="cb28-17" title="17"> q.append(<span class="st">&quot;code&quot;</span>)</a>
<a class="sourceLine" id="cb28-18" title="18"></a>
<a class="sourceLine" id="cb28-19" title="19"></a>
<a class="sourceLine" id="cb28-20" title="20"> q</a>
<a class="sourceLine" id="cb28-21" title="21">[<span class="st">&#39;eat&#39;</span>, <span class="st">&#39;sleep&#39;</span>, <span class="st">&#39;code&#39;</span>]</a>
<a class="sourceLine" id="cb28-22" title="22"></a>
<a class="sourceLine" id="cb28-23" title="23"></a>
<a class="sourceLine" id="cb28-24" title="24"> <span class="co"># Careful: This is slow!</span></a>
<a class="sourceLine" id="cb28-25" title="25"></a>
<a class="sourceLine" id="cb28-26" title="26"> q.pop(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb28-27" title="27"><span class="st">&#39;eat&#39;</span>`</a></code></pre></div>
<h4 id="collections.deque-fast-and-robust-queues"><code>collections.deque</code>: Fast and Robust Queues</h4>
<p>The <code>deque</code> class implements a double-ended queue that supports adding and removing elements from either end in <em>O</em>(1) time (non-amortized). Because deques support adding and removing elements from either end equally well, they can serve both as queues and as stacks.</p>
<p>Python’s <code>deque</code> objects are implemented as doubly-linked lists. This gives them excellent and consistent performance for inserting and deleting elements, but poor <em>O</em>(<em>n</em>) performance for randomly accessing elements in the middle of the stack.</p>
<p>As a result, <code>collections.deque</code> is a great default choice if you’re looking for a queue data structure in Python’s standard library:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb29-1" title="1"> <span class="im">from</span> collections <span class="im">import</span> deque</a>
<a class="sourceLine" id="cb29-2" title="2"></a>
<a class="sourceLine" id="cb29-3" title="3"> q <span class="op">=</span> deque()</a>
<a class="sourceLine" id="cb29-4" title="4"></a>
<a class="sourceLine" id="cb29-5" title="5"> q.append(<span class="st">&quot;eat&quot;</span>)</a>
<a class="sourceLine" id="cb29-6" title="6"></a>
<a class="sourceLine" id="cb29-7" title="7"> q.append(<span class="st">&quot;sleep&quot;</span>)</a>
<a class="sourceLine" id="cb29-8" title="8"></a>
<a class="sourceLine" id="cb29-9" title="9"> q.append(<span class="st">&quot;code&quot;</span>)</a>
<a class="sourceLine" id="cb29-10" title="10"></a>
<a class="sourceLine" id="cb29-11" title="11"></a>
<a class="sourceLine" id="cb29-12" title="12"> q</a>
<a class="sourceLine" id="cb29-13" title="13">deque([<span class="st">&#39;eat&#39;</span>, <span class="st">&#39;sleep&#39;</span>, <span class="st">&#39;code&#39;</span>])</a>
<a class="sourceLine" id="cb29-14" title="14"></a>
<a class="sourceLine" id="cb29-15" title="15"></a>
<a class="sourceLine" id="cb29-16" title="16"> q.popleft()</a>
<a class="sourceLine" id="cb29-17" title="17"><span class="co">&#39;eat&#39;</span></a>
<a class="sourceLine" id="cb29-18" title="18"></a>
<a class="sourceLine" id="cb29-19" title="19"> q.popleft()</a>
<a class="sourceLine" id="cb29-20" title="20"><span class="co">&#39;sleep&#39;</span></a>
<a class="sourceLine" id="cb29-21" title="21"></a>
<a class="sourceLine" id="cb29-22" title="22"> q.popleft()</a>
<a class="sourceLine" id="cb29-23" title="23"><span class="co">&#39;code&#39;</span></a>
<a class="sourceLine" id="cb29-24" title="24"></a>
<a class="sourceLine" id="cb29-25" title="25"></a>
<a class="sourceLine" id="cb29-26" title="26"> q.popleft()</a>
<a class="sourceLine" id="cb29-27" title="27">Traceback (most recent call last):</a>
<a class="sourceLine" id="cb29-28" title="28">  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb29-29" title="29"><span class="pp">IndexError</span>: pop <span class="im">from</span> an empty deque`</a></code></pre></div>
<h4 id="queue.queue-locking-semantics-for-parallel-computing"><code>queue.Queue</code>: Locking Semantics for Parallel Computing</h4>
<p>The <a href="https://docs.python.org/3/library/queue.html#queue.Queue"><code>queue.Queue</code></a> implementation in the Python standard library is synchronized and provides locking semantics to support multiple concurrent producers and consumers.</p>
<p>The <code>queue</code> module contains several other classes implementing multi-producer, multi-consumer queues that are useful for parallel computing.</p>
<p>Depending on your use case, the locking semantics might be helpful or just incur unneeded overhead. In this case, you’d be better off using <code>collections.deque</code> as a general-purpose queue:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb30-1" title="1"> <span class="im">from</span> queue <span class="im">import</span> Queue</a>
<a class="sourceLine" id="cb30-2" title="2"></a>
<a class="sourceLine" id="cb30-3" title="3"> q <span class="op">=</span> Queue()</a>
<a class="sourceLine" id="cb30-4" title="4"></a>
<a class="sourceLine" id="cb30-5" title="5"> q.put(<span class="st">&quot;eat&quot;</span>)</a>
<a class="sourceLine" id="cb30-6" title="6"></a>
<a class="sourceLine" id="cb30-7" title="7"> q.put(<span class="st">&quot;sleep&quot;</span>)</a>
<a class="sourceLine" id="cb30-8" title="8"></a>
<a class="sourceLine" id="cb30-9" title="9"> q.put(<span class="st">&quot;code&quot;</span>)</a>
<a class="sourceLine" id="cb30-10" title="10"></a>
<a class="sourceLine" id="cb30-11" title="11"></a>
<a class="sourceLine" id="cb30-12" title="12"> q</a>
<a class="sourceLine" id="cb30-13" title="13"><span class="op">&lt;</span>queue.Queue <span class="bu">object</span> at <span class="bn">0x1070f5b38</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb30-14" title="14"></a>
<a class="sourceLine" id="cb30-15" title="15"></a>
<a class="sourceLine" id="cb30-16" title="16"> q.get()</a>
<a class="sourceLine" id="cb30-17" title="17"><span class="co">&#39;eat&#39;</span></a>
<a class="sourceLine" id="cb30-18" title="18"></a>
<a class="sourceLine" id="cb30-19" title="19"> q.get()</a>
<a class="sourceLine" id="cb30-20" title="20"><span class="co">&#39;sleep&#39;</span></a>
<a class="sourceLine" id="cb30-21" title="21"></a>
<a class="sourceLine" id="cb30-22" title="22"> q.get()</a>
<a class="sourceLine" id="cb30-23" title="23"><span class="co">&#39;code&#39;</span></a>
<a class="sourceLine" id="cb30-24" title="24"></a>
<a class="sourceLine" id="cb30-25" title="25"></a>
<a class="sourceLine" id="cb30-26" title="26"> q.get_nowait()</a>
<a class="sourceLine" id="cb30-27" title="27">queue.Empty</a>
<a class="sourceLine" id="cb30-28" title="28"></a>
<a class="sourceLine" id="cb30-29" title="29"></a>
<a class="sourceLine" id="cb30-30" title="30"> q.get()  <span class="co"># Blocks/waits forever`</span></a></code></pre></div>
<h4 id="multiprocessing.queue-shared-job-queues"><code>multiprocessing.Queue</code>: Shared Job Queues</h4>
<p><a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue"><code>multiprocessing.Queue</code></a> is a shared job queue implementation that allows queued items to be processed in parallel by multiple concurrent workers. Process-based parallelization is popular in CPython due to the <a href="https://realpython.com/python-gil/">global interpreter lock</a> (GIL) that prevents some forms of parallel execution on a single interpreter process.</p>
<p>As a specialized queue implementation meant for sharing data between processes, <code>multiprocessing.Queue</code> makes it easy to distribute work across multiple processes in order to work around the GIL limitations. This type of queue can store and transfer any <a href="https://realpython.com/python-pickle-module/">pickleable</a> object across process boundaries:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb31-1" title="1"> <span class="im">from</span> multiprocessing <span class="im">import</span> Queue</a>
<a class="sourceLine" id="cb31-2" title="2"></a>
<a class="sourceLine" id="cb31-3" title="3"> q <span class="op">=</span> Queue()</a>
<a class="sourceLine" id="cb31-4" title="4"></a>
<a class="sourceLine" id="cb31-5" title="5"> q.put(<span class="st">&quot;eat&quot;</span>)</a>
<a class="sourceLine" id="cb31-6" title="6"></a>
<a class="sourceLine" id="cb31-7" title="7"> q.put(<span class="st">&quot;sleep&quot;</span>)</a>
<a class="sourceLine" id="cb31-8" title="8"></a>
<a class="sourceLine" id="cb31-9" title="9"> q.put(<span class="st">&quot;code&quot;</span>)</a>
<a class="sourceLine" id="cb31-10" title="10"></a>
<a class="sourceLine" id="cb31-11" title="11"></a>
<a class="sourceLine" id="cb31-12" title="12"> q</a>
<a class="sourceLine" id="cb31-13" title="13"><span class="op">&lt;</span>multiprocessing.queues.Queue <span class="bu">object</span> at <span class="bn">0x1081c12b0</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb31-14" title="14"></a>
<a class="sourceLine" id="cb31-15" title="15"></a>
<a class="sourceLine" id="cb31-16" title="16"> q.get()</a>
<a class="sourceLine" id="cb31-17" title="17"><span class="co">&#39;eat&#39;</span></a>
<a class="sourceLine" id="cb31-18" title="18"></a>
<a class="sourceLine" id="cb31-19" title="19"> q.get()</a>
<a class="sourceLine" id="cb31-20" title="20"><span class="co">&#39;sleep&#39;</span></a>
<a class="sourceLine" id="cb31-21" title="21"></a>
<a class="sourceLine" id="cb31-22" title="22"> q.get()</a>
<a class="sourceLine" id="cb31-23" title="23"><span class="co">&#39;code&#39;</span></a>
<a class="sourceLine" id="cb31-24" title="24"></a>
<a class="sourceLine" id="cb31-25" title="25"></a>
<a class="sourceLine" id="cb31-26" title="26"> q.get()  <span class="co"># Blocks/waits forever`</span></a></code></pre></div>
<h4 id="queues-in-python-summary">Queues in Python: Summary</h4>
<p>Python includes several queue implementations as part of the core language and its standard library.</p>
<p>``<code>pylist</code> objects can be used as queues, but this is generally not recommended due to slow performance.</p>
<p>If you’re not looking for parallel processing support, then the implementation offered by <code>collections.deque</code> is an excellent default choice for implementing a FIFO queue data structure in Python. It provides the performance characteristics you’d expect from a good queue implementation and can also be used as a stack (LIFO queue).</p>
<h3 id="priority-queues">Priority Queues</h3>
<p>A <strong>priority queue</strong> is a container data structure that manages a set of records with <a href="https://en.wikipedia.org/wiki/Total_order">totally-ordered</a> keys to provide quick access to the record with the smallest or largest key in the set.</p>
<p>You can think of a priority queue as a modified queue. Instead of retrieving the next element by insertion time, it retrieves the <em>highest-priority</em> element. The priority of individual elements is decided by the order applied to their keys.</p>
<p>Priority queues are commonly used for dealing with scheduling problems. For example, you might use them to give precedence to tasks with higher urgency.</p>
<p>Think about the job of an operating system task scheduler:</p>
<p>Ideally, higher-priority tasks on the system (such as playing a real-time game) should take precedence over lower-priority tasks (such as downloading updates in the background). By organizing pending tasks in a priority queue that uses task urgency as the key, the task scheduler can quickly select the highest-priority tasks and allow them to run first.</p>
<p>In this section, you’ll see a few options for how you can implement priority queues in Python using built-in data structures or data structures included in Python’s standard library. Each implementation will have its own upsides and downsides, but in my mind there’s a clear winner for most common scenarios. Let’s find out which one it is.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb32-1" title="1"><span class="co">### `list`: Manually Sorted Queues[](https://realpython.com/python-data-structures/#list-manually-sorted-queues &quot;Permanent link&quot;)</span></a>
<a class="sourceLine" id="cb32-2" title="2"></a>
<a class="sourceLine" id="cb32-3" title="3">You can use a <span class="bu">sorted</span> `list` to quickly identify <span class="kw">and</span> delete the smallest <span class="kw">or</span> largest element. The downside <span class="kw">is</span> that inserting new elements into a <span class="bu">list</span> <span class="kw">is</span> a slow _O_(_n_) operation.</a>
<a class="sourceLine" id="cb32-4" title="4"></a>
<a class="sourceLine" id="cb32-5" title="5">While the insertion point can be found <span class="kw">in</span> _O_(log _n_) time using [`bisect.insort`](https:<span class="op">//</span>docs.python.org<span class="op">/</span><span class="dv">3</span><span class="op">/</span>library<span class="op">/</span>bisect.html<span class="co">#bisect.insort) in the standard library, this is always dominated by the slow insertion step.</span></a>
<a class="sourceLine" id="cb32-6" title="6"></a>
<a class="sourceLine" id="cb32-7" title="7">Maintaining the order by appending to the <span class="bu">list</span> <span class="kw">and</span> re<span class="op">-</span>sorting also takes at least _O_(_n_ log _n_) time. Another downside <span class="kw">is</span> that you must manually take care of re<span class="op">-</span>sorting the <span class="bu">list</span> when new elements are inserted. It’s easy to introduce bugs by missing this step, <span class="kw">and</span> the burden <span class="kw">is</span> always on you, the developer.</a>
<a class="sourceLine" id="cb32-8" title="8"></a>
<a class="sourceLine" id="cb32-9" title="9">This means <span class="bu">sorted</span> lists are only suitable <span class="im">as</span> priority queues when there will be few insertions:</a>
<a class="sourceLine" id="cb32-10" title="10"></a>
<a class="sourceLine" id="cb32-11" title="11"></a>
<a class="sourceLine" id="cb32-12" title="12"></a>
<a class="sourceLine" id="cb32-13" title="13"></a>
<a class="sourceLine" id="cb32-14" title="14">```py</a>
<a class="sourceLine" id="cb32-15" title="15"> q <span class="op">=</span> []</a>
<a class="sourceLine" id="cb32-16" title="16"></a>
<a class="sourceLine" id="cb32-17" title="17"> q.append((<span class="dv">2</span>, <span class="st">&quot;code&quot;</span>))</a>
<a class="sourceLine" id="cb32-18" title="18"></a>
<a class="sourceLine" id="cb32-19" title="19"> q.append((<span class="dv">1</span>, <span class="st">&quot;eat&quot;</span>))</a>
<a class="sourceLine" id="cb32-20" title="20"></a>
<a class="sourceLine" id="cb32-21" title="21"> q.append((<span class="dv">3</span>, <span class="st">&quot;sleep&quot;</span>))</a>
<a class="sourceLine" id="cb32-22" title="22"></a>
<a class="sourceLine" id="cb32-23" title="23"> <span class="co"># Remember to re-sort every time a new element is inserted,</span></a>
<a class="sourceLine" id="cb32-24" title="24"></a>
<a class="sourceLine" id="cb32-25" title="25"> <span class="co"># or use bisect.insort()</span></a>
<a class="sourceLine" id="cb32-26" title="26"></a>
<a class="sourceLine" id="cb32-27" title="27"> q.sort(reverse<span class="op">=</span><span class="va">True</span>)</a>
<a class="sourceLine" id="cb32-28" title="28"></a>
<a class="sourceLine" id="cb32-29" title="29"></a>
<a class="sourceLine" id="cb32-30" title="30"> <span class="cf">while</span> q:</a>
<a class="sourceLine" id="cb32-31" title="31">     next_item <span class="op">=</span> q.pop()</a>
<a class="sourceLine" id="cb32-32" title="32">     <span class="bu">print</span>(next_item)</a>
<a class="sourceLine" id="cb32-33" title="33"></a>
<a class="sourceLine" id="cb32-34" title="34">(<span class="dv">1</span>, <span class="st">&#39;eat&#39;</span>)</a>
<a class="sourceLine" id="cb32-35" title="35">(<span class="dv">2</span>, <span class="st">&#39;code&#39;</span>)</a>
<a class="sourceLine" id="cb32-36" title="36">(<span class="dv">3</span>, <span class="st">&#39;sleep&#39;</span>)`</a></code></pre></div>
<h4 id="heapq-list-based-binary-heaps"><code>heapq</code>: List-Based Binary Heaps</h4>
<p><a href="https://docs.python.org/3/library/heapq.html"><code>heapq</code></a> is a binary heap implementation usually backed by a plain <code>list</code>, and it supports insertion and extraction of the smallest element in <em>O</em>(log <em>n</em>) time.</p>
<p>This module is a good choice for <a href="https://realpython.com/python-heapq-module/">implementing priority queues in Python</a>. Since <code>heapq</code> technically provides only a min-heap implementation, <a href="https://docs.python.org/3/library/heapq.html#priority-queue-implementation-notes">extra steps must be taken</a> to ensure sort stability and other features typically expected from a practical priority queue:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb33-1" title="1"> <span class="im">import</span> heapq</a>
<a class="sourceLine" id="cb33-2" title="2"></a>
<a class="sourceLine" id="cb33-3" title="3"> q <span class="op">=</span> []</a>
<a class="sourceLine" id="cb33-4" title="4"></a>
<a class="sourceLine" id="cb33-5" title="5"> heapq.heappush(q, (<span class="dv">2</span>, <span class="st">&quot;code&quot;</span>))</a>
<a class="sourceLine" id="cb33-6" title="6"></a>
<a class="sourceLine" id="cb33-7" title="7"> heapq.heappush(q, (<span class="dv">1</span>, <span class="st">&quot;eat&quot;</span>))</a>
<a class="sourceLine" id="cb33-8" title="8"></a>
<a class="sourceLine" id="cb33-9" title="9"> heapq.heappush(q, (<span class="dv">3</span>, <span class="st">&quot;sleep&quot;</span>))</a>
<a class="sourceLine" id="cb33-10" title="10"></a>
<a class="sourceLine" id="cb33-11" title="11"></a>
<a class="sourceLine" id="cb33-12" title="12"> <span class="cf">while</span> q:</a>
<a class="sourceLine" id="cb33-13" title="13">     next_item <span class="op">=</span> heapq.heappop(q)</a>
<a class="sourceLine" id="cb33-14" title="14">     <span class="bu">print</span>(next_item)</a>
<a class="sourceLine" id="cb33-15" title="15"></a>
<a class="sourceLine" id="cb33-16" title="16">(<span class="dv">1</span>, <span class="st">&#39;eat&#39;</span>)</a>
<a class="sourceLine" id="cb33-17" title="17">(<span class="dv">2</span>, <span class="st">&#39;code&#39;</span>)</a>
<a class="sourceLine" id="cb33-18" title="18">(<span class="dv">3</span>, <span class="st">&#39;sleep&#39;</span>)`</a></code></pre></div>
<h4 id="queue.priorityqueue-beautiful-priority-queues"><code>queue.PriorityQueue</code>: Beautiful Priority Queues</h4>
<p><a href="https://docs.python.org/3/library/queue.html#queue.PriorityQueue"><code>queue.PriorityQueue</code></a> uses <code>heapq</code> internally and shares the same time and space complexities. The difference is that <code>PriorityQueue</code> is synchronized and provides locking semantics to support multiple concurrent producers and consumers.</p>
<p>Depending on your use case, this might be helpful, or it might just slow your program down slightly. In any case, you might prefer the class-based interface provided by <code>PriorityQueue</code> over the function-based interface provided by <code>heapq</code>:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb34-1" title="1"> <span class="im">from</span> queue <span class="im">import</span> PriorityQueue</a>
<a class="sourceLine" id="cb34-2" title="2"></a>
<a class="sourceLine" id="cb34-3" title="3"> q <span class="op">=</span> PriorityQueue()</a>
<a class="sourceLine" id="cb34-4" title="4"></a>
<a class="sourceLine" id="cb34-5" title="5"> q.put((<span class="dv">2</span>, <span class="st">&quot;code&quot;</span>))</a>
<a class="sourceLine" id="cb34-6" title="6"></a>
<a class="sourceLine" id="cb34-7" title="7"> q.put((<span class="dv">1</span>, <span class="st">&quot;eat&quot;</span>))</a>
<a class="sourceLine" id="cb34-8" title="8"></a>
<a class="sourceLine" id="cb34-9" title="9"> q.put((<span class="dv">3</span>, <span class="st">&quot;sleep&quot;</span>))</a>
<a class="sourceLine" id="cb34-10" title="10"></a>
<a class="sourceLine" id="cb34-11" title="11"></a>
<a class="sourceLine" id="cb34-12" title="12"> <span class="cf">while</span> <span class="kw">not</span> q.empty():</a>
<a class="sourceLine" id="cb34-13" title="13">     next_item <span class="op">=</span> q.get()</a>
<a class="sourceLine" id="cb34-14" title="14">     <span class="bu">print</span>(next_item)</a>
<a class="sourceLine" id="cb34-15" title="15"></a>
<a class="sourceLine" id="cb34-16" title="16">(<span class="dv">1</span>, <span class="st">&#39;eat&#39;</span>)</a>
<a class="sourceLine" id="cb34-17" title="17">(<span class="dv">2</span>, <span class="st">&#39;code&#39;</span>)</a>
<a class="sourceLine" id="cb34-18" title="18">(<span class="dv">3</span>, <span class="st">&#39;sleep&#39;</span>)`</a></code></pre></div>
<h4 id="priority-queues-in-python-summary">Priority Queues in Python: Summary</h4>
<p>Python includes several priority queue implementations ready for you to use.</p>
<p><strong><code>queue.PriorityQueue</code></strong> stands out from the pack with a nice object-oriented interface and a name that clearly states its intent. It should be your preferred choice.</p>
<p>If you’d like to avoid the locking overhead of <code>queue.PriorityQueue</code>, then using the <strong><code>heapq</code></strong> module directly is also a good option.</p>
<h3 id="conclusion-python-data-structures">Conclusion: Python Data Structures</h3>
<p>That concludes your tour of common data structures in Python. With the knowledge you’ve gained here, you’re ready to implement efficient data structures that are just right for your specific algorithm or use case.</p>
<p><strong>In this tutorial, you’ve learned:</strong></p>
<ul>
<li>Which common <strong>abstract data types</strong> are built into the Python standard library</li>
<li>How the most common abstract data types map to Python’s <strong>naming scheme</strong></li>
<li>How to put abstract data types to <strong>practical use</strong> in various algorithms</li>
</ul>
<p>If you enjoyed what you learned in this sample from <em>Python Tricks</em>, then be sure to check out <a href="https://realpython.com/products/python-tricks-book/">the rest of the book</a>.</p>
<p>If you’re interested in brushing up on your general data structures knowledge, then I highly recommend <a href="https://realpython.com/asins/1848000693/">Steven S. Skiena’s <em>The Algorithm Design Manual</em></a>. It strikes a great balance between teaching you fundamental (and more advanced) data structures and showing you how to implement them in your code. Steve’s book was a great help in the writing of this tutorial.</p>
</body>
</html>
