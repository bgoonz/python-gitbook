<a href="https://bgoonz42.gitbook.io/datastructures-in-pytho/" class="link-a079aa82--primary-53a25e66--logoLink-10d08504"></a>

<img src="https://gblobscdn.gitbook.com/spaces%2F-Mij72ebV4OjqJvBacMy%2Favatar-rectangle-1631155247747.png?alt=media" class="image-67b14f24--logo-35ac2404--small-5fbe8ad7" />

<a href="https://bgoonz42.gitbook.io/datastructures-in-pytho/" class="link-a079aa82--primary-53a25e66--logoLink-10d08504"></a>

<img src="https://gblobscdn.gitbook.com/spaces%2F-Mij72ebV4OjqJvBacMy%2Favatar-rectangle-1631155247747.png?alt=media" class="image-67b14f24--logo-35ac2404--medium-5fbe8af6" />

<a href="https://bgoonz-blog.netlify.app/#gsc.tab=0" class="button-36063075--medium-6e2a217a--button-f76f0854--linkButton-67c61496--links-282dde1f"><span class="text-4505230f--UIH400-4e41e82a--textContentFamily-49a318e1--text-8ee2c8b2"><span class="text-4505230f--UIH400-4e41e82a--textContentFamily-49a318e1">My Blog</span></span></a>

<a href="https://www.notion.so/webdevhub42/Python-Data-Structures-Unit-1da9a5d55db844f4b62aff6fd2b4d1ce" class="button-36063075--medium-6e2a217a--button-f76f0854--linkButton-67c61496--links-282dde1f"><span class="text-4505230f--UIH400-4e41e82a--textContentFamily-49a318e1--text-8ee2c8b2"><span class="text-4505230f--UIH400-4e41e82a--textContentFamily-49a318e1">Notion Notes</span></span></a>

<a href="https://bgoonz-branch-the-algos.vercel.app/" class="button-36063075--medium-6e2a217a--button-f76f0854--linkButton-67c61496--links-282dde1f"><span class="text-4505230f--UIH400-4e41e82a--textContentFamily-49a318e1--text-8ee2c8b2"><span class="text-4505230f--UIH400-4e41e82a--textContentFamily-49a318e1">The Algorithms</span></span></a>

<a href="https://thealgorithms.netlify.app/#" class="button-36063075--medium-6e2a217a--button-f76f0854--linkButton-67c61496--links-282dde1f"><span class="text-4505230f--UIH400-4e41e82a--textContentFamily-49a318e1--text-8ee2c8b2"><span class="text-4505230f--UIH400-4e41e82a--textContentFamily-49a318e1">Python Module Website</span></span></a>

<a href="https://bgoonz42.gitbook.io/datastructures-in-pytho/" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Home</span></a>

<a href="../../index.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Downloads &amp; Misc-Assets</span></a>

<a href="../../readme-1.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">README</span></a>

<a href="../../navigation.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Navigation</span></a>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f"><span class="text-4505230f--InfoH200-3a8a7a86--textContentFamily-49a318e1">Cirriculumn</span></span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Outline</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">wk17</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">wk18</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">wk19</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">wk20</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f"><span class="text-4505230f--InfoH200-3a8a7a86--textContentFamily-49a318e1">Abstract Data Structures</span></span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Abstract Data Structures:</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Data Structures Overview</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Array</span>

<a href="binary-search.html" class="navButton-94f2579c--pageItemWithChildrenNested-2c5d8183--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Binary Search</span></a>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Exotic</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Graphs</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Hash Table</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Heap</span>

<a href="../../abstract-data-structures/untitled-1/string.html" class="navButton-94f2579c--pageItemWithChildrenNested-2c5d8183--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">String</span></a>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Map</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Queue</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Tree</span>

<a href="../../abstract-data-structures/untitled-1/tree/in-order-traversal.html" class="navButton-94f2579c--pageItemWithChildrenNested-2c5d8183--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">In Order Traversal</span></a>

<a href="../../abstract-data-structures/untitled-1/tree/tree-equal.html" class="navButton-94f2579c--pageItemWithChildrenNested-2c5d8183--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Tree Equal ?</span></a>

<a href="../../abstract-data-structures/untitled-1/tree/ternary-search-trees.html" class="navButton-94f2579c--pageItemWithChildrenNested-2c5d8183--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Ternary-search-trees</span></a>

<a href="../../abstract-data-structures/untitled-1/tree/red_black-tree.html" class="navButton-94f2579c--pageItemWithChildrenNested-2c5d8183--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Red_Black Tree</span></a>

<a href="../../abstract-data-structures/untitled-1/tree/tree-mirror.html" class="navButton-94f2579c--pageItemWithChildrenNested-2c5d8183--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Tree Mirror:</span></a>

<a href="../../abstract-data-structures/untitled-1/tree/tree-traversal.html" class="navButton-94f2579c--pageItemWithChildrenNested-2c5d8183--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Tree Traversal</span></a>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Binary Search Tree</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Binary Tree</span>

<a href="../../abstract-data-structures/untitled-1/tree/binary-tree/binary-tree-explained.html" class="navButton-94f2579c--pageItemWithChildrenNested-2c5d8183--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Binary Tree Explained</span></a>

<a href="../../abstract-data-structures/untitled-1/tree/binary-tree/find-the-maximum-path-sum-between-two-leaves-of-a-binary-tree.html" class="navButton-94f2579c--pageItemWithChildrenNested-2c5d8183--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Find the maximum path sum between two leaves of a binary tree</span></a>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Recursion</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Linked List</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Set</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Sorting</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Stack</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Searching</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f"><span class="text-4505230f--InfoH200-3a8a7a86--textContentFamily-49a318e1">Utilities</span></span>

<a href="../../utilities/code-lab-notebooks.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Code lab Notebooks</span></a>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Repl.IT</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Utilites</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f"><span class="text-4505230f--InfoH200-3a8a7a86--textContentFamily-49a318e1">practice</span></span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">GCA Sprint Prep:</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Supplemental Practice:</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f"><span class="text-4505230f--InfoH200-3a8a7a86--textContentFamily-49a318e1">Resources</span></span>

<a href="../../resources/python-cheat-sheet.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Python Cheat Sheet</span></a>

<a href="../../resources/intro-2-python.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Intro 2 Python</span></a>

<a href="../../resources/untitled-2.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Inheritance</span></a>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Strings</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Dictionaries</span>

<a href="../../resources/python-vs-javascript.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Python VS JavaScript</span></a>

<a href="../../resources/untitled-1.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Misc. Resources</span></a>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Things To Internalize:</span>

<a href="../../resources/intro-to-python-w-jupyter-notebooks.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Intro To Python w Jupyter Notebooks</span></a>

<a href="../../resources/calculating-big-o.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Calculating Big O</span></a>

<a href="../../resources/awesome-python.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Awesome Python</span></a>

<a href="../../resources/youtube.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Youtube</span></a>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Useful Links</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f"><span class="text-4505230f--InfoH200-3a8a7a86--textContentFamily-49a318e1">quick-reference</span></span>

<a href="../../quick-reference/my-medium-articles.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">My Medium Articles</span></a>

<a href="../../quick-reference/free-python-books.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Free Python Books</span></a>

<a href="../../quick-reference/why-python.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">WHY Python?</span></a>

<a href="../../quick-reference/python-snippets.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Python Snippets</span></a>

<a href="../../quick-reference/python3-regex.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Python3 Regex</span></a>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Python Module Index:</span>

<a href="../../quick-reference/creating-python-modules.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Creating Python Modules</span></a>

<a href="../../quick-reference/untitled.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Useful Info</span></a>

<a href="../../quick-reference/python-glossary.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Python Glossary</span></a>

<a href="../../quick-reference/untitled-1.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Python Snippets</span></a>

<a href="../../quick-reference/bash-commands.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">List Of Python Cheat Sheets</span></a>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f"><span class="text-4505230f--InfoH200-3a8a7a86--textContentFamily-49a318e1">Docs</span></span>

<a href="../../stdlib/touple.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Touple</span></a>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Docs</span>

<a href="../../stdlib/basic-syntax.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Basic Syntax</span></a>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Lists</span>

<a href="../../stdlib/conditionals-and-loops.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Conditionals and loops</span></a>

<a href="../../stdlib/dictionaries.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Dictionaries</span></a>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Classes and objects</span>

<a href="../../stdlib/untitled-1.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Functions</span></a>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Built In Functions</span>

<a href="../../stdlib/untitled-2.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Built-in Types</span></a>

<a href="../../stdlib/dictionaries-sets-files-and-modules.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Dictionaries, sets, files, and modules</span></a>

<a href="../../stdlib/queue-and-stacks.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Queue &amp; Stacks</span></a>

<a href="../../stdlib/values-expressions-and-statments.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Values Expressions &amp; Statments</span></a>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f"><span class="text-4505230f--InfoH200-3a8a7a86--textContentFamily-49a318e1">MISC</span></span>

<a href="../../misc/built-in-methods-and-functions.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Built-in Methods &amp; Functions</span></a>

<a href="../../misc/math.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Math</span></a>

<a href="../../misc/unsorted-examples.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Unsorted Examples</span></a>

<a href="../../misc/outline.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Outline</span></a>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">About Python</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f"><span class="text-4505230f--InfoH200-3a8a7a86--textContentFamily-49a318e1">Interview Prep</span></span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Interview Resources</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f"><span class="text-4505230f--InfoH200-3a8a7a86--textContentFamily-49a318e1">Installations Setup & Env</span></span>

<a href="../../installations-setup-and-env/untitled.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">python-setup</span></a>

<a href="../../installations-setup-and-env/installing-python-modules.html" class="navButton-94f2579c--navButtonClickable-161b88ca"><span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Installing Python Modules</span></a>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f"><span class="text-4505230f--InfoH200-3a8a7a86--textContentFamily-49a318e1">Aux-Exploration</span></span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1--navButtonLabel-14a4968f">Subject</span>

<a href="https://www.gitbook.com/?utm_source=content&amp;utm_medium=trademark&amp;utm_campaign=bgoonz42" class="reset-3c756112--trademark-a8da4b94"></a>

<span class="text-4505230f--TextH200-a3425406--textUIFamily-5ebd8e40">Powered by **GitBook**</span>

<span class="text-4505230f--DisplayH900-bfb998fa--textContentFamily-49a318e1">Binary Tree</span>
================================================================================================

<span class="text-4505230f--UIH300-2063425d--textUIFamily-5ebd8e40--text-8ee2c8b2"></span>

<span class="text-4505230f--UIH300-2063425d--textUIFamily-5ebd8e40--text-8ee2c8b2"></span>

<span class="text-4505230f--UIH300-2063425d--textUIFamily-5ebd8e40--text-8ee2c8b2"></span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1">Basic B-Tree.py</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1">B-Tree-Traversal.py</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1">BST.py</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1">BST-recursive.py</span>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1">Basic B-Tree.py</span>

    from __future__ import annotations​​class Node:    """    A Node has data variable and pointers to Nodes to its left and right.    """​    def __init__(self, data: int) -> None:        self.data = data        self.left: Node | None = None        self.right: Node | None = None​​def display(tree: Node | None) -> None:  # In Order traversal of the tree    """    >>> root = Node(1)    >>> root.left = Node(0)    >>> root.right = Node(2)    >>> display(root)    0    1    2    >>> display(root.right)    2    """    if tree:        display(tree.left)        print(tree.data)        display(tree.right)​​def depth_of_tree(tree: Node | None) -> int:    """    Recursive function that returns the depth of a binary tree.    >>> root = Node(0)    >>> depth_of_tree(root)    1    >>> root.left = Node(0)    >>> depth_of_tree(root)    2    >>> root.right = Node(0)    >>> depth_of_tree(root)    2    >>> root.left.right = Node(0)    >>> depth_of_tree(root)    3    >>> depth_of_tree(root.left)    2    """    return 1 + max(depth_of_tree(tree.left), depth_of_tree(tree.right)) if tree else 0​​def is_full_binary_tree(tree: Node) -> bool:    """    Returns True if this is a full binary tree    >>> root = Node(0)    >>> is_full_binary_tree(root)    True    >>> root.left = Node(0)    >>> is_full_binary_tree(root)    False    >>> root.right = Node(0)    >>> is_full_binary_tree(root)    True    >>> root.left.left = Node(0)    >>> is_full_binary_tree(root)    False    >>> root.right.right = Node(0)    >>> is_full_binary_tree(root)    False    """    if not tree:        return True    if tree.left and tree.right:        return is_full_binary_tree(tree.left) and is_full_binary_tree(tree.right)    else:        return not tree.left and not tree.right​​def main() -> None:  # Main function for testing.    tree = Node(1)    tree.left = Node(2)    tree.right = Node(3)    tree.left.left = Node(4)    tree.left.right = Node(5)    tree.left.right.left = Node(6)    tree.right.left = Node(7)    tree.right.left.left = Node(8)    tree.right.left.left.right = Node(9)​    print(is_full_binary_tree(tree))    print(depth_of_tree(tree))    print("Tree is: ")    display(tree)​​if __name__ == "__main__":    main()

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1">B-Tree-Traversal.py</span>

    # https://en.wikipedia.org/wiki/Tree_traversalfrom __future__ import annotations​from dataclasses import dataclass​​@dataclassclass Node:    data: int    left: Node | None = None    right: Node | None = None​​def make_tree() -> Node:    return Node(1, Node(2, Node(4), Node(5)), Node(3))​​def preorder(root: Node):    """    Pre-order traversal visits root node, left subtree, right subtree.    >>> preorder(make_tree())    [1, 2, 4, 5, 3]    """    return [root.data] + preorder(root.left) + preorder(root.right) if root else []​​def postorder(root: Node):    """    Post-order traversal visits left subtree, right subtree, root node.    >>> postorder(make_tree())    [4, 5, 2, 3, 1]    """    return postorder(root.left) + postorder(root.right) + [root.data] if root else []​​def inorder(root: Node):    """    In-order traversal visits left subtree, root node, right subtree.    >>> inorder(make_tree())    [4, 2, 5, 1, 3]    """    return inorder(root.left) + [root.data] + inorder(root.right) if root else []​​def height(root: Node):    """    Recursive function for calculating the height of the binary tree.    >>> height(None)    0    >>> height(make_tree())    3    """    return (max(height(root.left), height(root.right)) + 1) if root else 0​​def level_order_1(root: Node):    """    Print whole binary tree in Level Order Traverse.    Level Order traverse: Visit nodes of the tree level-by-level.    """    if not root:        return    temp = root    que = [temp]    while len(que) > 0:        print(que[0].data, end=" ")        temp = que.pop(0)        if temp.left:            que.append(temp.left)        if temp.right:            que.append(temp.right)    return que​​def level_order_2(root: Node, level: int):    """    Level-wise traversal: Print all nodes present at the given level of the binary tree    """    if not root:        return root    if level == 1:        print(root.data, end=" ")    elif level > 1:        level_order_2(root.left, level - 1)        level_order_2(root.right, level - 1)​​def print_left_to_right(root: Node, level: int):    """    Print elements on particular level from left to right direction of the binary tree.    """    if not root:        return    if level == 1:        print(root.data, end=" ")    elif level > 1:        print_left_to_right(root.left, level - 1)        print_left_to_right(root.right, level - 1)​​def print_right_to_left(root: Node, level: int):    """    Print elements on particular level from right to left direction of the binary tree.    """    if not root:        return    if level == 1:        print(root.data, end=" ")    elif level > 1:        print_right_to_left(root.right, level - 1)        print_right_to_left(root.left, level - 1)​​def zigzag(root: Node):    """    ZigZag traverse: Print node left to right and right to left, alternatively.    """    flag = 0    height_tree = height(root)    for h in range(1, height_tree + 1):        if flag == 0:            print_left_to_right(root, h)            flag = 1        else:            print_right_to_left(root, h)            flag = 0​​def main():  # Main function for testing.    """    Create binary tree.    """    root = make_tree()    """    All Traversals of the binary are as follows:    """    print(f"  In-order Traversal is {inorder(root)}")    print(f" Pre-order Traversal is {preorder(root)}")    print(f"Post-order Traversal is {postorder(root)}")    print(f"Height of Tree is {height(root)}")    print("Complete Level Order Traversal is : ")    level_order_1(root)    print("\nLevel-wise order Traversal is : ")    for h in range(1, height(root) + 1):        level_order_2(root, h)    print("\nZigZag order Traversal is : ")    zigzag(root)    print()​​if __name__ == "__main__":    import doctest​    doctest.testmod()    main()

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1">BST.py</span>

    """A binary search Tree"""​​class Node:    def __init__(self, value, parent):        self.value = value        self.parent = parent  # Added in order to delete a node easier        self.left = None        self.right = None​    def __repr__(self):        from pprint import pformat​        if self.left is None and self.right is None:            return str(self.value)        return pformat({"%s" % (self.value): (self.left, self.right)}, indent=1)​​class BinarySearchTree:    def __init__(self, root=None):        self.root = root​    def __str__(self):        """        Return a string of all the Nodes using in order traversal        """        return str(self.root)​    def __reassign_nodes(self, node, new_children):        if new_children is not None:  # reset its kids            new_children.parent = node.parent        if node.parent is not None:  # reset its parent            if self.is_right(node):  # If it is the right children                node.parent.right = new_children            else:                node.parent.left = new_children        else:            self.root = new_children​    def is_right(self, node):        return node == node.parent.right​    def empty(self):        return self.root is None​    def __insert(self, value):        """        Insert a new node in Binary Search Tree with value label        """        new_node = Node(value, None)  # create a new Node        if self.empty():  # if Tree is empty            self.root = new_node  # set its root        else:  # Tree is not empty            parent_node = self.root  # from root            while True:  # While we don't get to a leaf                if value < parent_node.value:  # We go left                    if parent_node.left is None:                        parent_node.left = new_node  # We insert the new node in a leaf                        break                    else:                        parent_node = parent_node.left                else:                    if parent_node.right is None:                        parent_node.right = new_node                        break                    else:                        parent_node = parent_node.right            new_node.parent = parent_node​    def insert(self, *values):        for value in values:            self.__insert(value)        return self​    def search(self, value):        if self.empty():            raise IndexError("Warning: Tree is empty! please use another.")        else:            node = self.root            # use lazy evaluation here to avoid NoneType Attribute error            while node is not None and node.value is not value:                node = node.left if value < node.value else node.right            return node​    def get_max(self, node=None):        """        We go deep on the right branch        """        if node is None:            node = self.root        if not self.empty():            while node.right is not None:                node = node.right        return node​    def get_min(self, node=None):        """        We go deep on the left branch        """        if node is None:            node = self.root        if not self.empty():            node = self.root            while node.left is not None:                node = node.left        return node​    def remove(self, value):        node = self.search(value)  # Look for the node with that label        if node is not None:            if node.left is None and node.right is None:  # If it has no children                self.__reassign_nodes(node, None)            elif node.left is None:  # Has only right children                self.__reassign_nodes(node, node.right)            elif node.right is None:  # Has only left children                self.__reassign_nodes(node, node.left)            else:                tmp_node = self.get_max(                    node.left                )  # Gets the max value of the left branch                self.remove(tmp_node.value)                node.value = (                    tmp_node.value                )  # Assigns the value to the node to delete and keep tree structure​    def preorder_traverse(self, node):        if node is not None:            yield node  # Preorder Traversal            yield from self.preorder_traverse(node.left)            yield from self.preorder_traverse(node.right)​    def traversal_tree(self, traversal_function=None):        """        This function traversal the tree.        You can pass a function to traversal the tree as needed by client code        """        if traversal_function is None:            return self.preorder_traverse(self.root)        else:            return traversal_function(self.root)​    def inorder(self, arr: list, node: Node):        """Perform an inorder traversal and append values of the nodes to        a list named arr"""        if node:            self.inorder(arr, node.left)            arr.append(node.value)            self.inorder(arr, node.right)​    def find_kth_smallest(self, k: int, node: Node) -> int:        """Return the kth smallest element in a binary search tree"""        arr = []        self.inorder(arr, node)  # append all values to list using inorder traversal        return arr[k - 1]​​def postorder(curr_node):    """    postOrder (left, right, self)    """    node_list = list()    if curr_node is not None:        node_list = postorder(curr_node.left) + postorder(curr_node.right) + [curr_node]    return node_list​​def binary_search_tree():    r"""    Example                  8                 / \                3   10               / \    \              1   6    14                 / \   /                4   7 13    >>> t = BinarySearchTree().insert(8, 3, 6, 1, 10, 14, 13, 4, 7)    >>> print(" ".join(repr(i.value) for i in t.traversal_tree()))    8 3 1 6 4 7 10 14 13    >>> print(" ".join(repr(i.value) for i in t.traversal_tree(postorder)))    1 4 7 6 3 13 14 10 8    >>> BinarySearchTree().search(6)    Traceback (most recent call last):    ...    IndexError: Warning: Tree is empty! please use another.    """    testlist = (8, 3, 6, 1, 10, 14, 13, 4, 7)    t = BinarySearchTree()    for i in testlist:        t.insert(i)​    # Prints all the elements of the list in order traversal    print(t)​    if t.search(6) is not None:        print("The value 6 exists")    else:        print("The value 6 doesn't exist")​    if t.search(-1) is not None:        print("The value -1 exists")    else:        print("The value -1 doesn't exist")​    if not t.empty():        print("Max Value: ", t.get_max().value)        print("Min Value: ", t.get_min().value)​    for i in testlist:        t.remove(i)        print(t)​​if __name__ == "__main__":    import doctest​    doctest.testmod()    # binary_search_tree()

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1">BST-recursive.py</span>

    """This is a python3 implementation of binary search tree using recursionTo run tests:python -m unittest binary_search_tree_recursive.pyTo run an example:python binary_search_tree_recursive.py"""from __future__ import annotations​import unittestfrom typing import Iterator​​class Node:    def __init__(self, label: int, parent: Node | None) -> None:        self.label = label        self.parent = parent        self.left: Node | None = None        self.right: Node | None = None​​class BinarySearchTree:    def __init__(self) -> None:        self.root: Node | None = None​    def empty(self) -> None:        """        Empties the tree        >>> t = BinarySearchTree()        >>> assert t.root is None        >>> t.put(8)        >>> assert t.root is not None        """        self.root = None​    def is_empty(self) -> bool:        """        Checks if the tree is empty        >>> t = BinarySearchTree()        >>> t.is_empty()        True        >>> t.put(8)        >>> t.is_empty()        False        """        return self.root is None​    def put(self, label: int) -> None:        """        Put a new node in the tree        >>> t = BinarySearchTree()        >>> t.put(8)        >>> assert t.root.parent is None        >>> assert t.root.label == 8        >>> t.put(10)        >>> assert t.root.right.parent == t.root        >>> assert t.root.right.label == 10        >>> t.put(3)        >>> assert t.root.left.parent == t.root        >>> assert t.root.left.label == 3        """        self.root = self._put(self.root, label)​    def _put(self, node: Node | None, label: int, parent: Node | None = None) -> Node:        if node is None:            node = Node(label, parent)        else:            if label < node.label:                node.left = self._put(node.left, label, node)            elif label > node.label:                node.right = self._put(node.right, label, node)            else:                raise Exception(f"Node with label {label} already exists")​        return node​    def search(self, label: int) -> Node:        """        Searches a node in the tree        >>> t = BinarySearchTree()        >>> t.put(8)        >>> t.put(10)        >>> node = t.search(8)        >>> assert node.label == 8        >>> node = t.search(3)        Traceback (most recent call last):            ...        Exception: Node with label 3 does not exist        """        return self._search(self.root, label)​    def _search(self, node: Node | None, label: int) -> Node:        if node is None:            raise Exception(f"Node with label {label} does not exist")        else:            if label < node.label:                node = self._search(node.left, label)            elif label > node.label:                node = self._search(node.right, label)​        return node​    def remove(self, label: int) -> None:        """        Removes a node in the tree        >>> t = BinarySearchTree()        >>> t.put(8)        >>> t.put(10)        >>> t.remove(8)        >>> assert t.root.label == 10        >>> t.remove(3)        Traceback (most recent call last):            ...        Exception: Node with label 3 does not exist        """        node = self.search(label)        if node.right and node.left:            lowest_node = self._get_lowest_node(node.right)            lowest_node.left = node.left            lowest_node.right = node.right            node.left.parent = lowest_node            if node.right:                node.right.parent = lowest_node            self._reassign_nodes(node, lowest_node)        elif not node.right and node.left:            self._reassign_nodes(node, node.left)        elif node.right and not node.left:            self._reassign_nodes(node, node.right)        else:            self._reassign_nodes(node, None)​    def _reassign_nodes(self, node: Node, new_children: Node | None) -> None:        if new_children:            new_children.parent = node.parent​        if node.parent:            if node.parent.right == node:                node.parent.right = new_children            else:                node.parent.left = new_children        else:            self.root = new_children​    def _get_lowest_node(self, node: Node) -> Node:        if node.left:            lowest_node = self._get_lowest_node(node.left)        else:            lowest_node = node            self._reassign_nodes(node, node.right)​        return lowest_node​    def exists(self, label: int) -> bool:        """        Checks if a node exists in the tree        >>> t = BinarySearchTree()        >>> t.put(8)        >>> t.put(10)        >>> t.exists(8)        True        >>> t.exists(3)        False        """        try:            self.search(label)            return True        except Exception:            return False​    def get_max_label(self) -> int:        """        Gets the max label inserted in the tree        >>> t = BinarySearchTree()        >>> t.get_max_label()        Traceback (most recent call last):            ...        Exception: Binary search tree is empty        >>> t.put(8)        >>> t.put(10)        >>> t.get_max_label()        10        """        if self.root is None:            raise Exception("Binary search tree is empty")​        node = self.root        while node.right is not None:            node = node.right​        return node.label​    def get_min_label(self) -> int:        """        Gets the min label inserted in the tree        >>> t = BinarySearchTree()        >>> t.get_min_label()        Traceback (most recent call last):            ...        Exception: Binary search tree is empty        >>> t.put(8)        >>> t.put(10)        >>> t.get_min_label()        8        """        if self.root is None:            raise Exception("Binary search tree is empty")​        node = self.root        while node.left is not None:            node = node.left​        return node.label​    def inorder_traversal(self) -> Iterator[Node]:        """        Return the inorder traversal of the tree        >>> t = BinarySearchTree()        >>> [i.label for i in t.inorder_traversal()]        []        >>> t.put(8)        >>> t.put(10)        >>> t.put(9)        >>> [i.label for i in t.inorder_traversal()]        [8, 9, 10]        """        return self._inorder_traversal(self.root)​    def _inorder_traversal(self, node: Node | None) -> Iterator[Node]:        if node is not None:            yield from self._inorder_traversal(node.left)            yield node            yield from self._inorder_traversal(node.right)​    def preorder_traversal(self) -> Iterator[Node]:        """        Return the preorder traversal of the tree        >>> t = BinarySearchTree()        >>> [i.label for i in t.preorder_traversal()]        []        >>> t.put(8)        >>> t.put(10)        >>> t.put(9)        >>> [i.label for i in t.preorder_traversal()]        [8, 10, 9]        """        return self._preorder_traversal(self.root)​    def _preorder_traversal(self, node: Node | None) -> Iterator[Node]:        if node is not None:            yield node            yield from self._preorder_traversal(node.left)            yield from self._preorder_traversal(node.right)​​class BinarySearchTreeTest(unittest.TestCase):    @staticmethod    def _get_binary_search_tree() -> BinarySearchTree:        r"""              8             / \            3   10           / \    \          1   6    14             / \   /            4   7 13             \              5        """        t = BinarySearchTree()        t.put(8)        t.put(3)        t.put(6)        t.put(1)        t.put(10)        t.put(14)        t.put(13)        t.put(4)        t.put(7)        t.put(5)​        return t​    def test_put(self) -> None:        t = BinarySearchTree()        assert t.is_empty()​        t.put(8)        r"""              8        """        assert t.root is not None        assert t.root.parent is None        assert t.root.label == 8​        t.put(10)        r"""              8               \                10        """        assert t.root.right is not None        assert t.root.right.parent == t.root        assert t.root.right.label == 10​        t.put(3)        r"""              8             / \            3   10        """        assert t.root.left is not None        assert t.root.left.parent == t.root        assert t.root.left.label == 3​        t.put(6)        r"""              8             / \            3   10             \              6        """        assert t.root.left.right is not None        assert t.root.left.right.parent == t.root.left        assert t.root.left.right.label == 6​        t.put(1)        r"""              8             / \            3   10           / \          1   6        """        assert t.root.left.left is not None        assert t.root.left.left.parent == t.root.left        assert t.root.left.left.label == 1​        with self.assertRaises(Exception):            t.put(1)​    def test_search(self) -> None:        t = self._get_binary_search_tree()​        node = t.search(6)        assert node.label == 6​        node = t.search(13)        assert node.label == 13​        with self.assertRaises(Exception):            t.search(2)​    def test_remove(self) -> None:        t = self._get_binary_search_tree()​        t.remove(13)        r"""              8             / \            3   10           / \    \          1   6    14             / \            4   7             \              5        """        assert t.root is not None        assert t.root.right is not None        assert t.root.right.right is not None        assert t.root.right.right.right is None        assert t.root.right.right.left is None​        t.remove(7)        r"""              8             / \            3   10           / \    \          1   6    14             /            4             \              5        """        assert t.root.left is not None        assert t.root.left.right is not None        assert t.root.left.right.left is not None        assert t.root.left.right.right is None        assert t.root.left.right.left.label == 4​        t.remove(6)        r"""              8             / \            3   10           / \    \          1   4    14               \                5        """        assert t.root.left.left is not None        assert t.root.left.right.right is not None        assert t.root.left.left.label == 1        assert t.root.left.right.label == 4        assert t.root.left.right.right.label == 5        assert t.root.left.right.left is None        assert t.root.left.left.parent == t.root.left        assert t.root.left.right.parent == t.root.left​        t.remove(3)        r"""              8             / \            4   10           / \    \          1   5    14        """        assert t.root is not None        assert t.root.left.label == 4        assert t.root.left.right.label == 5        assert t.root.left.left.label == 1        assert t.root.left.parent == t.root        assert t.root.left.left.parent == t.root.left        assert t.root.left.right.parent == t.root.left​        t.remove(4)        r"""              8             / \            5   10           /      \          1        14        """        assert t.root.left is not None        assert t.root.left.left is not None        assert t.root.left.label == 5        assert t.root.left.right is None        assert t.root.left.left.label == 1        assert t.root.left.parent == t.root        assert t.root.left.left.parent == t.root.left​    def test_remove_2(self) -> None:        t = self._get_binary_search_tree()​        t.remove(3)        r"""              8             / \            4   10           / \    \          1   6    14             / \   /            5   7 13        """        assert t.root is not None        assert t.root.left is not None        assert t.root.left.left is not None        assert t.root.left.right is not None        assert t.root.left.right.left is not None        assert t.root.left.right.right is not None        assert t.root.left.label == 4        assert t.root.left.right.label == 6        assert t.root.left.left.label == 1        assert t.root.left.right.right.label == 7        assert t.root.left.right.left.label == 5        assert t.root.left.parent == t.root        assert t.root.left.right.parent == t.root.left        assert t.root.left.left.parent == t.root.left        assert t.root.left.right.left.parent == t.root.left.right​    def test_empty(self) -> None:        t = self._get_binary_search_tree()        t.empty()        assert t.root is None​    def test_is_empty(self) -> None:        t = self._get_binary_search_tree()        assert not t.is_empty()​        t.empty()        assert t.is_empty()​    def test_exists(self) -> None:        t = self._get_binary_search_tree()​        assert t.exists(6)        assert not t.exists(-1)​    def test_get_max_label(self) -> None:        t = self._get_binary_search_tree()​        assert t.get_max_label() == 14​        t.empty()        with self.assertRaises(Exception):            t.get_max_label()​    def test_get_min_label(self) -> None:        t = self._get_binary_search_tree()​        assert t.get_min_label() == 1​        t.empty()        with self.assertRaises(Exception):            t.get_min_label()​    def test_inorder_traversal(self) -> None:        t = self._get_binary_search_tree()​        inorder_traversal_nodes = [i.label for i in t.inorder_traversal()]        assert inorder_traversal_nodes == [1, 3, 4, 5, 6, 7, 8, 10, 13, 14]​    def test_preorder_traversal(self) -> None:        t = self._get_binary_search_tree()​        preorder_traversal_nodes = [i.label for i in t.preorder_traversal()]        assert preorder_traversal_nodes == [8, 3, 1, 6, 4, 5, 7, 10, 14, 13]​​def binary_search_tree_example() -> None:    r"""    Example                  8                 / \                3   10               / \    \              1   6    14                 / \   /                4   7 13                \                5    Example After Deletion                  4                 / \                1   7                     \                      5    """​    t = BinarySearchTree()    t.put(8)    t.put(3)    t.put(6)    t.put(1)    t.put(10)    t.put(14)    t.put(13)    t.put(4)    t.put(7)    t.put(5)​    print(        """            8           / \\          3   10         / \\    \\        1   6    14           / \\   /          4   7 13           \\            5        """    )​    print("Label 6 exists:", t.exists(6))    print("Label 13 exists:", t.exists(13))    print("Label -1 exists:", t.exists(-1))    print("Label 12 exists:", t.exists(12))​    # Prints all the elements of the list in inorder traversal    inorder_traversal_nodes = [i.label for i in t.inorder_traversal()]    print("Inorder traversal:", inorder_traversal_nodes)​    # Prints all the elements of the list in preorder traversal    preorder_traversal_nodes = [i.label for i in t.preorder_traversal()]    print("Preorder traversal:", preorder_traversal_nodes)​    print("Max. label:", t.get_max_label())    print("Min. label:", t.get_min_label())​    # Delete elements    print("\nDeleting elements 13, 10, 8, 3, 6, 14")    print(        """          4         / \\        1   7             \\              5        """    )    t.remove(13)    t.remove(10)    t.remove(8)    t.remove(3)    t.remove(6)    t.remove(14)​    # Prints all the elements of the list in inorder traversal after delete    inorder_traversal_nodes = [i.label for i in t.inorder_traversal()]    print("Inorder traversal after delete:", inorder_traversal_nodes)​    # Prints all the elements of the list in preorder traversal after delete    preorder_traversal_nodes = [i.label for i in t.preorder_traversal()]    print("Preorder traversal after delete:", preorder_traversal_nodes)​    print("Max. label:", t.get_max_label())    print("Min. label:", t.get_min_label())​​if __name__ == "__main__":    binary_search_tree_example()

<span class="text-4505230f--HeadingH600-23f228db--textContentFamily-49a318e1"><span data-key="703ac484ce3841bcab4528f0499cd9e5"><span data-offset-key="703ac484ce3841bcab4528f0499cd9e5:0">Binary Trees</span></span></span>

1.  <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="011ec779374245b4b886fcfbc52d9ca1"><span data-offset-key="011ec779374245b4b886fcfbc52d9ca1:0">Explain and implement a Binary Tree.</span></span></span>

-   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="43ecd46b42e34907b527e72b6c2bd85f"><span data-offset-key="43ecd46b42e34907b527e72b6c2bd85f:0">A tree is a collection of nodes and edges between them.</span></span></span>

-   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="c8381a0b906541649928559471da2010"><span data-offset-key="c8381a0b906541649928559471da2010:0">It cannot have any cycles, which are edges that form a loop between nodes.</span></span></span>

-   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="47147811f47441aaafbcd2b756c12cbc"><span data-offset-key="47147811f47441aaafbcd2b756c12cbc:0">We also only consider rooted trees in computer science, which is a tree that has one root node that is able to access all other nodes.</span></span></span>

-   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="187b91bbc0814cbcbfe9249611baff35"><span data-offset-key="187b91bbc0814cbcbfe9249611baff35:0">For a tree to be a binary tree, each node can have a maximum of two children.</span></span></span>

-   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="07bc2e84ac444983b8b40c585aaca2aa"><span data-offset-key="07bc2e84ac444983b8b40c585aaca2aa:0">It's important to be able to identify and explain tree terminology as well. If given a tree, be able to point out each component.</span></span></span>

    -   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="faae7d07597a4764a68ace5fbc348339"><span data-offset-key="faae7d07597a4764a68ace5fbc348339:0">root: The single node of a tree that can access every other node through edges.</span></span></span>

    -   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="ad915479d1034d9d9a4e7c125a40ea48"><span data-offset-key="ad915479d1034d9d9a4e7c125a40ea48:0">parent node: A node that is connected to lower nodes in the tree. If a tree only has one node, it is not a parent node because there are no children.</span></span></span>

    -   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="1c104e4604234e27bc2b6f535eb9eff7"><span data-offset-key="1c104e4604234e27bc2b6f535eb9eff7:0">child node: A node that is connected to a higher node in the tree. Every node except for the root is a child node of some parent.</span></span></span>

    -   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="dabc5fcefbbe4b9396ce346addcf9386"><span data-offset-key="dabc5fcefbbe4b9396ce346addcf9386:0">sibling nodes: Nodes that have the same parent.</span></span></span>

    -   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="9e9b55e9eccf4d7089c044174f8a6306"><span data-offset-key="9e9b55e9eccf4d7089c044174f8a6306:0">leaf node: A node that has no children (at the ends of the branches of the tree)</span></span></span>

    -   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="4b7d279ae0d247b49580af3f71edee3b"><span data-offset-key="4b7d279ae0d247b49580af3f71edee3b:0">internal node: A non-leaf node (aka a parent)</span></span></span>

    -   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="186d80bdf703424bae11730d46e33407"><span data-offset-key="186d80bdf703424bae11730d46e33407:0">path: A series of nodes that can be traveled through edges.</span></span></span>

    -   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="a30e3e1e6a9e49ed9c6db05264942985"><span data-offset-key="a30e3e1e6a9e49ed9c6db05264942985:0">subtree: A smaller portion of the original tree. Any node that is not the root node is itself the root of a subtree.</span></span></span>

    -   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="1b29efc814d2446dbd0f038aff235d0f"><span data-offset-key="1b29efc814d2446dbd0f038aff235d0f:0">Know the basics of each term</span></span></span>

        -   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="15ae25d037ff4ce196a215f3de0bb2b3"><span data-offset-key="15ae25d037ff4ce196a215f3de0bb2b3:0">A non-empty tree has to have a root.</span></span></span>

        -   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="ab42e2322cd843b69a8c8985687a5193"><span data-offset-key="ab42e2322cd843b69a8c8985687a5193:0">A tree doesn't have any parent nodes if there are no children.</span></span></span>

        -   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="9e3d6f280cb84766a82249930b87ba81"><span data-offset-key="9e3d6f280cb84766a82249930b87ba81:0">What's the min/max number of parent and leaf nodes for a tree with 5 nodes?</span></span></span>

            -   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="2a61fbd7c0c249c6b38740bc63facd09"><span data-offset-key="2a61fbd7c0c249c6b38740bc63facd09:0">Two extreme implementations: </span></span><a href="https://github.com/bgoonz/DS-AND-ALGO-Notes-P2/blob/master/notes/D1/lo-s/W08D1and2/min-max-nodes-ll.png" class="link-a079aa82--primary-53a25e66--link-faf6c434"><span data-key="e9b1e96695c34cfbb6c5bd1a1c7feb5d"><span data-offset-key="e9b1e96695c34cfbb6c5bd1a1c7feb5d:0"><span data-slate-zero-width="z">​</span></span></span><span data-slate-void="true" data-key="677802736cf9486f8fff5b4e6844c036"><span><span class="reset-3c756112--frameInlineVoid-73b6a96b" data-key="677802736cf9486f8fff5b4e6844c036"><img src="https://github.com/bgoonz/DS-AND-ALGO-Notes-P2/raw/master/notes/D1/lo-s/W08D1and2/min-max-nodes-ll.png" alt="min-max-nodes-ll.png" class="image-67b14f24--image-54d049be" /></span></span></span><span data-key="01896739c4324801aa29db86799257e8"><span data-offset-key="01896739c4324801aa29db86799257e8:0"><span data-slate-zero-width="z">​</span></span></span></a><span data-key="6cacd84abeaa497683f4566ca85fa876"><span data-offset-key="6cacd84abeaa497683f4566ca85fa876:0"><span data-slate-zero-width="z">​</span></span></span></span>

            -   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="815777ef524b43ef9e624c8cd6be92cf"><span data-offset-key="815777ef524b43ef9e624c8cd6be92cf:0">Implementing in a chain results in max number of parents and min number of leaves: 4 parents, 1 leaf </span></span><a href="https://github.com/bgoonz/DS-AND-ALGO-Notes-P2/blob/master/notes/D1/lo-s/W08D1and2/min-max-nodes-balanced.png" class="link-a079aa82--primary-53a25e66--link-faf6c434"><span data-key="92571420a4444790ab12addb87c32976"><span data-offset-key="92571420a4444790ab12addb87c32976:0"><span data-slate-zero-width="z">​</span></span></span><span data-slate-void="true" data-key="422d306fb7204db38c5f7a72e0a94d3e"><span><span class="reset-3c756112--frameInlineVoid-73b6a96b" data-key="422d306fb7204db38c5f7a72e0a94d3e"><img src="https://github.com/bgoonz/DS-AND-ALGO-Notes-P2/raw/master/notes/D1/lo-s/W08D1and2/min-max-nodes-balanced.png" alt="min-max-nodes-balanced.png" class="image-67b14f24--image-54d049be" /></span></span></span><span data-key="a6dcdca2920a4c459c55e0057f3580f5"><span data-offset-key="a6dcdca2920a4c459c55e0057f3580f5:0"><span data-slate-zero-width="z">​</span></span></span></a><span data-key="4abb293104e04ed2bf2a80f28304847b"><span data-offset-key="4abb293104e04ed2bf2a80f28304847b:0"><span data-slate-zero-width="z">​</span></span></span></span>

            -   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="03436e9f35ab4c1b8fde4714fb384af3"><span data-offset-key="03436e9f35ab4c1b8fde4714fb384af3:0">Implementing as a balanced tree results in min number of parents and max number of leaves: 2 parents, 3 leaves</span></span></span>

    -   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="8c174a95d3304fbea0419cb6929a3ced"><span data-offset-key="8c174a95d3304fbea0419cb6929a3ced:0">All that we need in order to implement a binary tree is a TreeNode class that can store a value and references to a left and right child. We can create a tree by assigning the left and right properties to point to other TreeNode instances:</span></span></span>

    <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="65e8081de84a45ee8f59308e678270ee"><span data-offset-key="65e8081de84a45ee8f59308e678270ee:0"><span data-slate-zero-width="n">​</span></span></span></span>

<span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="1925f3e03fa841b48cb72eabaa354bd2"><span data-offset-key="1925f3e03fa841b48cb72eabaa354bd2:0"><span data-slate-zero-width="n">​</span></span></span></span>

    class TreeNode {  constructor(val) {    this.val = val;    this.left = null;    this.right = null;  }}

1.  <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="53fd97d52d594b9fa7cd12f8c276f0c9"><span data-offset-key="53fd97d52d594b9fa7cd12f8c276f0c9:0">Identify the three types of tree traversals: pre-order, in-order, and post-order.</span></span></span>

-   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="1c726876f84542bd9aaf5ef5bafa3b4d"><span data-offset-key="1c726876f84542bd9aaf5ef5bafa3b4d:0">Pre-order: Values are accessed as soon as the node is reached.</span></span></span>

-   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="4926efd5aca24ea5b35ad7c0bb74a20c"><span data-offset-key="4926efd5aca24ea5b35ad7c0bb74a20c:0">In-order: Values are accessed after we have fully explored the left but before we explore the right branch.</span></span></span>

-   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="4b9b95c631114195be0c7095e70f8e90"><span data-offset-key="4b9b95c631114195be0c7095e70f8e90:0">Post-order: Values are accessed after all of our children have been accessed.</span></span></span>

-   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="7e74410ac7a242a1bee065a6f778e4cf"><span data-offset-key="7e74410ac7a242a1bee065a6f778e4cf:0">\*Breadth First: The previous three are types of Depth First Traversals. Breadth first accesses values of nodes by level, left to right, top to bottom.</span></span></span>

-   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="d00d4fe7335440548af84e9b96630aa7"><span data-offset-key="d00d4fe7335440548af84e9b96630aa7:0">Given a tree, be able to determine the order of each traversal type: </span></span><a href="https://github.com/bgoonz/DS-AND-ALGO-Notes-P2/blob/master/notes/D1/lo-s/W08D1and2/number-tree.png" class="link-a079aa82--primary-53a25e66--link-faf6c434"><span data-key="99291ae9ef9f48d98144328770630e3f"><span data-offset-key="99291ae9ef9f48d98144328770630e3f:0"><span data-slate-zero-width="z">​</span></span></span><span data-slate-void="true" data-key="63d12586182c45788a88664c8d0c28b0"><span><span class="reset-3c756112--frameInlineVoid-73b6a96b" data-key="63d12586182c45788a88664c8d0c28b0"><img src="https://github.com/bgoonz/DS-AND-ALGO-Notes-P2/raw/master/notes/D1/lo-s/W08D1and2/number-tree.png" alt="Number tree" class="image-67b14f24--image-54d049be" /></span></span></span><span data-key="136bab2e9cbb487ebbdae3a859575723"><span data-offset-key="136bab2e9cbb487ebbdae3a859575723:0"><span data-slate-zero-width="z">​</span></span></span></a><span data-key="9ef37ff7f4b44e6797864280ca81724a"><span data-offset-key="9ef37ff7f4b44e6797864280ca81724a:0"><span data-slate-zero-width="z">​</span></span></span></span>

    -   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="8f9e6fb609e74b8f9acb549e2e523013"><span data-offset-key="8f9e6fb609e74b8f9acb549e2e523013:0">Breadth First: 20, 9, 24, 7, 11, 23, 27, 3, 10, 17, 36, 30</span></span></span>

    -   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="a6051054939e45b59f60060add8c839b"><span data-offset-key="a6051054939e45b59f60060add8c839b:0">Pre-order: 20, 9, 7, 3, 11, 10, 17, 24, 23, 27, 36, 30</span></span></span>

    -   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="0264db9bd4f1426a83fd39ac776a52b5"><span data-offset-key="0264db9bd4f1426a83fd39ac776a52b5:0">In-order: 3, 7, 9, 10, 11, 17, 20, 23, 24, 27, 30, 36</span></span></span>

    -   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="2e6bcafb12f143fdbcc86dab3ec3993f"><span data-offset-key="2e6bcafb12f143fdbcc86dab3ec3993f:0">Post-order: 3, 7, 10, 17, 11, 9, 23, 30, 36, 27, 24, 20</span></span></span>

1.  <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="c6438e40dd6246c69496c44d082fcefe"><span data-offset-key="c6438e40dd6246c69496c44d082fcefe:0">Explain and implement a Binary Search Tree.</span></span></span>

-   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="99853eabac0c471f805fb7e0e7194922"><span data-offset-key="99853eabac0c471f805fb7e0e7194922:0">A binary search tree is a binary tree with the added stipulation that all values to the left of a node are less than its value and all values to the right are greater than its value.</span></span></span>

-   <span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="80539ef02cee405b8af6f1afcee1a045"><span data-offset-key="80539ef02cee405b8af6f1afcee1a045:0">Example of a BST with an insert method. You won't be asked to implement a removal:</span></span></span>

<span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="fc4d246e3c7f4914ba84e808d63df8f6"><span data-offset-key="fc4d246e3c7f4914ba84e808d63df8f6:0"><span data-slate-zero-width="n">​</span></span></span></span>

<span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="aad23e65a67242899204fbdcad057064"><span data-offset-key="aad23e65a67242899204fbdcad057064:0"><span data-slate-zero-width="n">​</span></span></span></span>

    class BST {  constructor() {      this.root = null;  }​  insert(val, currentNode=this.root) {    if(!this.root) {      this.root = new TreeNode(val);      return;    }​    if (val < currentNode.val) {      if (!currentNode.left) {        currentNode.left = new TreeNode(val);      } else {        this.insert(val, currentNode.left);      }    } else {      if (!currentNode.right) {        currentNode.right = new TreeNode(val);      } else {        this.insert(val, currentNode.right);      }    }  }}​

    # Implement a Binary Search Tree (BST) that can insert values and check if# values are present​class Node(object):    def __init__(self, value):        self.value = value        self.left = None        self.right = None​class BST(object):    def __init__(self, root):        self.root = Node(root)​    def insert(self, new_val):        if(self.root.left==None):            if(self.root.value>new_val):                self.root.left = Node(new_val)        elif(self.root.right==None):            if(self.root.value<new_val):                self.root.right = Node(new_val)        else:            current = self.root            while(current.left!=None or current.right!=None):                if(current.value>new_val):                    current = current.left                else:                    current = current.right​            if(current.left==None):                current.left = Node(new_val)            else:                current.right = Node(new_val)​    def search(self, find_val):        if(self.root.left==None and self.root.right==None and self.root.value!=find_val):            return False        else:            current = self.root            val_possible = True            while(val_possible):                if(current.value==find_val):                        return True                if(current.value<find_val):                    current = current.right                else:                    current = current.left                if(current==None):                    return False                if(current.value<find_val and (current.right==None or current.right>find_val)):                    return False                if(current.value>find_val and (current.left==None or current.left<find_val)):                    return False​# Set up treetree = BST(4)​# Insert elementstree.insert(2)tree.insert(1)tree.insert(3)tree.insert(5)​# Check search# Should be Trueprint tree.search(4)# Should be Falseprint tree.search(6)​

    class Solution(object):    def topKFrequent(self, nums, k):        number_frequency = {}        frequency_list = {}        for i in nums:            if i not in number_frequency:                number_frequency[i] = 1            else:                number_frequency[i] += 1        for key, value in number_frequency.items():            if value not in frequency_list:                frequency_list[value] = [key]            else:                frequency_list[value].append(key)        result = []        for i in range(len(nums), 0, -1):            if i in frequency_list:                result.extend(frequency_list[i])            if len(result) >= k:                break        return result​​ob1 = Solution()print(ob1.topKFrequent([1, 1, 1, 1, 2, 2, 3, 3, 3], 2))​​​​

<span class="text-4505230f--HeadingH700-04e1a2a3--textContentFamily-49a318e1"><span data-key="10213338ec0846e5a8683a34df9ed83b"><span data-offset-key="10213338ec0846e5a8683a34df9ed83b:0">Balanced Binary Tree</span></span></span>

<span class="text-4505230f--HeadingH700-04e1a2a3--textContentFamily-49a318e1"><span data-key="5181e9be2b2b4b2c9655f9eee01036c3"><span data-offset-key="5181e9be2b2b4b2c9655f9eee01036c3:0">Balanced Binary Tree</span></span></span>

<span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="fd0c34f7474248e5825e65f8e4e08923"><span data-offset-key="fd0c34f7474248e5825e65f8e4e08923:0">Given a binary tree class that looks like this:</span></span></span>

    class BinaryTreeNode {  constructor(value) {    this.value = value;    this.left = null;    this.right = null;  }​  insertLeft(value) {    this.left = new BinaryTreeNode(value);    return this.left;  }​  insertRight(value) {    this.right = new BinaryTreeNode(value);    return this.right;  }}

<span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="01a8d1cfeb7a4aa09b26b197a62682df"><span data-offset-key="01a8d1cfeb7a4aa09b26b197a62682df:0">write a function that checks to see if a given binary tree is perfectly balanced, meaning all leaf nodes are located at the same depth. Your function should return </span><span data-offset-key="01a8d1cfeb7a4aa09b26b197a62682df:1">`true`</span><span data-offset-key="01a8d1cfeb7a4aa09b26b197a62682df:2"> if the tree is perfectly balanced and </span><span data-offset-key="01a8d1cfeb7a4aa09b26b197a62682df:3">`false`</span><span data-offset-key="01a8d1cfeb7a4aa09b26b197a62682df:4"> otherwise.</span></span></span>

<span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="9b09f4b98e2544cbac41d55c89494e80"><span data-offset-key="9b09f4b98e2544cbac41d55c89494e80:0">Analyze the time and space complexity of your function.</span></span></span>

<span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="dbb1e0bed53c42668fd19b1c45a432e4"><span data-offset-key="dbb1e0bed53c42668fd19b1c45a432e4:0"><span data-slate-zero-width="n">​</span></span></span></span>

<span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="8debe2d01e19423cb8abb963f1d1f735"><span data-offset-key="8debe2d01e19423cb8abb963f1d1f735:0">JS Solution:</span></span></span>

    /*   A recursive solution  How would you solve this iteratively? */const checkBalanced = (rootNode) => {  // An empty tree is balanced by default  if (!rootNode) return true;  // recursive helper function to check the min depth of the tree  const minDepth = (node) => {    if (!node) return 0;    return 1 + Math.min(minDepth(node.left), minDepth(node.right));  };  // recursive helper function to check the max depth of the tree  const maxDepth = (node) => {    if (!node) return 0;    return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));  };​  return maxDepth(rootNode) - minDepth(rootNode) === 0;};​/* Some console.log tests */class BinaryTreeNode {  constructor(value) {    this.value = value;    this.left = null;    this.right = null;  }​  insertLeft(value) {    this.left = new BinaryTreeNode(value);    return this.left;  }​  insertRight(value) {    this.right = new BinaryTreeNode(value);    return this.right;  }}​const root = new BinaryTreeNode(5);console.log(checkBalanced(root)); // should print true​root.insertLeft(10);console.log(checkBalanced(root)); // should print false​root.insertRight(11);console.log(checkBalanced(root)); // should print true;​

<span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="fbb43e0e8dfe4dc8bac031c854884e55"><span data-offset-key="fbb43e0e8dfe4dc8bac031c854884e55:0"><span data-slate-zero-width="n">​</span></span></span></span>

    #  A recursive solution#  How would you solve this iteratively?​​def checkBalanced(rootNode):    # An empty tree is balanced by default    if rootNode == None:        return True​    # recursive helper function to check the min depth of the tree    def minDepth(node):        if node == None:            return 0        return 1 + min(minDepth(node.left), minDepth(node.right))​    # recursive helper function to check the max depth of the tree    def maxDepth(node):        if node == None:            return 0        return 1 + max(maxDepth(node.left), maxDepth(node.right))​    return maxDepth(rootNode) - minDepth(rootNode) == 0​​# Some console.log testsclass BinaryTreeNode:    def __init__(self, value):        self.value = value        self.left = None        self.right = None​    def insertLeft(self, value):        self.left = BinaryTreeNode(value)        return self.left​    def insertRight(self, value):        self.right = BinaryTreeNode(value)        return self.right​​root = BinaryTreeNode(5)print(checkBalanced(root))  # should print True​root.insertLeft(10)print(checkBalanced(root))  # should print False​root.insertRight(11)print(checkBalanced(root))  # should print True​

<span class="text-4505230f--HeadingH700-04e1a2a3--textContentFamily-49a318e1"><span data-key="53464c8446bd4138ab15fd1408dc6db2"><span data-offset-key="53464c8446bd4138ab15fd1408dc6db2:0">Binary Search Tree from Sorted Array</span></span></span>

<span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="a1382002b8944909b466a965cad208b7"><span data-offset-key="a1382002b8944909b466a965cad208b7:0">Given an array that is sorted in ascending order containing unique integer elements, write a function that receives the sorted array as input and creates a valid binary search tree with minimal height.</span></span></span>

<span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="4b98a79e29de4ce79f4790376339e505"><span data-offset-key="4b98a79e29de4ce79f4790376339e505:0">For example, given an array </span><span data-offset-key="4b98a79e29de4ce79f4790376339e505:1">`[1, 2, 3, 4, 5, 6, 7]`</span><span data-offset-key="4b98a79e29de4ce79f4790376339e505:2">, your function should return a binary search tree with the form</span></span></span>

                              4                        /   \                      2       6                     / \     / \                    1   3   5   7

<span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="5fce30fbcfbb4770a4fae0bb9dfe847b"><span data-offset-key="5fce30fbcfbb4770a4fae0bb9dfe847b:0">Note that when we say "binary search tree" in this case, we're just talking about a tree that exhibits the expected </span><span data-offset-key="5fce30fbcfbb4770a4fae0bb9dfe847b:1">*form*</span><span data-offset-key="5fce30fbcfbb4770a4fae0bb9dfe847b:2"> of a binary search tree. The tree in this case won't have an </span><span data-offset-key="5fce30fbcfbb4770a4fae0bb9dfe847b:3">`insert`</span><span data-offset-key="5fce30fbcfbb4770a4fae0bb9dfe847b:4"> method that does the work of receiving a value and then inserting it in a valid spot in the binary search tree. Your function should place the values in valid spots that adhere to the rules of binary search trees, while also seeking to minimize the overall height of the tree.</span></span></span>

<span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="70f63fa0b42140759f193e36ba3d0c3c"><span data-offset-key="70f63fa0b42140759f193e36ba3d0c3c:0">Here's a </span><span data-offset-key="70f63fa0b42140759f193e36ba3d0c3c:1">`BinaryTreeNode`</span><span data-offset-key="70f63fa0b42140759f193e36ba3d0c3c:2"> class that you can use to construct a binary search tree:</span></span></span>

    class BinaryTreeNode:  def __init__(self, value):    self.value = value    self.left = None    self.right = None

<span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="0e4890ce6280440082ce04ed2f16644d"><span data-offset-key="0e4890ce6280440082ce04ed2f16644d:0">Analyze the time and space complexity of your solution.</span></span></span>

<span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="e79c82ed44914f56a12126a9ca803ae8"><span data-offset-key="e79c82ed44914f56a12126a9ca803ae8:0"><span data-slate-zero-width="n">​</span></span></span></span>

<span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="354c9b732c474b99b9bfd20ada05ca1c"><span data-offset-key="354c9b732c474b99b9bfd20ada05ca1c:0"><span data-slate-zero-width="n">​</span></span></span></span>

<span class="text-4505230f--HeadingH700-04e1a2a3--textContentFamily-49a318e1"><span data-key="d45ccea820a041c0bc9ea4f6c95afdf1"><span data-offset-key="d45ccea820a041c0bc9ea4f6c95afdf1:0">Create a Minimal Height BST from Sorted Array</span></span></span>

<span class="text-4505230f--HeadingH600-23f228db--textContentFamily-49a318e1"><span data-key="c88eb193306a42e09c41efc437cb3598"><span data-offset-key="c88eb193306a42e09c41efc437cb3598:0">Understanding the Problem</span></span></span>

<span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="f5af8b8d80ed46e98643662f60f5d399"><span data-offset-key="f5af8b8d80ed46e98643662f60f5d399:0">This problem asks us to create a valid binary search tree from a sorted array of integers. More specifically, the resulting binary search tree needs to be of </span><span data-offset-key="f5af8b8d80ed46e98643662f60f5d399:1">*minimal height*</span><span data-offset-key="f5af8b8d80ed46e98643662f60f5d399:2">. Our function should return the root node of the created binary search tree.</span></span></span>

<span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="b34ca874e583498c89c7a442fbd43acb"><span data-offset-key="b34ca874e583498c89c7a442fbd43acb:0">From the given example where the input is </span><span data-offset-key="b34ca874e583498c89c7a442fbd43acb:1">`[1, 2, 3, 4, 5, 6, 7]`</span><span data-offset-key="b34ca874e583498c89c7a442fbd43acb:2">, the expected answer is a binary search tree of height 3. This is the minimal height that can be achieved for an array of 7 seven elements. Try as we might, there's no way to construct a binary search tree containing all of these elements that has a shorter height.</span></span></span>

<span class="text-4505230f--HeadingH600-23f228db--textContentFamily-49a318e1"><span data-key="0068e4263efe4e9685ba923db9659b25"><span data-offset-key="0068e4263efe4e9685ba923db9659b25:0">Coming Up with a First Pass</span></span></span>

<span class="text-4505230f--TextH400-3033861f--textContentFamily-49a318e1"><span data-key="8cd5eef780994f2598caa09fb4c710c0"><span data-offset-key="8cd5eef780994f2598caa09fb4c710c0:0">A straightforward way to do this would be to take the first element of our array, call that the root, and then iterate through the rest of our array, adding those elements as nodes in the binary search tree. In pseudocode, that might look something like this:</span></span></span>

    def create_min_height_bst(sorted_arr):  root = BinaryTreeNode(sorted_arr[0])​  for elem in sorted_arr:    root.insert(elem)​  return root  

    function createMinHeightBST(sortedArray) {  const left = 0;  const right = sortedArray.length - 1;​  return recHelper(sortedArray, left, right);}​function recHelper(sortedArray, left, right) {  if (left > right) {    return null;  }​  const midpoint = math.floor(right - left) / 2 + left;  const root = new BinaryTreeNode(sortedArray[midpoint]);​  root.left = recHelper(sortedArray, left, midpoint - 1);  root.right = recHelper(sortedArray, midpoint + 1, right);​  return root;}​class BinaryTreeNode {  constructor(value) {    this.value = value;    this.left = null;    this.right = null;  }}​function isBST(root, minBound, maxBound) {  if (root === null) {    return true;  }​  if (root.value < minBound || root.value > maxBound) {    return false;  }​  const left = isBST(root.left, minBound, root.value - 1);  const right = isBST(root.right, root.value + 1, maxBound);​  return left && right;}​function findBSTMaxHeight(node) {  if (node === null) {    return 0;  }​  return (    1 + Math.max(findBSTMaxHeight(node.left), findBSTMaxHeight(node.right))  );}​function isBSTMinHeight(root, N) {  const height = findBSTMaxHeight(root);  const shouldEqual = Math.floor(Math.log2(N)) + 1;​  return height === shouldEqual;}​function countBSTNodes(root, count) {  if (root === null) {    return count;  }​  countBSTNodes(root.left, count);  count++;  countBSTNodes(root.right, count);}​// Some testslet sortedArray = [1, 2, 3, 4, 5, 6, 7];let bst = createMinHeightBST(sortedArray);​console.log(isBST(bst, -Infinity, Infinity));console.log(isBSTMinHeight(bst, sortedArray.length));​sortedArray = [4, 10, 11, 18, 42, 43, 47, 49, 55, 67, 79, 89, 90, 95, 98, 100];bst = createMinHeightBST(sortedArray);​console.log(isBST(bst, -Infinity, Infinity));console.log(isBSTMinHeight(bst, sortedArray.length));​

    import math​​def create_min_height_bst(sorted_array):    left = 0    right = len(sorted_array) - 1​    return rec_helper(sorted_array, left, right)​​def rec_helper(sorted_array, left, right):    if left > right:        return None​    midpoint = ((right - left) // 2) + left    root = BinaryTreeNode(sorted_array[midpoint])​    root.left = rec_helper(sorted_array, left, midpoint - 1)    root.right = rec_helper(sorted_array, midpoint + 1, right)​    return root​​class BinaryTreeNode:    def __init__(self, value):        self.value = value        self.left = None        self.right = None​​# Helper function to validate that the created tree is a valid BSTdef is_BST(root, min_bound, max_bound):    if root is None:        return True​    if root.value < min_bound or root.value > max_bound:        return False​    left = is_BST(root.left, min_bound, root.value - 1)    right = is_BST(root.right, root.value + 1, max_bound)​    return left and right​​# Helper function to check the max height of a BSTdef find_bst_max_height(node):    if node is None:        return 0​    return 1 + max(find_bst_max_height(node.left), find_bst_max_height(node.right))​​# Helper function to validate that the given BST exhibits the min heightdef is_bst_min_height(root, N):    bst_max_height = find_bst_max_height(root)    should_equal = math.floor(math.log2(N)) + 1​    return bst_max_height == should_equal​​# Helper function to count the number of nodes for a given BSTdef count_bst_nodes(root, count):    if root is None:        return count​    count_bst_nodes(root.left, count)    count += 1    count_bst_nodes(root.right, count)​​# Some testssorted_array = [1, 2, 3, 4, 5, 6, 7]bst = create_min_height_bst(sorted_array)​print(is_BST(bst, float("-inf"), float("inf")))  # should print trueprint(is_bst_min_height(bst, len(sorted_array)))  # should print true​sorted_array = [4, 10, 11, 18, 42, 43, 47, 49, 55, 67, 79, 89, 90, 95, 98, 100]bst = create_min_height_bst(sorted_array)​print(is_BST(bst, float("-inf"), float("inf")))  # should print trueprint(is_bst_min_height(bst, len(sorted_array)))  # should print true​

<span class="text-4505230f--HeadingH700-04e1a2a3--textContentFamily-49a318e1"><span data-key="3143b326cb5b4d2383d00ba5fb91fe06"><span data-offset-key="3143b326cb5b4d2383d00ba5fb91fe06:0">Another BST Implementation:</span></span></span>

    class BinarySearchTree:  def __init__(self, value):    self.value = value    self.left = None    self.right = None​  def insert(self, value):    pass​  def contains(self, target):    pass​  def get_max(self):    pass​  def for_each(self, cb):    pass​

    import unittestimport randomfrom binary_search_tree import BinarySearchTree​class BinarySearchTreeTests(unittest.TestCase):  def setUp(self):    self.bst = BinarySearchTree(5)​  def test_insert(self):    self.bst.insert(2)    self.bst.insert(3)    self.bst.insert(7)    self.bst.insert(6)    self.assertEqual(self.bst.left.right.value, 3)    self.assertEqual(self.bst.right.left.value, 6)​  def test_contains(self):    self.bst.insert(2)    self.bst.insert(3)    self.bst.insert(7)    self.assertTrue(self.bst.contains(7))    self.assertFalse(self.bst.contains(8))​  def test_get_max(self):    self.assertEqual(self.bst.get_max(), 5)    self.bst.insert(30)    self.assertEqual(self.bst.get_max(), 30)    self.bst.insert(300)    self.bst.insert(3)    self.assertEqual(self.bst.get_max(), 300)​  def test_for_each(self):    arr = []    cb = lambda x: arr.append(x)​    v1 = random.randint(1, 101)    v2 = random.randint(1, 101)    v3 = random.randint(1, 101)    v4 = random.randint(1, 101)    v5 = random.randint(1, 101)​    self.bst.insert(v1)    self.bst.insert(v2)    self.bst.insert(v3)    self.bst.insert(v4)    self.bst.insert(v5)​    self.bst.for_each(cb)​    self.assertTrue(5 in arr)    self.assertTrue(v1 in arr)    self.assertTrue(v2 in arr)    self.assertTrue(v3 in arr)    self.assertTrue(v4 in arr)    self.assertTrue(v5 in arr)​​if __name__ == '__main__':  unittest.main()​

<a href="binary-search-tree/bst-insert.html" class="reset-3c756112--card-6570f064--whiteCard-fff091a4--cardPrevious-56a5e674"></a>

<span class="text-4505230f--TextH200-a3425406--textContentFamily-49a318e1">Previous</span>

<span class="text-4505230f--UIH400-4e41e82a--textContentFamily-49a318e1">BST Insert</span>

<a href="../../abstract-data-structures/untitled-1/tree/binary-tree/binary-tree-explained.html" class="reset-3c756112--card-6570f064--whiteCard-fff091a4--cardNext-19241c42"></a>

<span class="text-4505230f--TextH200-a3425406--textContentFamily-49a318e1">Next</span>

<span class="text-4505230f--UIH400-4e41e82a--textContentFamily-49a318e1">Binary Tree Explained</span>

<img src="https://avatars.githubusercontent.com/u/66654881?v=4" class="image-67b14f24--avatar-1c1d03ec" />

<span class="text-4505230f--TextH200-a3425406--textContentFamily-49a318e1">Last updated 2 hours ago</span>

<a href="https://github.com/bgoonz/python-gitbook/blob/master/abstract-data-structures/untitled-1/tree/binary-tree/README.md" class="reset-3c756112--menuItem-aa02f6ec--menuItemLight-757d5235--menuItemInline-173bdf97--pageSideMenuItem-22949732"></a>

<span class="text-4505230f--UIH300-2063425d--textUIFamily-5ebd8e40">Edit on GitHub</span>

<span class="text-4505230f--UIH300-2063425d--textUIFamily-5ebd8e40">Export as PDF</span>

<span class="text-4505230f--InfoH100-1e92e1d1--textContentFamily-49a318e1">Contents</span>

<a href="binary-tree.html#binary-trees" class="reset-3c756112--menuItem-aa02f6ec--menuItemLight-757d5235--menuItemInline-173bdf97--pageTocItem-f4427024"></a>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1"><span class="text-4505230f--UIH200-50ead35f--textContentFamily-49a318e1--pageTocLinkH2-2294976c">Binary Trees</span></span>

<a href="binary-tree.html#balanced-binary-tree" class="reset-3c756112--menuItem-aa02f6ec--menuItemLight-757d5235--menuItemInline-173bdf97--pageTocItem-f4427024"></a>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1"><span class="text-4505230f--UIH200-50ead35f--textContentFamily-49a318e1">Balanced Binary Tree</span></span>

<a href="binary-tree.html#balanced-binary-tree-1" class="reset-3c756112--menuItem-aa02f6ec--menuItemLight-757d5235--menuItemInline-173bdf97--pageTocItem-f4427024"></a>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1"><span class="text-4505230f--UIH200-50ead35f--textContentFamily-49a318e1">Balanced Binary Tree</span></span>

<a href="binary-tree.html#binary-search-tree-from-sorted-array" class="reset-3c756112--menuItem-aa02f6ec--menuItemLight-757d5235--menuItemInline-173bdf97--pageTocItem-f4427024"></a>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1"><span class="text-4505230f--UIH200-50ead35f--textContentFamily-49a318e1">Binary Search Tree from Sorted Array</span></span>

<a href="binary-tree.html#create-a-minimal-height-bst-from-sorted-array" class="reset-3c756112--menuItem-aa02f6ec--menuItemLight-757d5235--menuItemInline-173bdf97--pageTocItem-f4427024"></a>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1"><span class="text-4505230f--UIH200-50ead35f--textContentFamily-49a318e1">Create a Minimal Height BST from Sorted Array</span></span>

<a href="binary-tree.html#understanding-the-problem" class="reset-3c756112--menuItem-aa02f6ec--menuItemLight-757d5235--menuItemInline-173bdf97--pageTocItem-f4427024"></a>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1"><span class="text-4505230f--UIH200-50ead35f--textContentFamily-49a318e1--pageTocLinkH2-2294976c">Understanding the Problem</span></span>

<a href="binary-tree.html#coming-up-with-a-first-pass" class="reset-3c756112--menuItem-aa02f6ec--menuItemLight-757d5235--menuItemInline-173bdf97--pageTocItem-f4427024"></a>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1"><span class="text-4505230f--UIH200-50ead35f--textContentFamily-49a318e1--pageTocLinkH2-2294976c">Coming Up with a First Pass</span></span>

<a href="binary-tree.html#another-bst-implementation" class="reset-3c756112--menuItem-aa02f6ec--menuItemLight-757d5235--menuItemInline-173bdf97--pageTocItem-f4427024"></a>

<span class="text-4505230f--UIH300-2063425d--textContentFamily-49a318e1"><span class="text-4505230f--UIH200-50ead35f--textContentFamily-49a318e1">Another BST Implementation:</span></span>
