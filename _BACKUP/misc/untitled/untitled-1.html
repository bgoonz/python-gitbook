<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>untitled-1</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
    <style type="text/css">
      a.sourceLine {
        display: inline-block;
        line-height: 1.25;
      }
      a.sourceLine {
        pointer-events: none;
        color: inherit;
        text-decoration: inherit;
      }
      a.sourceLine:empty {
        height: 1.2em;
      }
      .sourceCode {
        overflow: visible;
      }
      code.sourceCode {
        white-space: pre;
        position: relative;
      }
      div.sourceCode {
        margin: 1em 0;
      }
      pre.sourceCode {
        margin: 0;
      }
      @media screen {
        div.sourceCode {
          overflow: auto;
        }
      }
      @media print {
        code.sourceCode {
          white-space: pre-wrap;
        }
        a.sourceLine {
          text-indent: -1em;
          padding-left: 1em;
        }
      }
      pre.numberSource a.sourceLine {
        position: relative;
        left: -4em;
      }
      pre.numberSource a.sourceLine::before {
        content: attr(title);
        position: relative;
        left: -1em;
        text-align: right;
        vertical-align: baseline;
        border: none;
        pointer-events: all;
        display: inline-block;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        padding: 0 4px;
        width: 4em;
        color: #aaaaaa;
      }
      pre.numberSource {
        margin-left: 3em;
        border-left: 1px solid #aaaaaa;
        padding-left: 4px;
      }
      div.sourceCode {
      }
      @media screen {
        a.sourceLine::before {
          text-decoration: underline;
        }
      }
      code span.al {
        color: #ff0000;
        font-weight: bold;
      } /* Alert */
      code span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Annotation */
      code span.at {
        color: #7d9029;
      } /* Attribute */
      code span.bn {
        color: #40a070;
      } /* BaseN */
      code span.bu {
      } /* BuiltIn */
      code span.cf {
        color: #007020;
        font-weight: bold;
      } /* ControlFlow */
      code span.ch {
        color: #4070a0;
      } /* Char */
      code span.cn {
        color: #880000;
      } /* Constant */
      code span.co {
        color: #60a0b0;
        font-style: italic;
      } /* Comment */
      code span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* CommentVar */
      code span.do {
        color: #ba2121;
        font-style: italic;
      } /* Documentation */
      code span.dt {
        color: #902000;
      } /* DataType */
      code span.dv {
        color: #40a070;
      } /* DecVal */
      code span.er {
        color: #ff0000;
        font-weight: bold;
      } /* Error */
      code span.ex {
      } /* Extension */
      code span.fl {
        color: #40a070;
      } /* Float */
      code span.fu {
        color: #06287e;
      } /* Function */
      code span.im {
      } /* Import */
      code span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Information */
      code span.kw {
        color: #007020;
        font-weight: bold;
      } /* Keyword */
      code span.op {
        color: #666666;
      } /* Operator */
      code span.ot {
        color: #007020;
      } /* Other */
      code span.pp {
        color: #bc7a00;
      } /* Preprocessor */
      code span.sc {
        color: #4070a0;
      } /* SpecialChar */
      code span.ss {
        color: #bb6688;
      } /* SpecialString */
      code span.st {
        color: #4070a0;
      } /* String */
      code span.va {
        color: #19177c;
      } /* Variable */
      code span.vs {
        color: #4070a0;
      } /* VerbatimString */
      code span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Warning */
    </style>
  </head>
  <body>
    <h1 id="python-modules-python-packages">
      Python Modules &amp; Python Packages
    </h1>
    <p>
      This article explores Python <strong>modules</strong> and Python
      <strong>packages</strong>, two mechanisms that facilitate
      <strong>modular programming</strong>.
    </p>
    <p>
      <strong>Modular programming</strong> refers to the process of breaking a
      large, unwieldy programming task into separate, smaller, more manageable
      subtasks or <strong>modules</strong>. Individual modules can then be
      cobbled together like building blocks to create a larger application.
    </p>
    <p>
      There are several advantages to <strong>modularizing</strong> code in a
      large application:
    </p>
    <ul>
      <li>
        <strong>Simplicity:</strong> Rather than focusing on the entire problem
        at hand, a module typically focuses on one relatively small portion of
        the problem. If you’re working on a single module, you’ll have a smaller
        problem domain to wrap your head around. This makes development easier
        and less error-prone.
      </li>
      <li>
        <strong>Maintainability:</strong> Modules are typically designed so that
        they enforce logical boundaries between different problem domains. If
        modules are written in a way that minimizes interdependency, there is
        decreased likelihood that modifications to a single module will have an
        impact on other parts of the program. (You may even be able to make
        changes to a module without having any knowledge of the application
        outside that module.) This makes it more viable for a team of many
        programmers to work collaboratively on a large application.
      </li>
      <li>
        <strong>Reusability:</strong> Functionality defined in a single module
        can be easily reused (through an appropriately defined interface) by
        other parts of the application. This eliminates the need to duplicate
        code.
      </li>
      <li>
        <strong>Scoping:</strong> Modules typically define a separate
        <a href="https://realpython.com/python-namespaces-scope/"
          ><strong>namespace</strong></a
        >, which helps avoid collisions between identifiers in different areas
        of a program. (One of the tenets in the
        <a href="https://www.python.org/dev/peps/pep-0020">Zen of Python</a> is
        <em>Namespaces are one honking great idea—let’s do more of those!</em>)
      </li>
    </ul>
    <p>
      <strong>Functions</strong>, <strong>modules</strong> and
      <strong>packages</strong> are all constructs in Python that promote code
      modularization.
    </p>
    <p>
      <strong>Free PDF Download:</strong>
      <a href="https://realpython.com/bonus/python-cheat-sheet-short/"
        >Python 3 Cheat Sheet</a
      >
    </p>
    <h3 id="python-modules-overview">Python Modules: Overview</h3>
    <p>
      There are actually three different ways to define a
      <strong>module</strong> in Python:
    </p>
    <ol type="1">
      <li>A module can be written in Python itself.</li>
      <li>
        A module can be written in <strong>C</strong> and loaded dynamically at
        run-time, like the <code>re</code> (<a
          href="https://realpython.com/regex-python/"
          ><strong>regular expression</strong></a
        >) module.
      </li>
      <li>
        A <strong>built-in</strong> module is intrinsically contained in the
        interpreter, like the
        <a href="https://realpython.com/python-itertools/"
          ><code>itertools</code> module</a
        >.
      </li>
    </ol>
    <p>
      A module’s contents are accessed the same way in all three cases: with the
      <code>import</code> statement.
    </p>
    <p>
      Here, the focus will mostly be on modules that are written in Python. The
      cool thing about modules written in Python is that they are exceedingly
      straightforward to build. All you need to do is create a file that
      contains legitimate Python code and then give the file a name with a
      <code>.py</code> extension. That’s it! No special syntax or voodoo is
      necessary.
    </p>
    <p>
      For example, suppose you have created a file called
      <code>mod.py</code> containing the following:
    </p>
    <p>
      <em><strong>mod.py</strong></em>
    </p>
    <div class="sourceCode" id="cb1">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1">s <span class="op">=</span> <span class="st">&quot;If Comrade Napoleon says it, it must be right.&quot;</span></a>
<a class="sourceLine" id="cb1-2" title="2">a <span class="op">=</span> [<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">300</span>]</a>
<a class="sourceLine" id="cb1-3" title="3"></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">def</span> foo(arg):</a>
<a class="sourceLine" id="cb1-5" title="5">    <span class="bu">print</span>(<span class="ss">f&#39;arg = </span><span class="sc">{</span>arg<span class="sc">}</span><span class="ss">&#39;</span>)</a>
<a class="sourceLine" id="cb1-6" title="6"></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="kw">class</span> Foo:</a>
<a class="sourceLine" id="cb1-8" title="8">    <span class="cf">pass</span></a></code></pre>
    </div>
    <p>Several objects are defined in <code>mod.py</code>:</p>
    <ul>
      <li><code>s</code> (a string)</li>
      <li><code>a</code> (a list)</li>
      <li><code>foo()</code> (a function)</li>
      <li><code>Foo</code> (a class)</li>
    </ul>
    <p>
      Assuming <code>mod.py</code> is in an appropriate location, which you will
      learn more about shortly, these objects can be accessed by
      <strong>importing</strong> the module as follows:&gt;&gt;&gt;
    </p>
    <div class="sourceCode" id="cb2">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> mod</a>
<a class="sourceLine" id="cb2-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="bu">print</span>(mod.s)</a>
<a class="sourceLine" id="cb2-3" title="3">If Comrade Napoleon says it, it must be right.</a>
<a class="sourceLine" id="cb2-4" title="4"><span class="op">&gt;&gt;&gt;</span> mod.a</a>
<a class="sourceLine" id="cb2-5" title="5">[<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">300</span>]</a>
<a class="sourceLine" id="cb2-6" title="6"><span class="op">&gt;&gt;&gt;</span> mod.foo([<span class="st">&#39;quux&#39;</span>, <span class="st">&#39;corge&#39;</span>, <span class="st">&#39;grault&#39;</span>])</a>
<a class="sourceLine" id="cb2-7" title="7">arg <span class="op">=</span> [<span class="st">&#39;quux&#39;</span>, <span class="st">&#39;corge&#39;</span>, <span class="st">&#39;grault&#39;</span>]</a>
<a class="sourceLine" id="cb2-8" title="8"><span class="op">&gt;&gt;&gt;</span> x <span class="op">=</span> mod.Foo()</a>
<a class="sourceLine" id="cb2-9" title="9"><span class="op">&gt;&gt;&gt;</span> x</a>
<a class="sourceLine" id="cb2-10" title="10"><span class="op">&lt;</span>mod.Foo <span class="bu">object</span> at <span class="bn">0x03C181F0</span><span class="op">&gt;</span></a></code></pre>
    </div>
    <p>
      <a
        href="https://srv.realpython.net/click/21785147887/?c=59166930991&amp;p=58946116052&amp;r=96792"
        ><img
          src="https://img.realpython.net/985664a6516083df6deee129c0591bfb" /></a
      ><a href="https://realpython.com/account/join/">Remove ads</a>
    </p>
    <h3 id="the-module-search-path">The Module Search Path</h3>
    <p>
      Continuing with the above example, let’s take a look at what happens when
      Python executes the statement:
    </p>
    <div class="sourceCode" id="cb3">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1"><span class="im">import</span> mod</a></code></pre>
    </div>
    <p>
      When the interpreter executes the above <code>import</code> statement, it
      searches for <code>mod.py</code> in a
      <a href="https://realpython.com/python-lists-tuples/">list</a> of
      directories assembled from the following sources:
    </p>
    <ul>
      <li>
        The directory from which the input script was run or the
        <strong>current directory</strong> if the interpreter is being run
        interactively
      </li>
      <li>
        The list of directories contained in the
        <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH"
          ><code>PYTHONPATH</code></a
        >
        environment variable, if it is set. (The format for
        <code>PYTHONPATH</code> is OS-dependent but should mimic the
        <code>PATH</code> environment variable.)
      </li>
      <li>
        An installation-dependent list of directories configured at the time
        Python is installed
      </li>
    </ul>
    <p>
      The resulting search path is accessible in the Python variable
      <code>sys.path</code>, which is obtained from a module named
      <code>sys</code>:&gt;&gt;&gt;
    </p>
    <div class="sourceCode" id="cb4">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> sys</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="op">&gt;&gt;&gt;</span> sys.path</a>
<a class="sourceLine" id="cb4-3" title="3">[<span class="st">&#39;&#39;</span>, <span class="st">&#39;C:</span><span class="ch">\\</span><span class="st">Users</span><span class="ch">\\</span><span class="st">john</span><span class="ch">\\</span><span class="st">Documents</span><span class="ch">\\</span><span class="st">Python</span><span class="ch">\\</span><span class="st">doc&#39;</span>, <span class="st">&#39;C:</span><span class="ch">\\</span><span class="st">Python36</span><span class="ch">\\</span><span class="st">Lib</span><span class="ch">\\</span><span class="st">idlelib&#39;</span>,</a>
<a class="sourceLine" id="cb4-4" title="4"><span class="st">&#39;C:</span><span class="ch">\\</span><span class="st">Python36</span><span class="ch">\\</span><span class="st">python36.zip&#39;</span>, <span class="st">&#39;C:</span><span class="ch">\\</span><span class="st">Python36</span><span class="ch">\\</span><span class="st">DLLs&#39;</span>, <span class="st">&#39;C:</span><span class="ch">\\</span><span class="st">Python36</span><span class="ch">\\</span><span class="st">lib&#39;</span>,</a>
<a class="sourceLine" id="cb4-5" title="5"><span class="st">&#39;C:</span><span class="ch">\\</span><span class="st">Python36&#39;</span>, <span class="st">&#39;C:</span><span class="ch">\\</span><span class="st">Python36</span><span class="ch">\\</span><span class="st">lib</span><span class="ch">\\</span><span class="st">site-packages&#39;</span>]</a></code></pre>
    </div>
    <p>
      <strong>Note:</strong> The exact contents of <code>sys.path</code> are
      installation-dependent. The above will almost certainly look slightly
      different on your computer.
    </p>
    <p>
      Thus, to ensure your module is found, you need to do one of the following:
    </p>
    <ul>
      <li>
        Put <code>mod.py</code> in the directory where the input script is
        located or the <strong>current directory</strong>, if interactive
      </li>
      <li>
        Modify the <code>PYTHONPATH</code> environment variable to contain the
        directory where <code>mod.py</code> is located before starting the
        interpreter
        <ul>
          <li>
            <strong>Or:</strong> Put <code>mod.py</code> in one of the
            directories already contained in the
            <code>PYTHONPATH</code> variable
          </li>
        </ul>
      </li>
      <li>
        Put <code>mod.py</code> in one of the installation-dependent
        directories, which you may or may not have write-access to, depending on
        the OS
      </li>
    </ul>
    <p>
      There is actually one additional option: you can put the module file in
      any directory of your choice and then modify <code>sys.path</code> at
      run-time so that it contains that directory. For example, in this case,
      you could put <code>mod.py</code> in directory
      <code>C:\Users\john</code> and then issue the following
      statements:&gt;&gt;&gt;
    </p>
    <div class="sourceCode" id="cb5">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb5-1" title="1"><span class="op">&gt;&gt;&gt;</span> sys.path.append(<span class="vs">r&#39;C:\Users\john&#39;</span>)</a>
<a class="sourceLine" id="cb5-2" title="2"><span class="op">&gt;&gt;&gt;</span> sys.path</a>
<a class="sourceLine" id="cb5-3" title="3">[<span class="st">&#39;&#39;</span>, <span class="st">&#39;C:</span><span class="ch">\\</span><span class="st">Users</span><span class="ch">\\</span><span class="st">john</span><span class="ch">\\</span><span class="st">Documents</span><span class="ch">\\</span><span class="st">Python</span><span class="ch">\\</span><span class="st">doc&#39;</span>, <span class="st">&#39;C:</span><span class="ch">\\</span><span class="st">Python36</span><span class="ch">\\</span><span class="st">Lib</span><span class="ch">\\</span><span class="st">idlelib&#39;</span>,</a>
<a class="sourceLine" id="cb5-4" title="4"><span class="st">&#39;C:</span><span class="ch">\\</span><span class="st">Python36</span><span class="ch">\\</span><span class="st">python36.zip&#39;</span>, <span class="st">&#39;C:</span><span class="ch">\\</span><span class="st">Python36</span><span class="ch">\\</span><span class="st">DLLs&#39;</span>, <span class="st">&#39;C:</span><span class="ch">\\</span><span class="st">Python36</span><span class="ch">\\</span><span class="st">lib&#39;</span>,</a>
<a class="sourceLine" id="cb5-5" title="5"><span class="st">&#39;C:</span><span class="ch">\\</span><span class="st">Python36&#39;</span>, <span class="st">&#39;C:</span><span class="ch">\\</span><span class="st">Python36</span><span class="ch">\\</span><span class="st">lib</span><span class="ch">\\</span><span class="st">site-packages&#39;</span>, <span class="st">&#39;C:</span><span class="ch">\\</span><span class="st">Users</span><span class="ch">\\</span><span class="st">john&#39;</span>]</a>
<a class="sourceLine" id="cb5-6" title="6"><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> mod</a></code></pre>
    </div>
    <p>
      Once a module has been imported, you can determine the location where it
      was found with the module’s <code>__file__</code> attribute:&gt;&gt;&gt;
    </p>
    <div class="sourceCode" id="cb6">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb6-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> mod</a>
<a class="sourceLine" id="cb6-2" title="2"><span class="op">&gt;&gt;&gt;</span> mod.<span class="va">__file__</span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="co">&#39;C:</span><span class="ch">\\</span><span class="co">Users</span><span class="ch">\\</span><span class="co">john</span><span class="ch">\\</span><span class="co">mod.py&#39;</span></a>
<a class="sourceLine" id="cb6-4" title="4"></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> re</a>
<a class="sourceLine" id="cb6-6" title="6"><span class="op">&gt;&gt;&gt;</span> re.<span class="va">__file__</span></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="co">&#39;C:</span><span class="ch">\\</span><span class="co">Python36</span><span class="ch">\\</span><span class="co">lib</span><span class="ch">\\</span><span class="co">re.py&#39;</span></a></code></pre>
    </div>
    <p>
      The directory portion of <code>__file__</code> should be one of the
      directories in <code>sys.path</code>.
    </p>
    <h3 id="the-import-statement">The <code>import</code> Statement</h3>
    <p>
      <strong>Module</strong> contents are made available to the caller with the
      <code>import</code> statement. The <code>import</code> statement takes
      many different forms, shown below.
    </p>
    <h4 id="import-module_name"><code>import &lt;module_name&gt;</code></h4>
    <p>The simplest form is the one already shown above:</p>
    <div class="sourceCode" id="cb7">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb7-1" title="1"><span class="im">import</span> <span class="op">&lt;</span>module_name<span class="op">&gt;</span></a></code></pre>
    </div>
    <p>
      Note that this <em>does not</em> make the module contents
      <em>directly</em> accessible to the caller. Each module has its own
      <strong>private symbol table</strong>, which serves as the global symbol
      table for all objects defined <em>in the module</em>. Thus, a module
      creates a separate <strong>namespace</strong>, as already noted.
    </p>
    <p>
      The statement <code>import &lt;module_name&gt;</code> only places
      <code>&lt;module_name&gt;</code> in the caller’s symbol table. The
      <em>objects</em> that are defined in the module
      <em>remain in the module’s private symbol table</em>.
    </p>
    <p>
      From the caller, objects in the module are only accessible when prefixed
      with <code>&lt;module_name&gt;</code> via <strong>dot notation</strong>,
      as illustrated below.
    </p>
    <p>
      After the following <code>import</code> statement, <code>mod</code> is
      placed into the local symbol table. Thus, <code>mod</code> has meaning in
      the caller’s local context:&gt;&gt;&gt;
    </p>
    <div class="sourceCode" id="cb8">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb8-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> mod</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="op">&gt;&gt;&gt;</span> mod</a>
<a class="sourceLine" id="cb8-3" title="3"><span class="op">&lt;</span>module <span class="st">&#39;mod&#39;</span> <span class="im">from</span> <span class="st">&#39;C:</span><span class="ch">\\</span><span class="st">Users</span><span class="ch">\\</span><span class="st">john</span><span class="ch">\\</span><span class="st">Documents</span><span class="ch">\\</span><span class="st">Python</span><span class="ch">\\</span><span class="st">doc</span><span class="ch">\\</span><span class="st">mod.py&#39;</span><span class="op">&gt;</span></a></code></pre>
    </div>
    <p>
      But <code>s</code> and <code>foo</code> remain in the module’s private
      symbol table and are not meaningful in the local context:&gt;&gt;&gt;
    </p>
    <div class="sourceCode" id="cb9">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb9-1" title="1"><span class="op">&gt;&gt;&gt;</span> s</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="pp">NameError</span>: name <span class="st">&#39;s&#39;</span> <span class="kw">is</span> <span class="kw">not</span> defined</a>
<a class="sourceLine" id="cb9-3" title="3"><span class="op">&gt;&gt;&gt;</span> foo(<span class="st">&#39;quux&#39;</span>)</a>
<a class="sourceLine" id="cb9-4" title="4"><span class="pp">NameError</span>: name <span class="st">&#39;foo&#39;</span> <span class="kw">is</span> <span class="kw">not</span> defined</a></code></pre>
    </div>
    <p>
      To be accessed in the local context, names of objects defined in the
      module must be prefixed by <code>mod</code>:&gt;&gt;&gt;
    </p>
    <div class="sourceCode" id="cb10">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb10-1" title="1"><span class="op">&gt;&gt;&gt;</span> mod.s</a>
<a class="sourceLine" id="cb10-2" title="2"><span class="co">&#39;If Comrade Napoleon says it, it must be right.&#39;</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="op">&gt;&gt;&gt;</span> mod.foo(<span class="st">&#39;quux&#39;</span>)</a>
<a class="sourceLine" id="cb10-4" title="4">arg <span class="op">=</span> quux</a></code></pre>
    </div>
    <p>
      Several comma-separated modules may be specified in a single
      <code>import</code> statement:
    </p>
    <div class="sourceCode" id="cb11">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb11-1" title="1"><span class="im">import</span> <span class="op">&lt;</span>module_name<span class="op">&gt;</span>[, <span class="op">&lt;</span>module_name<span class="op">&gt;</span> ...]</a></code></pre>
    </div>
    <p>
      <a
        href="https://srv.realpython.net/click/17294013797/?c=37584728541&amp;p=58946116052&amp;r=36663"
        ><img
          src="https://img.realpython.net/ebb4fba61c1032b36fd97b803225bc8f" /></a
      ><a href="https://realpython.com/account/join/">Remove ads</a>
    </p>
    <h4 id="from-module_name-import-names">
      <code>from &lt;module_name&gt; import &lt;name(s)&gt;</code>
    </h4>
    <p>
      An alternate form of the <code>import</code> statement allows individual
      objects from the module to be imported
      <em>directly into the caller’s symbol table</em>:
    </p>
    <div class="sourceCode" id="cb12">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb12-1" title="1"><span class="im">from</span> <span class="op">&lt;</span>module_name<span class="op">&gt;</span> <span class="im">import</span> <span class="op">&lt;</span>name(s)<span class="op">&gt;</span></a></code></pre>
    </div>
    <p>
      Following execution of the above statement,
      <code>&lt;name(s)&gt;</code> can be referenced in the caller’s environment
      without the <code>&lt;module_name&gt;</code> prefix:&gt;&gt;&gt;
    </p>
    <div class="sourceCode" id="cb13">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb13-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="im">from</span> mod <span class="im">import</span> s, foo</a>
<a class="sourceLine" id="cb13-2" title="2"><span class="op">&gt;&gt;&gt;</span> s</a>
<a class="sourceLine" id="cb13-3" title="3"><span class="co">&#39;If Comrade Napoleon says it, it must be right.&#39;</span></a>
<a class="sourceLine" id="cb13-4" title="4"><span class="op">&gt;&gt;&gt;</span> foo(<span class="st">&#39;quux&#39;</span>)</a>
<a class="sourceLine" id="cb13-5" title="5">arg <span class="op">=</span> quux</a>
<a class="sourceLine" id="cb13-6" title="6"></a>
<a class="sourceLine" id="cb13-7" title="7"><span class="op">&gt;&gt;&gt;</span> <span class="im">from</span> mod <span class="im">import</span> Foo</a>
<a class="sourceLine" id="cb13-8" title="8"><span class="op">&gt;&gt;&gt;</span> x <span class="op">=</span> Foo()</a>
<a class="sourceLine" id="cb13-9" title="9"><span class="op">&gt;&gt;&gt;</span> x</a>
<a class="sourceLine" id="cb13-10" title="10"><span class="op">&lt;</span>mod.Foo <span class="bu">object</span> at <span class="bn">0x02E3AD50</span><span class="op">&gt;</span></a></code></pre>
    </div>
    <p>
      Because this form of <code>import</code> places the object names directly
      into the caller’s symbol table, any objects that already exist with the
      same name will be <em>overwritten</em>:&gt;&gt;&gt;
    </p>
    <div class="sourceCode" id="cb14">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb14-1" title="1"><span class="op">&gt;&gt;&gt;</span> a <span class="op">=</span> [<span class="st">&#39;foo&#39;</span>, <span class="st">&#39;bar&#39;</span>, <span class="st">&#39;baz&#39;</span>]</a>
<a class="sourceLine" id="cb14-2" title="2"><span class="op">&gt;&gt;&gt;</span> a</a>
<a class="sourceLine" id="cb14-3" title="3">[<span class="st">&#39;foo&#39;</span>, <span class="st">&#39;bar&#39;</span>, <span class="st">&#39;baz&#39;</span>]</a>
<a class="sourceLine" id="cb14-4" title="4"></a>
<a class="sourceLine" id="cb14-5" title="5"><span class="op">&gt;&gt;&gt;</span> <span class="im">from</span> mod <span class="im">import</span> a</a>
<a class="sourceLine" id="cb14-6" title="6"><span class="op">&gt;&gt;&gt;</span> a</a>
<a class="sourceLine" id="cb14-7" title="7">[<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">300</span>]</a></code></pre>
    </div>
    <p>
      It is even possible to indiscriminately <code>import</code> everything
      from a module at one fell swoop:
    </p>
    <div class="sourceCode" id="cb15">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb15-1" title="1"><span class="im">from</span> <span class="op">&lt;</span>module_name<span class="op">&gt;</span> <span class="im">import</span> <span class="op">*</span></a></code></pre>
    </div>
    <p>
      This will place the names of <em>all</em> objects from
      <code>&lt;module_name&gt;</code> into the local symbol table, with the
      exception of any that begin with the underscore (<code>_</code>)
      character.
    </p>
    <p>For example:&gt;&gt;&gt;</p>
    <div class="sourceCode" id="cb16">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb16-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="im">from</span> mod <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb16-2" title="2"><span class="op">&gt;&gt;&gt;</span> s</a>
<a class="sourceLine" id="cb16-3" title="3"><span class="co">&#39;If Comrade Napoleon says it, it must be right.&#39;</span></a>
<a class="sourceLine" id="cb16-4" title="4"><span class="op">&gt;&gt;&gt;</span> a</a>
<a class="sourceLine" id="cb16-5" title="5">[<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">300</span>]</a>
<a class="sourceLine" id="cb16-6" title="6"><span class="op">&gt;&gt;&gt;</span> foo</a>
<a class="sourceLine" id="cb16-7" title="7"><span class="op">&lt;</span>function foo at <span class="bn">0x03B449C0</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb16-8" title="8"><span class="op">&gt;&gt;&gt;</span> Foo</a>
<a class="sourceLine" id="cb16-9" title="9"><span class="op">&lt;</span><span class="kw">class</span> <span class="st">&#39;mod.Foo&#39;</span><span class="op">&gt;</span></a></code></pre>
    </div>
    <p>
      This isn’t necessarily recommended in large-scale production code. It’s a
      bit dangerous because you are entering names into the local symbol table
      <em>en masse</em>. Unless you know them all well and can be confident
      there won’t be a conflict, you have a decent chance of overwriting an
      existing name inadvertently. However, this syntax is quite handy when you
      are just mucking around with the interactive interpreter, for testing or
      discovery purposes, because it quickly gives you access to everything a
      module has to offer without a lot of typing.
    </p>
    <h4 id="from-module_name-import-name-as-alt_name">
      <code
        >from &lt;module_name&gt; import &lt;name&gt; as &lt;alt_name&gt;</code
      >
    </h4>
    <p>
      It is also possible to <code>import</code> individual objects but enter
      them into the local symbol table with alternate names:
    </p>
    <div class="sourceCode" id="cb17">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb17-1" title="1"><span class="im">from</span> <span class="op">&lt;</span>module_name<span class="op">&gt;</span> <span class="im">import</span> <span class="op">&lt;</span>name<span class="op">&gt;</span> <span class="im">as</span> <span class="op">&lt;</span>alt_name<span class="op">&gt;</span>[, <span class="op">&lt;</span>name<span class="op">&gt;</span> <span class="im">as</span> <span class="op">&lt;</span>alt_name<span class="op">&gt;</span> …]</a></code></pre>
    </div>
    <p>
      This makes it possible to place names directly into the local symbol table
      but avoid conflicts with previously existing names:&gt;&gt;&gt;
    </p>
    <div class="sourceCode" id="cb18">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb18-1" title="1"><span class="op">&gt;&gt;&gt;</span> s <span class="op">=</span> <span class="st">&#39;foo&#39;</span></a>
<a class="sourceLine" id="cb18-2" title="2"><span class="op">&gt;&gt;&gt;</span> a <span class="op">=</span> [<span class="st">&#39;foo&#39;</span>, <span class="st">&#39;bar&#39;</span>, <span class="st">&#39;baz&#39;</span>]</a>
<a class="sourceLine" id="cb18-3" title="3"></a>
<a class="sourceLine" id="cb18-4" title="4"><span class="op">&gt;&gt;&gt;</span> <span class="im">from</span> mod <span class="im">import</span> s <span class="im">as</span> string, a <span class="im">as</span> alist</a>
<a class="sourceLine" id="cb18-5" title="5"><span class="op">&gt;&gt;&gt;</span> s</a>
<a class="sourceLine" id="cb18-6" title="6"><span class="co">&#39;foo&#39;</span></a>
<a class="sourceLine" id="cb18-7" title="7"><span class="op">&gt;&gt;&gt;</span> string</a>
<a class="sourceLine" id="cb18-8" title="8"><span class="co">&#39;If Comrade Napoleon says it, it must be right.&#39;</span></a>
<a class="sourceLine" id="cb18-9" title="9"><span class="op">&gt;&gt;&gt;</span> a</a>
<a class="sourceLine" id="cb18-10" title="10">[<span class="st">&#39;foo&#39;</span>, <span class="st">&#39;bar&#39;</span>, <span class="st">&#39;baz&#39;</span>]</a>
<a class="sourceLine" id="cb18-11" title="11"><span class="op">&gt;&gt;&gt;</span> alist</a>
<a class="sourceLine" id="cb18-12" title="12">[<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">300</span>]</a></code></pre>
    </div>
    <h4 id="import-module_name-as-alt_name">
      <code>import &lt;module_name&gt; as &lt;alt_name&gt;</code>
    </h4>
    <p>You can also import an entire module under an alternate name:</p>
    <div class="sourceCode" id="cb19">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb19-1" title="1"><span class="im">import</span> <span class="op">&lt;</span>module_name<span class="op">&gt;</span> <span class="im">as</span> <span class="op">&lt;</span>alt_name<span class="op">&gt;</span></a></code></pre>
    </div>
    <p>&gt;&gt;&gt;</p>
    <div class="sourceCode" id="cb20">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb20-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> mod <span class="im">as</span> my_module</a>
<a class="sourceLine" id="cb20-2" title="2"><span class="op">&gt;&gt;&gt;</span> my_module.a</a>
<a class="sourceLine" id="cb20-3" title="3">[<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">300</span>]</a>
<a class="sourceLine" id="cb20-4" title="4"><span class="op">&gt;&gt;&gt;</span> my_module.foo(<span class="st">&#39;qux&#39;</span>)</a>
<a class="sourceLine" id="cb20-5" title="5">arg <span class="op">=</span> qux</a></code></pre>
    </div>
    <p>
      Module contents can be imported from within a
      <a href="https://realpython.com/defining-your-own-python-function/"
        >function definition</a
      >. In that case, the <code>import</code> does not occur until the function
      is <em>called</em>:&gt;&gt;&gt;
    </p>
    <div class="sourceCode" id="cb21">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb21-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">def</span> bar():</a>
<a class="sourceLine" id="cb21-2" title="2">...     <span class="im">from</span> mod <span class="im">import</span> foo</a>
<a class="sourceLine" id="cb21-3" title="3">...     foo(<span class="st">&#39;corge&#39;</span>)</a>
<a class="sourceLine" id="cb21-4" title="4">...</a>
<a class="sourceLine" id="cb21-5" title="5"></a>
<a class="sourceLine" id="cb21-6" title="6"><span class="op">&gt;&gt;&gt;</span> bar()</a>
<a class="sourceLine" id="cb21-7" title="7">arg <span class="op">=</span> corge</a></code></pre>
    </div>
    <p>
      However, <strong>Python 3</strong> does not allow the indiscriminate
      <code>import *</code> syntax from within a function:&gt;&gt;&gt;
    </p>
    <div class="sourceCode" id="cb22">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb22-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">def</span> bar():</a>
<a class="sourceLine" id="cb22-2" title="2">...     <span class="im">from</span> mod <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb22-3" title="3">...</a>
<a class="sourceLine" id="cb22-4" title="4"><span class="pp">SyntaxError</span>: <span class="im">import</span> <span class="op">*</span> only allowed at module level</a></code></pre>
    </div>
    <p>
      Lastly, a
      <a href="https://realpython.com/python-exceptions/"
        ><code>try</code> statement with an <code>except ImportError</code></a
      >
      clause can be used to guard against unsuccessful
      <code>import</code> attempts:&gt;&gt;&gt;
    </p>
    <div class="sourceCode" id="cb23">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb23-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="cf">try</span>:</a>
<a class="sourceLine" id="cb23-2" title="2">...     <span class="co"># Non-existent module</span></a>
<a class="sourceLine" id="cb23-3" title="3">...     <span class="im">import</span> baz</a>
<a class="sourceLine" id="cb23-4" title="4">... <span class="cf">except</span> <span class="pp">ImportError</span>:</a>
<a class="sourceLine" id="cb23-5" title="5">...     <span class="bu">print</span>(<span class="st">&#39;Module not found&#39;</span>)</a>
<a class="sourceLine" id="cb23-6" title="6">...</a>
<a class="sourceLine" id="cb23-7" title="7"></a>
<a class="sourceLine" id="cb23-8" title="8">Module <span class="kw">not</span> found</a></code></pre>
    </div>
    <p>&gt;&gt;&gt;</p>
    <div class="sourceCode" id="cb24">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb24-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="cf">try</span>:</a>
<a class="sourceLine" id="cb24-2" title="2">...     <span class="co"># Existing module, but non-existent object</span></a>
<a class="sourceLine" id="cb24-3" title="3">...     <span class="im">from</span> mod <span class="im">import</span> baz</a>
<a class="sourceLine" id="cb24-4" title="4">... <span class="cf">except</span> <span class="pp">ImportError</span>:</a>
<a class="sourceLine" id="cb24-5" title="5">...     <span class="bu">print</span>(<span class="st">&#39;Object not found in module&#39;</span>)</a>
<a class="sourceLine" id="cb24-6" title="6">...</a>
<a class="sourceLine" id="cb24-7" title="7"></a>
<a class="sourceLine" id="cb24-8" title="8">Object <span class="kw">not</span> found <span class="kw">in</span> module</a></code></pre>
    </div>
    <p>
      <a
        href="https://srv.realpython.net/click/64251616254/?c=57731396368&amp;p=58946116052&amp;r=37348"
        ><img
          src="https://img.realpython.net/785012599729209d9a50c87329a69fbc" /></a
      ><a href="https://realpython.com/account/join/">Remove ads</a>
    </p>
    <h3 id="the-dir-function">The <code>dir()</code> Function</h3>
    <p>
      The built-in function <code>dir()</code> returns a list of defined names
      in a namespace. Without arguments, it produces an alphabetically sorted
      list of names in the current
      <strong>local symbol table</strong>:&gt;&gt;&gt;
    </p>
    <div class="sourceCode" id="cb25">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb25-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="bu">dir</span>()</a>
<a class="sourceLine" id="cb25-2" title="2">[<span class="st">&#39;__annotations__&#39;</span>, <span class="st">&#39;__builtins__&#39;</span>, <span class="st">&#39;__doc__&#39;</span>, <span class="st">&#39;__loader__&#39;</span>, <span class="st">&#39;__name__&#39;</span>,</a>
<a class="sourceLine" id="cb25-3" title="3"><span class="st">&#39;__package__&#39;</span>, <span class="st">&#39;__spec__&#39;</span>]</a>
<a class="sourceLine" id="cb25-4" title="4"></a>
<a class="sourceLine" id="cb25-5" title="5"><span class="op">&gt;&gt;&gt;</span> qux <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</a>
<a class="sourceLine" id="cb25-6" title="6"><span class="op">&gt;&gt;&gt;</span> <span class="bu">dir</span>()</a>
<a class="sourceLine" id="cb25-7" title="7">[<span class="st">&#39;__annotations__&#39;</span>, <span class="st">&#39;__builtins__&#39;</span>, <span class="st">&#39;__doc__&#39;</span>, <span class="st">&#39;__loader__&#39;</span>, <span class="st">&#39;__name__&#39;</span>,</a>
<a class="sourceLine" id="cb25-8" title="8"><span class="st">&#39;__package__&#39;</span>, <span class="st">&#39;__spec__&#39;</span>, <span class="st">&#39;qux&#39;</span>]</a>
<a class="sourceLine" id="cb25-9" title="9"></a>
<a class="sourceLine" id="cb25-10" title="10"><span class="op">&gt;&gt;&gt;</span> <span class="kw">class</span> Bar():</a>
<a class="sourceLine" id="cb25-11" title="11">...     <span class="cf">pass</span></a>
<a class="sourceLine" id="cb25-12" title="12">...</a>
<a class="sourceLine" id="cb25-13" title="13"><span class="op">&gt;&gt;&gt;</span> x <span class="op">=</span> Bar()</a>
<a class="sourceLine" id="cb25-14" title="14"><span class="op">&gt;&gt;&gt;</span> <span class="bu">dir</span>()</a>
<a class="sourceLine" id="cb25-15" title="15">[<span class="st">&#39;Bar&#39;</span>, <span class="st">&#39;__annotations__&#39;</span>, <span class="st">&#39;__builtins__&#39;</span>, <span class="st">&#39;__doc__&#39;</span>, <span class="st">&#39;__loader__&#39;</span>, <span class="st">&#39;__name__&#39;</span>,</a>
<a class="sourceLine" id="cb25-16" title="16"><span class="st">&#39;__package__&#39;</span>, <span class="st">&#39;__spec__&#39;</span>, <span class="st">&#39;qux&#39;</span>, <span class="st">&#39;x&#39;</span>]</a></code></pre>
    </div>
    <p>
      Note how the first call to <code>dir()</code> above lists several names
      that are automatically defined and already in the namespace when the
      interpreter starts. As new names are defined (<code>qux</code>,
      <code>Bar</code>, <code>x</code>), they appear on subsequent invocations
      of <code>dir()</code>.
    </p>
    <p>
      This can be useful for identifying what exactly has been added to the
      namespace by an import statement:&gt;&gt;&gt;
    </p>
    <div class="sourceCode" id="cb26">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb26-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="bu">dir</span>()</a>
<a class="sourceLine" id="cb26-2" title="2">[<span class="st">&#39;__annotations__&#39;</span>, <span class="st">&#39;__builtins__&#39;</span>, <span class="st">&#39;__doc__&#39;</span>, <span class="st">&#39;__loader__&#39;</span>, <span class="st">&#39;__name__&#39;</span>,</a>
<a class="sourceLine" id="cb26-3" title="3"><span class="st">&#39;__package__&#39;</span>, <span class="st">&#39;__spec__&#39;</span>]</a>
<a class="sourceLine" id="cb26-4" title="4"></a>
<a class="sourceLine" id="cb26-5" title="5"><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> mod</a>
<a class="sourceLine" id="cb26-6" title="6"><span class="op">&gt;&gt;&gt;</span> <span class="bu">dir</span>()</a>
<a class="sourceLine" id="cb26-7" title="7">[<span class="st">&#39;__annotations__&#39;</span>, <span class="st">&#39;__builtins__&#39;</span>, <span class="st">&#39;__doc__&#39;</span>, <span class="st">&#39;__loader__&#39;</span>, <span class="st">&#39;__name__&#39;</span>,</a>
<a class="sourceLine" id="cb26-8" title="8"><span class="st">&#39;__package__&#39;</span>, <span class="st">&#39;__spec__&#39;</span>, <span class="st">&#39;mod&#39;</span>]</a>
<a class="sourceLine" id="cb26-9" title="9"><span class="op">&gt;&gt;&gt;</span> mod.s</a>
<a class="sourceLine" id="cb26-10" title="10"><span class="co">&#39;If Comrade Napoleon says it, it must be right.&#39;</span></a>
<a class="sourceLine" id="cb26-11" title="11"><span class="op">&gt;&gt;&gt;</span> mod.foo([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])</a>
<a class="sourceLine" id="cb26-12" title="12">arg <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</a>
<a class="sourceLine" id="cb26-13" title="13"></a>
<a class="sourceLine" id="cb26-14" title="14"><span class="op">&gt;&gt;&gt;</span> <span class="im">from</span> mod <span class="im">import</span> a, Foo</a>
<a class="sourceLine" id="cb26-15" title="15"><span class="op">&gt;&gt;&gt;</span> <span class="bu">dir</span>()</a>
<a class="sourceLine" id="cb26-16" title="16">[<span class="st">&#39;Foo&#39;</span>, <span class="st">&#39;__annotations__&#39;</span>, <span class="st">&#39;__builtins__&#39;</span>, <span class="st">&#39;__doc__&#39;</span>, <span class="st">&#39;__loader__&#39;</span>, <span class="st">&#39;__name__&#39;</span>,</a>
<a class="sourceLine" id="cb26-17" title="17"><span class="st">&#39;__package__&#39;</span>, <span class="st">&#39;__spec__&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;mod&#39;</span>]</a>
<a class="sourceLine" id="cb26-18" title="18"><span class="op">&gt;&gt;&gt;</span> a</a>
<a class="sourceLine" id="cb26-19" title="19">[<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">300</span>]</a>
<a class="sourceLine" id="cb26-20" title="20"><span class="op">&gt;&gt;&gt;</span> x <span class="op">=</span> Foo()</a>
<a class="sourceLine" id="cb26-21" title="21"><span class="op">&gt;&gt;&gt;</span> x</a>
<a class="sourceLine" id="cb26-22" title="22"><span class="op">&lt;</span>mod.Foo <span class="bu">object</span> at <span class="bn">0x002EAD50</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb26-23" title="23"></a>
<a class="sourceLine" id="cb26-24" title="24"><span class="op">&gt;&gt;&gt;</span> <span class="im">from</span> mod <span class="im">import</span> s <span class="im">as</span> string</a>
<a class="sourceLine" id="cb26-25" title="25"><span class="op">&gt;&gt;&gt;</span> <span class="bu">dir</span>()</a>
<a class="sourceLine" id="cb26-26" title="26">[<span class="st">&#39;Foo&#39;</span>, <span class="st">&#39;__annotations__&#39;</span>, <span class="st">&#39;__builtins__&#39;</span>, <span class="st">&#39;__doc__&#39;</span>, <span class="st">&#39;__loader__&#39;</span>, <span class="st">&#39;__name__&#39;</span>,</a>
<a class="sourceLine" id="cb26-27" title="27"><span class="st">&#39;__package__&#39;</span>, <span class="st">&#39;__spec__&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;mod&#39;</span>, <span class="st">&#39;string&#39;</span>, <span class="st">&#39;x&#39;</span>]</a>
<a class="sourceLine" id="cb26-28" title="28"><span class="op">&gt;&gt;&gt;</span> string</a>
<a class="sourceLine" id="cb26-29" title="29"><span class="co">&#39;If Comrade Napoleon says it, it must be right.&#39;</span></a></code></pre>
    </div>
    <p>
      When given an argument that is the name of a module,
      <code>dir()</code> lists the names defined in the module:&gt;&gt;&gt;
    </p>
    <div class="sourceCode" id="cb27">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb27-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> mod</a>
<a class="sourceLine" id="cb27-2" title="2"><span class="op">&gt;&gt;&gt;</span> <span class="bu">dir</span>(mod)</a>
<a class="sourceLine" id="cb27-3" title="3">[<span class="st">&#39;Foo&#39;</span>, <span class="st">&#39;__builtins__&#39;</span>, <span class="st">&#39;__cached__&#39;</span>, <span class="st">&#39;__doc__&#39;</span>, <span class="st">&#39;__file__&#39;</span>, <span class="st">&#39;__loader__&#39;</span>,</a>
<a class="sourceLine" id="cb27-4" title="4"><span class="st">&#39;__name__&#39;</span>, <span class="st">&#39;__package__&#39;</span>, <span class="st">&#39;__spec__&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;foo&#39;</span>, <span class="st">&#39;s&#39;</span>]</a></code></pre>
    </div>
    <p>&gt;&gt;&gt;</p>
    <div class="sourceCode" id="cb28">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb28-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="bu">dir</span>()</a>
<a class="sourceLine" id="cb28-2" title="2">[<span class="st">&#39;__annotations__&#39;</span>, <span class="st">&#39;__builtins__&#39;</span>, <span class="st">&#39;__doc__&#39;</span>, <span class="st">&#39;__loader__&#39;</span>, <span class="st">&#39;__name__&#39;</span>,</a>
<a class="sourceLine" id="cb28-3" title="3"><span class="st">&#39;__package__&#39;</span>, <span class="st">&#39;__spec__&#39;</span>]</a>
<a class="sourceLine" id="cb28-4" title="4"><span class="op">&gt;&gt;&gt;</span> <span class="im">from</span> mod <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb28-5" title="5"><span class="op">&gt;&gt;&gt;</span> <span class="bu">dir</span>()</a>
<a class="sourceLine" id="cb28-6" title="6">[<span class="st">&#39;Foo&#39;</span>, <span class="st">&#39;__annotations__&#39;</span>, <span class="st">&#39;__builtins__&#39;</span>, <span class="st">&#39;__doc__&#39;</span>, <span class="st">&#39;__loader__&#39;</span>, <span class="st">&#39;__name__&#39;</span>,</a>
<a class="sourceLine" id="cb28-7" title="7"><span class="st">&#39;__package__&#39;</span>, <span class="st">&#39;__spec__&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;foo&#39;</span>, <span class="st">&#39;s&#39;</span>]</a></code></pre>
    </div>
    <h3 id="executing-a-module-as-a-script">Executing a Module as a Script</h3>
    <p>
      Any <code>.py</code> file that contains a <strong>module</strong> is
      essentially also a Python <strong>script</strong>, and there isn’t any
      reason it can’t be executed like one.
    </p>
    <p>Here again is <code>mod.py</code> as it was defined above:</p>
    <p>
      <em><strong>mod.py</strong></em>
    </p>
    <div class="sourceCode" id="cb29">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb29-1" title="1">s <span class="op">=</span> <span class="st">&quot;If Comrade Napoleon says it, it must be right.&quot;</span></a>
<a class="sourceLine" id="cb29-2" title="2">a <span class="op">=</span> [<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">300</span>]</a>
<a class="sourceLine" id="cb29-3" title="3"></a>
<a class="sourceLine" id="cb29-4" title="4"><span class="kw">def</span> foo(arg):</a>
<a class="sourceLine" id="cb29-5" title="5">    <span class="bu">print</span>(<span class="ss">f&#39;arg = </span><span class="sc">{</span>arg<span class="sc">}</span><span class="ss">&#39;</span>)</a>
<a class="sourceLine" id="cb29-6" title="6"></a>
<a class="sourceLine" id="cb29-7" title="7"><span class="kw">class</span> Foo:</a>
<a class="sourceLine" id="cb29-8" title="8">    <span class="cf">pass</span></a></code></pre>
    </div>
    <p>This can be run as a script:</p>
    <div class="sourceCode" id="cb30">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb30-1" title="1">C:<span class="op">\</span>Users<span class="op">\</span>john<span class="op">\</span>Documents<span class="op">&gt;</span>python mod.py</a>
<a class="sourceLine" id="cb30-2" title="2">C:<span class="op">\</span>Users<span class="op">\</span>john<span class="op">\</span>Documents<span class="op">&gt;</span></a></code></pre>
    </div>
    <p>
      There are no errors, so it apparently worked. Granted, it’s not very
      interesting. As it is written, it only <em>defines</em> objects. It
      doesn’t <em>do</em> anything with them, and it doesn’t generate any
      output.
    </p>
    <p>
      Let’s modify the above Python module so it does generate some output when
      run as a script:
    </p>
    <p>
      <em><strong>mod.py</strong></em>
    </p>
    <div class="sourceCode" id="cb31">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb31-1" title="1">s <span class="op">=</span> <span class="st">&quot;If Comrade Napoleon says it, it must be right.&quot;</span></a>
<a class="sourceLine" id="cb31-2" title="2">a <span class="op">=</span> [<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">300</span>]</a>
<a class="sourceLine" id="cb31-3" title="3"></a>
<a class="sourceLine" id="cb31-4" title="4"><span class="kw">def</span> foo(arg):</a>
<a class="sourceLine" id="cb31-5" title="5">    <span class="bu">print</span>(<span class="ss">f&#39;arg = </span><span class="sc">{</span>arg<span class="sc">}</span><span class="ss">&#39;</span>)</a>
<a class="sourceLine" id="cb31-6" title="6"></a>
<a class="sourceLine" id="cb31-7" title="7"><span class="kw">class</span> Foo:</a>
<a class="sourceLine" id="cb31-8" title="8">    <span class="cf">pass</span></a>
<a class="sourceLine" id="cb31-9" title="9"></a>
<a class="sourceLine" id="cb31-10" title="10"><span class="bu">print</span>(s)</a>
<a class="sourceLine" id="cb31-11" title="11"><span class="bu">print</span>(a)</a>
<a class="sourceLine" id="cb31-12" title="12">foo(<span class="st">&#39;quux&#39;</span>)</a>
<a class="sourceLine" id="cb31-13" title="13">x <span class="op">=</span> Foo()</a>
<a class="sourceLine" id="cb31-14" title="14"><span class="bu">print</span>(x)</a></code></pre>
    </div>
    <p>Now it should be a little more interesting:</p>
    <div class="sourceCode" id="cb32">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb32-1" title="1">C:<span class="op">\</span>Users<span class="op">\</span>john<span class="op">\</span>Documents<span class="op">&gt;</span>python mod.py</a>
<a class="sourceLine" id="cb32-2" title="2">If Comrade Napoleon says it, it must be right.</a>
<a class="sourceLine" id="cb32-3" title="3">[<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">300</span>]</a>
<a class="sourceLine" id="cb32-4" title="4">arg <span class="op">=</span> quux</a>
<a class="sourceLine" id="cb32-5" title="5"><span class="op">&lt;</span>__main__.Foo <span class="bu">object</span> at <span class="bn">0x02F101D0</span><span class="op">&gt;</span></a></code></pre>
    </div>
    <p>
      Unfortunately, now it also generates output when imported as a
      module:&gt;&gt;&gt;
    </p>
    <div class="sourceCode" id="cb33">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb33-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> mod</a>
<a class="sourceLine" id="cb33-2" title="2">If Comrade Napoleon says it, it must be right.</a>
<a class="sourceLine" id="cb33-3" title="3">[<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">300</span>]</a>
<a class="sourceLine" id="cb33-4" title="4">arg <span class="op">=</span> quux</a>
<a class="sourceLine" id="cb33-5" title="5"><span class="op">&lt;</span>mod.Foo <span class="bu">object</span> at <span class="bn">0x0169AD50</span><span class="op">&gt;</span></a></code></pre>
    </div>
    <p>
      This is probably not what you want. It isn’t usual for a module to
      generate output when it is imported.
    </p>
    <p>
      Wouldn’t it be nice if you could distinguish between when the file is
      loaded as a module and when it is run as a standalone script?
    </p>
    <p>Ask and ye shall receive.</p>
    <p>
      When a <code>.py</code> file is imported as a module, Python sets the
      special <strong>dunder</strong> variable
      <a href="https://realpython.com/python-main-function/"
        ><code>__name__</code></a
      >
      to the name of the module. However, if a file is run as a standalone
      script, <code>__name__</code> is (creatively) set to the string
      <code>'__main__'</code>. Using this fact, you can discern which is the
      case at run-time and alter behavior accordingly:
    </p>
    <p>
      <em><strong>mod.py</strong></em>
    </p>
    <div class="sourceCode" id="cb34">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb34-1" title="1">s <span class="op">=</span> <span class="st">&quot;If Comrade Napoleon says it, it must be right.&quot;</span></a>
<a class="sourceLine" id="cb34-2" title="2">a <span class="op">=</span> [<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">300</span>]</a>
<a class="sourceLine" id="cb34-3" title="3"></a>
<a class="sourceLine" id="cb34-4" title="4"><span class="kw">def</span> foo(arg):</a>
<a class="sourceLine" id="cb34-5" title="5">    <span class="bu">print</span>(<span class="ss">f&#39;arg = </span><span class="sc">{</span>arg<span class="sc">}</span><span class="ss">&#39;</span>)</a>
<a class="sourceLine" id="cb34-6" title="6"></a>
<a class="sourceLine" id="cb34-7" title="7"><span class="kw">class</span> Foo:</a>
<a class="sourceLine" id="cb34-8" title="8">    <span class="cf">pass</span></a>
<a class="sourceLine" id="cb34-9" title="9"></a>
<a class="sourceLine" id="cb34-10" title="10"><span class="cf">if</span> (<span class="va">__name__</span> <span class="op">==</span> <span class="st">&#39;__main__&#39;</span>):</a>
<a class="sourceLine" id="cb34-11" title="11">    <span class="bu">print</span>(<span class="st">&#39;Executing as standalone script&#39;</span>)</a>
<a class="sourceLine" id="cb34-12" title="12">    <span class="bu">print</span>(s)</a>
<a class="sourceLine" id="cb34-13" title="13">    <span class="bu">print</span>(a)</a>
<a class="sourceLine" id="cb34-14" title="14">    foo(<span class="st">&#39;quux&#39;</span>)</a>
<a class="sourceLine" id="cb34-15" title="15">    x <span class="op">=</span> Foo()</a>
<a class="sourceLine" id="cb34-16" title="16">    <span class="bu">print</span>(x)</a></code></pre>
    </div>
    <p>Now, if you run as a script, you get output:</p>
    <div class="sourceCode" id="cb35">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb35-1" title="1">C:<span class="op">\</span>Users<span class="op">\</span>john<span class="op">\</span>Documents<span class="op">&gt;</span>python mod.py</a>
<a class="sourceLine" id="cb35-2" title="2">Executing <span class="im">as</span> standalone script</a>
<a class="sourceLine" id="cb35-3" title="3">If Comrade Napoleon says it, it must be right.</a>
<a class="sourceLine" id="cb35-4" title="4">[<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">300</span>]</a>
<a class="sourceLine" id="cb35-5" title="5">arg <span class="op">=</span> quux</a>
<a class="sourceLine" id="cb35-6" title="6"><span class="op">&lt;</span>__main__.Foo <span class="bu">object</span> at <span class="bn">0x03450690</span><span class="op">&gt;</span></a></code></pre>
    </div>
    <p>But if you import as a module, you don’t:&gt;&gt;&gt;</p>
    <div class="sourceCode" id="cb36">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb36-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> mod</a>
<a class="sourceLine" id="cb36-2" title="2"><span class="op">&gt;&gt;&gt;</span> mod.foo(<span class="st">&#39;grault&#39;</span>)</a>
<a class="sourceLine" id="cb36-3" title="3">arg <span class="op">=</span> grault</a></code></pre>
    </div>
    <p>
      Modules are often designed with the capability to run as a standalone
      script for purposes of testing the functionality that is contained within
      the module. This is referred to as
      <a href="https://realpython.com/python-testing/"
        ><strong>unit testing</strong></a
      ><strong>.</strong> For example, suppose you have created a module
      <code>fact.py</code> containing a <strong>factorial</strong> function, as
      follows:
    </p>
    <p>
      <em><strong>fact.py</strong></em>
    </p>
    <div class="sourceCode" id="cb37">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb37-1" title="1"><span class="kw">def</span> fact(n):</a>
<a class="sourceLine" id="cb37-2" title="2">    <span class="cf">return</span> <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span> n <span class="op">*</span> fact(n<span class="dv">-1</span>)</a>
<a class="sourceLine" id="cb37-3" title="3"></a>
<a class="sourceLine" id="cb37-4" title="4"><span class="cf">if</span> (<span class="va">__name__</span> <span class="op">==</span> <span class="st">&#39;__main__&#39;</span>):</a>
<a class="sourceLine" id="cb37-5" title="5">    <span class="im">import</span> sys</a>
<a class="sourceLine" id="cb37-6" title="6">    <span class="cf">if</span> <span class="bu">len</span>(sys.argv) <span class="op">&gt;</span> <span class="dv">1</span>:</a>
<a class="sourceLine" id="cb37-7" title="7">        <span class="bu">print</span>(fact(<span class="bu">int</span>(sys.argv[<span class="dv">1</span>])))</a></code></pre>
    </div>
    <p>
      The file can be treated as a module, and the <code>fact()</code> function
      imported:&gt;&gt;&gt;
    </p>
    <div class="sourceCode" id="cb38">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb38-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="im">from</span> fact <span class="im">import</span> fact</a>
<a class="sourceLine" id="cb38-2" title="2"><span class="op">&gt;&gt;&gt;</span> fact(<span class="dv">6</span>)</a>
<a class="sourceLine" id="cb38-3" title="3"><span class="dv">720</span></a></code></pre>
    </div>
    <p>
      But it can also be run as a standalone by passing an integer argument on
      the command-line for testing:
    </p>
    <div class="sourceCode" id="cb39">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb39-1" title="1">C:<span class="op">\</span>Users<span class="op">\</span>john<span class="op">\</span>Documents<span class="op">&gt;</span>python fact.py <span class="dv">6</span></a>
<a class="sourceLine" id="cb39-2" title="2"><span class="dv">720</span></a></code></pre>
    </div>
    <p>
      <a
        href="https://srv.realpython.net/click/59335905319/?c=32419346518&amp;p=58946116052&amp;r=67094"
        ><img
          src="https://img.realpython.net/7915ae1c65bffcd60287b05a4a5e2d20" /></a
      ><a href="https://realpython.com/account/join/">Remove ads</a>
    </p>
    <h3 id="reloading-a-module">Reloading a Module</h3>
    <p>
      For reasons of efficiency, a module is only loaded once per interpreter
      session. That is fine for function and class definitions, which typically
      make up the bulk of a module’s contents. But a module can contain
      executable statements as well, usually for initialization. Be aware that
      these statements will only be executed the <em>first time</em> a module is
      imported.
    </p>
    <p>Consider the following file <code>mod.py</code>:</p>
    <p>
      <em><strong>mod.py</strong></em>
    </p>
    <div class="sourceCode" id="cb40">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb40-1" title="1">a <span class="op">=</span> [<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">300</span>]</a>
<a class="sourceLine" id="cb40-2" title="2"><span class="bu">print</span>(<span class="st">&#39;a =&#39;</span>, a)</a></code></pre>
    </div>
    <p>&gt;&gt;&gt;</p>
    <div class="sourceCode" id="cb41">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb41-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> mod</a>
<a class="sourceLine" id="cb41-2" title="2">a <span class="op">=</span> [<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">300</span>]</a>
<a class="sourceLine" id="cb41-3" title="3"><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> mod</a>
<a class="sourceLine" id="cb41-4" title="4"><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> mod</a>
<a class="sourceLine" id="cb41-5" title="5"></a>
<a class="sourceLine" id="cb41-6" title="6"><span class="op">&gt;&gt;&gt;</span> mod.a</a>
<a class="sourceLine" id="cb41-7" title="7">[<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">300</span>]</a></code></pre>
    </div>
    <p>
      The <code>print()</code> statement is not executed on subsequent imports.
      (For that matter, neither is the assignment statement, but as the final
      display of the value of <code>mod.a</code> shows, that doesn’t matter.
      Once the assignment is made, it sticks.)
    </p>
    <p>
      If you make a change to a module and need to reload it, you need to either
      restart the interpreter or use a function called
      <code>reload()</code> from module <code>importlib</code>:&gt;&gt;&gt;
    </p>
    <div class="sourceCode" id="cb42">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb42-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> mod</a>
<a class="sourceLine" id="cb42-2" title="2">a <span class="op">=</span> [<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">300</span>]</a>
<a class="sourceLine" id="cb42-3" title="3"></a>
<a class="sourceLine" id="cb42-4" title="4"><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> mod</a>
<a class="sourceLine" id="cb42-5" title="5"></a>
<a class="sourceLine" id="cb42-6" title="6"><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> importlib</a>
<a class="sourceLine" id="cb42-7" title="7"><span class="op">&gt;&gt;&gt;</span> importlib.<span class="bu">reload</span>(mod)</a>
<a class="sourceLine" id="cb42-8" title="8">a <span class="op">=</span> [<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">300</span>]</a>
<a class="sourceLine" id="cb42-9" title="9"><span class="op">&lt;</span>module <span class="st">&#39;mod&#39;</span> <span class="im">from</span> <span class="st">&#39;C:</span><span class="ch">\\</span><span class="st">Users</span><span class="ch">\\</span><span class="st">john</span><span class="ch">\\</span><span class="st">Documents</span><span class="ch">\\</span><span class="st">Python</span><span class="ch">\\</span><span class="st">doc</span><span class="ch">\\</span><span class="st">mod.py&#39;</span><span class="op">&gt;</span></a></code></pre>
    </div>
    <h3 id="python-packages">Python Packages</h3>
    <p>
      Suppose you have developed a very large application that includes many
      modules. As the number of modules grows, it becomes difficult to keep
      track of them all if they are dumped into one location. This is
      particularly so if they have similar names or functionality. You might
      wish for a means of grouping and organizing them.
    </p>
    <p>
      <strong>Packages</strong> allow for a hierarchical structuring of the
      module namespace using <strong>dot notation</strong>. In the same way that
      <strong>modules</strong> help avoid collisions between global variable
      names, <strong>packages</strong> help avoid collisions between module
      names.
    </p>
    <p>
      Creating a <strong>package</strong> is quite straightforward, since it
      makes use of the operating system’s inherent hierarchical file structure.
      Consider the following arrangement:<a
        href="https://files.realpython.com/media/pkg1.9af1c7aea48f.png"
        ><img
          src="https://files.realpython.com/media/pkg1.9af1c7aea48f.png"
          alt="Image of a Python package"
      /></a>
    </p>
    <p>
      Here, there is a directory named <code>pkg</code> that contains two
      modules, <code>mod1.py</code> and <code>mod2.py</code>. The contents of
      the modules are:
    </p>
    <p>
      <em><strong>mod1.py</strong></em>
    </p>
    <div class="sourceCode" id="cb43">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb43-1" title="1"><span class="kw">def</span> foo():</a>
<a class="sourceLine" id="cb43-2" title="2">    <span class="bu">print</span>(<span class="st">&#39;[mod1] foo()&#39;</span>)</a>
<a class="sourceLine" id="cb43-3" title="3"></a>
<a class="sourceLine" id="cb43-4" title="4"><span class="kw">class</span> Foo:</a>
<a class="sourceLine" id="cb43-5" title="5">    <span class="cf">pass</span></a></code></pre>
    </div>
    <p>
      <em><strong>mod2.py</strong></em>
    </p>
    <div class="sourceCode" id="cb44">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb44-1" title="1"><span class="kw">def</span> bar():</a>
<a class="sourceLine" id="cb44-2" title="2">    <span class="bu">print</span>(<span class="st">&#39;[mod2] bar()&#39;</span>)</a>
<a class="sourceLine" id="cb44-3" title="3"></a>
<a class="sourceLine" id="cb44-4" title="4"><span class="kw">class</span> Bar:</a>
<a class="sourceLine" id="cb44-5" title="5">    <span class="cf">pass</span></a></code></pre>
    </div>
    <p>
      Given this structure, if the <code>pkg</code> directory resides in a
      location where it can be found (in one of the directories contained in
      <code>sys.path</code>), you can refer to the two
      <strong>modules</strong> with
      <strong>dot notation</strong> (<code>pkg.mod1</code>,
      <code>pkg.mod2</code>) and import them with the syntax you are already
      familiar with:
    </p>
    <div class="sourceCode" id="cb45">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb45-1" title="1"><span class="im">import</span> <span class="op">&lt;</span>module_name<span class="op">&gt;</span>[, <span class="op">&lt;</span>module_name<span class="op">&gt;</span> ...]</a></code></pre>
    </div>
    <p>&gt;&gt;&gt;</p>
    <div class="sourceCode" id="cb46">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb46-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> pkg.mod1, pkg.mod2</a>
<a class="sourceLine" id="cb46-2" title="2"><span class="op">&gt;&gt;&gt;</span> pkg.mod1.foo()</a>
<a class="sourceLine" id="cb46-3" title="3">[mod1] foo()</a>
<a class="sourceLine" id="cb46-4" title="4"><span class="op">&gt;&gt;&gt;</span> x <span class="op">=</span> pkg.mod2.Bar()</a>
<a class="sourceLine" id="cb46-5" title="5"><span class="op">&gt;&gt;&gt;</span> x</a>
<a class="sourceLine" id="cb46-6" title="6"><span class="op">&lt;</span>pkg.mod2.Bar <span class="bu">object</span> at <span class="bn">0x033F7290</span><span class="op">&gt;</span></a></code></pre>
    </div>
    <div class="sourceCode" id="cb47">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb47-1" title="1"><span class="im">from</span> <span class="op">&lt;</span>module_name<span class="op">&gt;</span> <span class="im">import</span> <span class="op">&lt;</span>name(s)<span class="op">&gt;</span></a></code></pre>
    </div>
    <p>&gt;&gt;&gt;</p>
    <div class="sourceCode" id="cb48">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb48-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="im">from</span> pkg.mod1 <span class="im">import</span> foo</a>
<a class="sourceLine" id="cb48-2" title="2"><span class="op">&gt;&gt;&gt;</span> foo()</a>
<a class="sourceLine" id="cb48-3" title="3">[mod1] foo()</a></code></pre>
    </div>
    <div class="sourceCode" id="cb49">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb49-1" title="1"><span class="im">from</span> <span class="op">&lt;</span>module_name<span class="op">&gt;</span> <span class="im">import</span> <span class="op">&lt;</span>name<span class="op">&gt;</span> <span class="im">as</span> <span class="op">&lt;</span>alt_name<span class="op">&gt;</span></a></code></pre>
    </div>
    <p>&gt;&gt;&gt;</p>
    <div class="sourceCode" id="cb50">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb50-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="im">from</span> pkg.mod2 <span class="im">import</span> Bar <span class="im">as</span> Qux</a>
<a class="sourceLine" id="cb50-2" title="2"><span class="op">&gt;&gt;&gt;</span> x <span class="op">=</span> Qux()</a>
<a class="sourceLine" id="cb50-3" title="3"><span class="op">&gt;&gt;&gt;</span> x</a>
<a class="sourceLine" id="cb50-4" title="4"><span class="op">&lt;</span>pkg.mod2.Bar <span class="bu">object</span> at <span class="bn">0x036DFFD0</span><span class="op">&gt;</span></a></code></pre>
    </div>
    <p>You can import modules with these statements as well:</p>
    <div class="sourceCode" id="cb51">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb51-1" title="1"><span class="im">from</span> <span class="op">&lt;</span>package_name<span class="op">&gt;</span> <span class="im">import</span> <span class="op">&lt;</span>modules_name<span class="op">&gt;</span>[, <span class="op">&lt;</span>module_name<span class="op">&gt;</span> ...]</a>
<a class="sourceLine" id="cb51-2" title="2"><span class="im">from</span> <span class="op">&lt;</span>package_name<span class="op">&gt;</span> <span class="im">import</span> <span class="op">&lt;</span>module_name<span class="op">&gt;</span> <span class="im">as</span> <span class="op">&lt;</span>alt_name<span class="op">&gt;</span></a></code></pre>
    </div>
    <p>&gt;&gt;&gt;</p>
    <div class="sourceCode" id="cb52">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb52-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="im">from</span> pkg <span class="im">import</span> mod1</a>
<a class="sourceLine" id="cb52-2" title="2"><span class="op">&gt;&gt;&gt;</span> mod1.foo()</a>
<a class="sourceLine" id="cb52-3" title="3">[mod1] foo()</a>
<a class="sourceLine" id="cb52-4" title="4"></a>
<a class="sourceLine" id="cb52-5" title="5"><span class="op">&gt;&gt;&gt;</span> <span class="im">from</span> pkg <span class="im">import</span> mod2 <span class="im">as</span> quux</a>
<a class="sourceLine" id="cb52-6" title="6"><span class="op">&gt;&gt;&gt;</span> quux.bar()</a>
<a class="sourceLine" id="cb52-7" title="7">[mod2] bar()</a></code></pre>
    </div>
    <p>You can technically import the package as well:&gt;&gt;&gt;</p>
    <div class="sourceCode" id="cb53">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb53-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> pkg</a>
<a class="sourceLine" id="cb53-2" title="2"><span class="op">&gt;&gt;&gt;</span> pkg</a>
<a class="sourceLine" id="cb53-3" title="3"><span class="op">&lt;</span>module <span class="st">&#39;pkg&#39;</span> (namespace)<span class="op">&gt;</span></a></code></pre>
    </div>
    <p>
      But this is of little avail. Though this is, strictly speaking, a
      syntactically correct Python statement, it doesn’t do much of anything
      useful. In particular, it <em>does not place</em> any of the modules in
      <code>pkg</code> into the local namespace:&gt;&gt;&gt;
    </p>
    <div class="sourceCode" id="cb54">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb54-1" title="1"><span class="op">&gt;&gt;&gt;</span> pkg.mod1</a>
<a class="sourceLine" id="cb54-2" title="2">Traceback (most recent call last):</a>
<a class="sourceLine" id="cb54-3" title="3">  File <span class="st">&quot;&lt;pyshell#34&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb54-4" title="4">    pkg.mod1</a>
<a class="sourceLine" id="cb54-5" title="5"><span class="pp">AttributeError</span>: module <span class="st">&#39;pkg&#39;</span> has no attribute <span class="st">&#39;mod1&#39;</span></a>
<a class="sourceLine" id="cb54-6" title="6"><span class="op">&gt;&gt;&gt;</span> pkg.mod1.foo()</a>
<a class="sourceLine" id="cb54-7" title="7">Traceback (most recent call last):</a>
<a class="sourceLine" id="cb54-8" title="8">  File <span class="st">&quot;&lt;pyshell#35&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb54-9" title="9">    pkg.mod1.foo()</a>
<a class="sourceLine" id="cb54-10" title="10"><span class="pp">AttributeError</span>: module <span class="st">&#39;pkg&#39;</span> has no attribute <span class="st">&#39;mod1&#39;</span></a>
<a class="sourceLine" id="cb54-11" title="11"><span class="op">&gt;&gt;&gt;</span> pkg.mod2.Bar()</a>
<a class="sourceLine" id="cb54-12" title="12">Traceback (most recent call last):</a>
<a class="sourceLine" id="cb54-13" title="13">  File <span class="st">&quot;&lt;pyshell#36&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb54-14" title="14">    pkg.mod2.Bar()</a>
<a class="sourceLine" id="cb54-15" title="15"><span class="pp">AttributeError</span>: module <span class="st">&#39;pkg&#39;</span> has no attribute <span class="st">&#39;mod2&#39;</span></a></code></pre>
    </div>
    <p>
      To actually import the modules or their contents, you need to use one of
      the forms shown above.<a
        href="https://srv.realpython.net/click/12410455494/?c=13641354227&amp;p=58946116052&amp;r=89494"
        ><img
          src="https://img.realpython.net/ce045944865116e7c70acc217eac34ec" /></a
      ><a href="https://realpython.com/account/join/">Remove ads</a>
    </p>
    <h3 id="package-initialization">Package Initialization</h3>
    <p>
      If a file named <code>__init__.py</code> is present in a package
      directory, it is invoked when the package or a module in the package is
      imported. This can be used for execution of package initialization code,
      such as initialization of package-level data.
    </p>
    <p>For example, consider the following <code>__init__.py</code> file:</p>
    <p>
      <em><strong>__init__.py</strong></em>
    </p>
    <div class="sourceCode" id="cb55">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb55-1" title="1"><span class="bu">print</span>(<span class="ss">f&#39;Invoking __init__.py for </span><span class="sc">{</span><span class="va">__name__</span><span class="sc">}</span><span class="ss">&#39;</span>)</a>
<a class="sourceLine" id="cb55-2" title="2">A <span class="op">=</span> [<span class="st">&#39;quux&#39;</span>, <span class="st">&#39;corge&#39;</span>, <span class="st">&#39;grault&#39;</span>]</a></code></pre>
    </div>
    <p>
      Let’s add this file to the <code>pkg</code> directory from the above
      example:<a href="https://files.realpython.com/media/pkg2.dab97c2f9c58.png"
        ><img
          src="https://files.realpython.com/media/pkg2.dab97c2f9c58.png"
          alt="Illustration of hierarchical file structure of Python packages"
      /></a>
    </p>
    <p>
      Now when the package is imported, the global list <code>A</code> is
      initialized:&gt;&gt;&gt;
    </p>
    <div class="sourceCode" id="cb56">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb56-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> pkg</a>
<a class="sourceLine" id="cb56-2" title="2">Invoking <span class="fu">__init__</span>.py <span class="cf">for</span> pkg</a>
<a class="sourceLine" id="cb56-3" title="3"><span class="op">&gt;&gt;&gt;</span> pkg.A</a>
<a class="sourceLine" id="cb56-4" title="4">[<span class="st">&#39;quux&#39;</span>, <span class="st">&#39;corge&#39;</span>, <span class="st">&#39;grault&#39;</span>]</a></code></pre>
    </div>
    <p>
      A <strong>module</strong> in the package can access the global variable by
      importing it in turn:
    </p>
    <p>
      <em><strong>mod1.py</strong></em>
    </p>
    <div class="sourceCode" id="cb57">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb57-1" title="1"><span class="kw">def</span> foo():</a>
<a class="sourceLine" id="cb57-2" title="2">    <span class="im">from</span> pkg <span class="im">import</span> A</a>
<a class="sourceLine" id="cb57-3" title="3">    <span class="bu">print</span>(<span class="st">&#39;[mod1] foo() / A = &#39;</span>, A)</a>
<a class="sourceLine" id="cb57-4" title="4"></a>
<a class="sourceLine" id="cb57-5" title="5"><span class="kw">class</span> Foo:</a>
<a class="sourceLine" id="cb57-6" title="6">    <span class="cf">pass</span></a></code></pre>
    </div>
    <p>&gt;&gt;&gt;</p>
    <div class="sourceCode" id="cb58">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb58-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="im">from</span> pkg <span class="im">import</span> mod1</a>
<a class="sourceLine" id="cb58-2" title="2">Invoking <span class="fu">__init__</span>.py <span class="cf">for</span> pkg</a>
<a class="sourceLine" id="cb58-3" title="3"><span class="op">&gt;&gt;&gt;</span> mod1.foo()</a>
<a class="sourceLine" id="cb58-4" title="4">[mod1] foo() <span class="op">/</span> A <span class="op">=</span>  [<span class="st">&#39;quux&#39;</span>, <span class="st">&#39;corge&#39;</span>, <span class="st">&#39;grault&#39;</span>]</a></code></pre>
    </div>
    <p>
      <code>__init__.py</code> can also be used to effect automatic importing of
      modules from a package. For example, earlier you saw that the statement
      <code>import pkg</code> only places the name <code>pkg</code> in the
      caller’s local symbol table and doesn’t import any modules. But if
      <code>__init__.py</code> in the <code>pkg</code> directory contains the
      following:
    </p>
    <p>
      <em><strong>__init__.py</strong></em>
    </p>
    <div class="sourceCode" id="cb59">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb59-1" title="1"><span class="bu">print</span>(<span class="ss">f&#39;Invoking __init__.py for </span><span class="sc">{</span><span class="va">__name__</span><span class="sc">}</span><span class="ss">&#39;</span>)</a>
<a class="sourceLine" id="cb59-2" title="2"><span class="im">import</span> pkg.mod1, pkg.mod2</a></code></pre>
    </div>
    <p>
      then when you execute <code>import pkg</code>, modules
      <code>mod1</code> and <code>mod2</code> are imported
      automatically:&gt;&gt;&gt;
    </p>
    <div class="sourceCode" id="cb60">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb60-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> pkg</a>
<a class="sourceLine" id="cb60-2" title="2">Invoking <span class="fu">__init__</span>.py <span class="cf">for</span> pkg</a>
<a class="sourceLine" id="cb60-3" title="3"><span class="op">&gt;&gt;&gt;</span> pkg.mod1.foo()</a>
<a class="sourceLine" id="cb60-4" title="4">[mod1] foo()</a>
<a class="sourceLine" id="cb60-5" title="5"><span class="op">&gt;&gt;&gt;</span> pkg.mod2.bar()</a>
<a class="sourceLine" id="cb60-6" title="6">[mod2] bar()</a></code></pre>
    </div>
    <p>
      <strong>Note:</strong> Much of the Python documentation states that an
      <code>__init__.py</code> file <strong>must</strong> be present in the
      package directory when creating a package. This was once true. It used to
      be that the very presence of <code>__init__.py</code> signified to Python
      that a package was being defined. The file could contain initialization
      code or even be empty, but it <strong>had</strong> to be present.
    </p>
    <p>
      Starting with <strong>Python 3.3</strong>,
      <a href="https://www.python.org/dev/peps/pep-0420"
        >Implicit Namespace Packages</a
      >
      were introduced. These allow for the creation of a package without any
      <code>__init__.py</code> file. Of course, it <strong>can</strong> still be
      present if package initialization is needed. But it is no longer required.
    </p>
    <h3 id="importing-from-a-package">
      Importing <code>*</code> From a Package
    </h3>
    <p>
      For the purposes of the following discussion, the previously defined
      package is expanded to contain some additional modules:<a
        href="https://files.realpython.com/media/pkg3.d2160908ae77.png"
        ><img
          src="https://files.realpython.com/media/pkg3.d2160908ae77.png"
          alt="Illustration of hierarchical file structure of Python packages"
      /></a>
    </p>
    <p>
      There are now four modules defined in the <code>pkg</code> directory.
      Their contents are as shown below:
    </p>
    <p>
      <em><strong>mod1.py</strong></em>
    </p>
    <div class="sourceCode" id="cb61">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb61-1" title="1"><span class="kw">def</span> foo():</a>
<a class="sourceLine" id="cb61-2" title="2">    <span class="bu">print</span>(<span class="st">&#39;[mod1] foo()&#39;</span>)</a>
<a class="sourceLine" id="cb61-3" title="3"></a>
<a class="sourceLine" id="cb61-4" title="4"><span class="kw">class</span> Foo:</a>
<a class="sourceLine" id="cb61-5" title="5">    <span class="cf">pass</span></a></code></pre>
    </div>
    <p>
      <em><strong>mod2.py</strong></em>
    </p>
    <div class="sourceCode" id="cb62">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb62-1" title="1"><span class="kw">def</span> bar():</a>
<a class="sourceLine" id="cb62-2" title="2">    <span class="bu">print</span>(<span class="st">&#39;[mod2] bar()&#39;</span>)</a>
<a class="sourceLine" id="cb62-3" title="3"></a>
<a class="sourceLine" id="cb62-4" title="4"><span class="kw">class</span> Bar:</a>
<a class="sourceLine" id="cb62-5" title="5">    <span class="cf">pass</span></a></code></pre>
    </div>
    <p>
      <em><strong>mod3.py</strong></em>
    </p>
    <div class="sourceCode" id="cb63">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb63-1" title="1"><span class="kw">def</span> baz():</a>
<a class="sourceLine" id="cb63-2" title="2">    <span class="bu">print</span>(<span class="st">&#39;[mod3] baz()&#39;</span>)</a>
<a class="sourceLine" id="cb63-3" title="3"></a>
<a class="sourceLine" id="cb63-4" title="4"><span class="kw">class</span> Baz:</a>
<a class="sourceLine" id="cb63-5" title="5">    <span class="cf">pass</span></a></code></pre>
    </div>
    <p>
      <em><strong>mod4.py</strong></em>
    </p>
    <div class="sourceCode" id="cb64">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb64-1" title="1"><span class="kw">def</span> qux():</a>
<a class="sourceLine" id="cb64-2" title="2">    <span class="bu">print</span>(<span class="st">&#39;[mod4] qux()&#39;</span>)</a>
<a class="sourceLine" id="cb64-3" title="3"></a>
<a class="sourceLine" id="cb64-4" title="4"><span class="kw">class</span> Qux:</a>
<a class="sourceLine" id="cb64-5" title="5">    <span class="cf">pass</span></a></code></pre>
    </div>
    <p>(Imaginative, aren’t they?)</p>
    <p>
      You have already seen that when <code>import *</code> is used for a
      <strong>module</strong>, <em>all</em> objects from the module are imported
      into the local symbol table, except those whose names begin with an
      underscore, as always:&gt;&gt;&gt;
    </p>
    <div class="sourceCode" id="cb65">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb65-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="bu">dir</span>()</a>
<a class="sourceLine" id="cb65-2" title="2">[<span class="st">&#39;__annotations__&#39;</span>, <span class="st">&#39;__builtins__&#39;</span>, <span class="st">&#39;__doc__&#39;</span>, <span class="st">&#39;__loader__&#39;</span>, <span class="st">&#39;__name__&#39;</span>,</a>
<a class="sourceLine" id="cb65-3" title="3"><span class="st">&#39;__package__&#39;</span>, <span class="st">&#39;__spec__&#39;</span>]</a>
<a class="sourceLine" id="cb65-4" title="4"></a>
<a class="sourceLine" id="cb65-5" title="5"><span class="op">&gt;&gt;&gt;</span> <span class="im">from</span> pkg.mod3 <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb65-6" title="6"></a>
<a class="sourceLine" id="cb65-7" title="7"><span class="op">&gt;&gt;&gt;</span> <span class="bu">dir</span>()</a>
<a class="sourceLine" id="cb65-8" title="8">[<span class="st">&#39;Baz&#39;</span>, <span class="st">&#39;__annotations__&#39;</span>, <span class="st">&#39;__builtins__&#39;</span>, <span class="st">&#39;__doc__&#39;</span>, <span class="st">&#39;__loader__&#39;</span>, <span class="st">&#39;__name__&#39;</span>,</a>
<a class="sourceLine" id="cb65-9" title="9"><span class="st">&#39;__package__&#39;</span>, <span class="st">&#39;__spec__&#39;</span>, <span class="st">&#39;baz&#39;</span>]</a>
<a class="sourceLine" id="cb65-10" title="10"><span class="op">&gt;&gt;&gt;</span> baz()</a>
<a class="sourceLine" id="cb65-11" title="11">[mod3] baz()</a>
<a class="sourceLine" id="cb65-12" title="12"><span class="op">&gt;&gt;&gt;</span> Baz</a>
<a class="sourceLine" id="cb65-13" title="13"><span class="op">&lt;</span><span class="kw">class</span> <span class="st">&#39;pkg.mod3.Baz&#39;</span><span class="op">&gt;</span></a></code></pre>
    </div>
    <p>The analogous statement for a <strong>package</strong> is this:</p>
    <div class="sourceCode" id="cb66">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb66-1" title="1"><span class="im">from</span> <span class="op">&lt;</span>package_name<span class="op">&gt;</span> <span class="im">import</span> <span class="op">*</span></a></code></pre>
    </div>
    <p>What does that do?&gt;&gt;&gt;</p>
    <div class="sourceCode" id="cb67">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb67-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="bu">dir</span>()</a>
<a class="sourceLine" id="cb67-2" title="2">[<span class="st">&#39;__annotations__&#39;</span>, <span class="st">&#39;__builtins__&#39;</span>, <span class="st">&#39;__doc__&#39;</span>, <span class="st">&#39;__loader__&#39;</span>, <span class="st">&#39;__name__&#39;</span>,</a>
<a class="sourceLine" id="cb67-3" title="3"><span class="st">&#39;__package__&#39;</span>, <span class="st">&#39;__spec__&#39;</span>]</a>
<a class="sourceLine" id="cb67-4" title="4"></a>
<a class="sourceLine" id="cb67-5" title="5"><span class="op">&gt;&gt;&gt;</span> <span class="im">from</span> pkg <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb67-6" title="6"><span class="op">&gt;&gt;&gt;</span> <span class="bu">dir</span>()</a>
<a class="sourceLine" id="cb67-7" title="7">[<span class="st">&#39;__annotations__&#39;</span>, <span class="st">&#39;__builtins__&#39;</span>, <span class="st">&#39;__doc__&#39;</span>, <span class="st">&#39;__loader__&#39;</span>, <span class="st">&#39;__name__&#39;</span>,</a>
<a class="sourceLine" id="cb67-8" title="8"><span class="st">&#39;__package__&#39;</span>, <span class="st">&#39;__spec__&#39;</span>]</a></code></pre>
    </div>
    <p>
      Hmph. Not much. You might have expected (assuming you had any expectations
      at all) that Python would dive down into the package directory, find all
      the modules it could, and import them all. But as you can see, by default
      that is not what happens.
    </p>
    <p>
      Instead, Python follows this convention: if the
      <code>__init__.py</code> file in the <strong>package</strong> directory
      contains a <strong>list</strong> named <code>__all__</code>, it is taken
      to be a list of modules that should be imported when the statement
      <code>from &lt;package_name&gt; import *</code> is encountered.
    </p>
    <p>
      For the present example, suppose you create an <code>__init__.py</code> in
      the <code>pkg</code> directory like this:
    </p>
    <p>
      <em><strong>pkg/__init__.py</strong></em>
    </p>
    <div class="sourceCode" id="cb68">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb68-1" title="1">__all__ <span class="op">=</span> [</a>
<a class="sourceLine" id="cb68-2" title="2">        <span class="st">&#39;mod1&#39;</span>,</a>
<a class="sourceLine" id="cb68-3" title="3">        <span class="st">&#39;mod2&#39;</span>,</a>
<a class="sourceLine" id="cb68-4" title="4">        <span class="st">&#39;mod3&#39;</span>,</a>
<a class="sourceLine" id="cb68-5" title="5">        <span class="st">&#39;mod4&#39;</span></a>
<a class="sourceLine" id="cb68-6" title="6">        ]</a></code></pre>
    </div>
    <p>
      Now <code>from pkg import *</code> imports all four modules:&gt;&gt;&gt;
    </p>
    <div class="sourceCode" id="cb69">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb69-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="bu">dir</span>()</a>
<a class="sourceLine" id="cb69-2" title="2">[<span class="st">&#39;__annotations__&#39;</span>, <span class="st">&#39;__builtins__&#39;</span>, <span class="st">&#39;__doc__&#39;</span>, <span class="st">&#39;__loader__&#39;</span>, <span class="st">&#39;__name__&#39;</span>,</a>
<a class="sourceLine" id="cb69-3" title="3"><span class="st">&#39;__package__&#39;</span>, <span class="st">&#39;__spec__&#39;</span>]</a>
<a class="sourceLine" id="cb69-4" title="4"></a>
<a class="sourceLine" id="cb69-5" title="5"><span class="op">&gt;&gt;&gt;</span> <span class="im">from</span> pkg <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb69-6" title="6"><span class="op">&gt;&gt;&gt;</span> <span class="bu">dir</span>()</a>
<a class="sourceLine" id="cb69-7" title="7">[<span class="st">&#39;__annotations__&#39;</span>, <span class="st">&#39;__builtins__&#39;</span>, <span class="st">&#39;__doc__&#39;</span>, <span class="st">&#39;__loader__&#39;</span>, <span class="st">&#39;__name__&#39;</span>,</a>
<a class="sourceLine" id="cb69-8" title="8"><span class="st">&#39;__package__&#39;</span>, <span class="st">&#39;__spec__&#39;</span>, <span class="st">&#39;mod1&#39;</span>, <span class="st">&#39;mod2&#39;</span>, <span class="st">&#39;mod3&#39;</span>, <span class="st">&#39;mod4&#39;</span>]</a>
<a class="sourceLine" id="cb69-9" title="9"><span class="op">&gt;&gt;&gt;</span> mod2.bar()</a>
<a class="sourceLine" id="cb69-10" title="10">[mod2] bar()</a>
<a class="sourceLine" id="cb69-11" title="11"><span class="op">&gt;&gt;&gt;</span> mod4.Qux</a>
<a class="sourceLine" id="cb69-12" title="12"><span class="op">&lt;</span><span class="kw">class</span> <span class="st">&#39;pkg.mod4.Qux&#39;</span><span class="op">&gt;</span></a></code></pre>
    </div>
    <p>
      Using <code>import *</code> still isn’t considered terrific form, any more
      for <strong>packages</strong> than for <strong>modules</strong>. But this
      facility at least gives the creator of the package some control over what
      happens when <code>import *</code> is specified. (In fact, it provides the
      capability to disallow it entirely, simply by declining to define
      <code>__all__</code> at all. As you have seen, the default behavior for
      packages is to import nothing.)
    </p>
    <p>
      By the way, <code>__all__</code> can be defined in a
      <strong>module</strong> as well and serves the same purpose: to control
      what is imported with <code>import *</code>. For example, modify
      <code>mod1.py</code> as follows:
    </p>
    <p>
      <em><strong>pkg/mod1.py</strong></em>
    </p>
    <div class="sourceCode" id="cb70">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb70-1" title="1">__all__ <span class="op">=</span> [<span class="st">&#39;foo&#39;</span>]</a>
<a class="sourceLine" id="cb70-2" title="2"></a>
<a class="sourceLine" id="cb70-3" title="3"><span class="kw">def</span> foo():</a>
<a class="sourceLine" id="cb70-4" title="4">    <span class="bu">print</span>(<span class="st">&#39;[mod1] foo()&#39;</span>)</a>
<a class="sourceLine" id="cb70-5" title="5"></a>
<a class="sourceLine" id="cb70-6" title="6"><span class="kw">class</span> Foo:</a>
<a class="sourceLine" id="cb70-7" title="7">    <span class="cf">pass</span></a></code></pre>
    </div>
    <p>
      Now an <code>import *</code> statement from <code>pkg.mod1</code> will
      only import what is contained in <code>__all__</code>:&gt;&gt;&gt;
    </p>
    <div class="sourceCode" id="cb71">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb71-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="bu">dir</span>()</a>
<a class="sourceLine" id="cb71-2" title="2">[<span class="st">&#39;__annotations__&#39;</span>, <span class="st">&#39;__builtins__&#39;</span>, <span class="st">&#39;__doc__&#39;</span>, <span class="st">&#39;__loader__&#39;</span>, <span class="st">&#39;__name__&#39;</span>,</a>
<a class="sourceLine" id="cb71-3" title="3"><span class="st">&#39;__package__&#39;</span>, <span class="st">&#39;__spec__&#39;</span>]</a>
<a class="sourceLine" id="cb71-4" title="4"></a>
<a class="sourceLine" id="cb71-5" title="5"><span class="op">&gt;&gt;&gt;</span> <span class="im">from</span> pkg.mod1 <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb71-6" title="6"><span class="op">&gt;&gt;&gt;</span> <span class="bu">dir</span>()</a>
<a class="sourceLine" id="cb71-7" title="7">[<span class="st">&#39;__annotations__&#39;</span>, <span class="st">&#39;__builtins__&#39;</span>, <span class="st">&#39;__doc__&#39;</span>, <span class="st">&#39;__loader__&#39;</span>, <span class="st">&#39;__name__&#39;</span>,</a>
<a class="sourceLine" id="cb71-8" title="8"><span class="st">&#39;__package__&#39;</span>, <span class="st">&#39;__spec__&#39;</span>, <span class="st">&#39;foo&#39;</span>]</a>
<a class="sourceLine" id="cb71-9" title="9"></a>
<a class="sourceLine" id="cb71-10" title="10"><span class="op">&gt;&gt;&gt;</span> foo()</a>
<a class="sourceLine" id="cb71-11" title="11">[mod1] foo()</a>
<a class="sourceLine" id="cb71-12" title="12"><span class="op">&gt;&gt;&gt;</span> Foo</a>
<a class="sourceLine" id="cb71-13" title="13">Traceback (most recent call last):</a>
<a class="sourceLine" id="cb71-14" title="14">  File <span class="st">&quot;&lt;pyshell#37&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb71-15" title="15">    Foo</a>
<a class="sourceLine" id="cb71-16" title="16"><span class="pp">NameError</span>: name <span class="st">&#39;Foo&#39;</span> <span class="kw">is</span> <span class="kw">not</span> defined</a></code></pre>
    </div>
    <p>
      <code>foo()</code> (the function) is now defined in the local namespace,
      but <code>Foo</code> (the class) is not, because the latter is not in
      <code>__all__</code>.
    </p>
    <p>
      In summary, <code>__all__</code> is used by both
      <strong>packages</strong> and <strong>modules</strong> to control what is
      imported when <code>import *</code> is specified. But
      <em>the default behavior differs</em>:
    </p>
    <ul>
      <li>
        For a package, when <code>__all__</code> is not defined,
        <code>import *</code> does not import anything.
      </li>
      <li>
        For a module, when <code>__all__</code> is not defined,
        <code>import *</code> imports everything (except—you guessed it—names
        starting with an underscore).
      </li>
    </ul>
    <p>
      <a
        href="https://srv.realpython.net/click/58257184031/?c=31941813441&amp;p=58946116052&amp;r=17046"
        ><img
          src="https://img.realpython.net/16bf1efe41b538fae54711c58c701f0e" /></a
      ><a href="https://realpython.com/account/join/">Remove ads</a>
    </p>
    <h3 id="subpackages">Subpackages</h3>
    <p>
      Packages can contain nested <strong>subpackages</strong> to arbitrary
      depth. For example, let’s make one more modification to the example
      <strong>package</strong> directory as follows:<a
        href="https://files.realpython.com/media/pkg4.a830d6e144bf.png"
        ><img
          src="https://files.realpython.com/media/pkg4.a830d6e144bf.png"
          alt="Illustration of hierarchical file structure of Python packages"
      /></a>
    </p>
    <p>
      The four modules (<code>mod1.py</code>, <code>mod2.py</code>,
      <code>mod3.py</code> and <code>mod4.py</code>) are defined as previously.
      But now, instead of being lumped together into the
      <code>pkg</code> directory, they are split out into two
      <strong>subpackage</strong> directories, <code>sub_pkg1</code> and
      <code>sub_pkg2</code>.
    </p>
    <p>
      Importing still works the same as shown previously. Syntax is similar, but
      additional <strong>dot notation</strong> is used to separate
      <strong>package</strong> name from
      <strong>subpackage</strong> name:&gt;&gt;&gt;
    </p>
    <div class="sourceCode" id="cb72">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb72-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> pkg.sub_pkg1.mod1</a>
<a class="sourceLine" id="cb72-2" title="2"><span class="op">&gt;&gt;&gt;</span> pkg.sub_pkg1.mod1.foo()</a>
<a class="sourceLine" id="cb72-3" title="3">[mod1] foo()</a>
<a class="sourceLine" id="cb72-4" title="4"></a>
<a class="sourceLine" id="cb72-5" title="5"><span class="op">&gt;&gt;&gt;</span> <span class="im">from</span> pkg.sub_pkg1 <span class="im">import</span> mod2</a>
<a class="sourceLine" id="cb72-6" title="6"><span class="op">&gt;&gt;&gt;</span> mod2.bar()</a>
<a class="sourceLine" id="cb72-7" title="7">[mod2] bar()</a>
<a class="sourceLine" id="cb72-8" title="8"></a>
<a class="sourceLine" id="cb72-9" title="9"><span class="op">&gt;&gt;&gt;</span> <span class="im">from</span> pkg.sub_pkg2.mod3 <span class="im">import</span> baz</a>
<a class="sourceLine" id="cb72-10" title="10"><span class="op">&gt;&gt;&gt;</span> baz()</a>
<a class="sourceLine" id="cb72-11" title="11">[mod3] baz()</a>
<a class="sourceLine" id="cb72-12" title="12"></a>
<a class="sourceLine" id="cb72-13" title="13"><span class="op">&gt;&gt;&gt;</span> <span class="im">from</span> pkg.sub_pkg2.mod4 <span class="im">import</span> qux <span class="im">as</span> grault</a>
<a class="sourceLine" id="cb72-14" title="14"><span class="op">&gt;&gt;&gt;</span> grault()</a>
<a class="sourceLine" id="cb72-15" title="15">[mod4] qux()</a></code></pre>
    </div>
    <p>
      In addition, a module in one <strong>subpackage</strong> can reference
      objects in a <strong>sibling subpackage</strong> (in the event that the
      sibling contains some functionality that you need). For example, suppose
      you want to import and execute function <code>foo()</code> (defined in
      module <code>mod1</code>) from within module <code>mod3</code>. You can
      either use an <strong>absolute import</strong>:
    </p>
    <p>
      <em><strong>pkg/sub__pkg2/mod3.py</strong></em>
    </p>
    <div class="sourceCode" id="cb73">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb73-1" title="1"><span class="kw">def</span> baz():</a>
<a class="sourceLine" id="cb73-2" title="2">    <span class="bu">print</span>(<span class="st">&#39;[mod3] baz()&#39;</span>)</a>
<a class="sourceLine" id="cb73-3" title="3"></a>
<a class="sourceLine" id="cb73-4" title="4"><span class="kw">class</span> Baz:</a>
<a class="sourceLine" id="cb73-5" title="5">    <span class="cf">pass</span></a>
<a class="sourceLine" id="cb73-6" title="6"></a>
<a class="sourceLine" id="cb73-7" title="7"><span class="im">from</span> pkg.sub_pkg1.mod1 <span class="im">import</span> foo</a>
<a class="sourceLine" id="cb73-8" title="8">foo()</a></code></pre>
    </div>
    <p>&gt;&gt;&gt;</p>
    <div class="sourceCode" id="cb74">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb74-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="im">from</span> pkg.sub_pkg2 <span class="im">import</span> mod3</a>
<a class="sourceLine" id="cb74-2" title="2">[mod1] foo()</a>
<a class="sourceLine" id="cb74-3" title="3"><span class="op">&gt;&gt;&gt;</span> mod3.foo()</a>
<a class="sourceLine" id="cb74-4" title="4">[mod1] foo()</a></code></pre>
    </div>
    <p>
      Or you can use a <strong>relative import</strong>, where
      <code>..</code> refers to the package one level up. From within
      <code>mod3.py</code>, which is in subpackage <code>sub_pkg2</code>,
    </p>
    <ul>
      <li>
        <code>..</code> evaluates to the parent package (<code>pkg</code>), and
      </li>
      <li>
        <code>..sub_pkg1</code> evaluates to subpackage <code>sub_pkg1</code> of
        the parent package.
      </li>
    </ul>
    <p>
      <em><strong>pkg/sub__pkg2/mod3.py</strong></em>
    </p>
    <div class="sourceCode" id="cb75">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb75-1" title="1"><span class="kw">def</span> baz():</a>
<a class="sourceLine" id="cb75-2" title="2">    <span class="bu">print</span>(<span class="st">&#39;[mod3] baz()&#39;</span>)</a>
<a class="sourceLine" id="cb75-3" title="3"></a>
<a class="sourceLine" id="cb75-4" title="4"><span class="kw">class</span> Baz:</a>
<a class="sourceLine" id="cb75-5" title="5">    <span class="cf">pass</span></a>
<a class="sourceLine" id="cb75-6" title="6"></a>
<a class="sourceLine" id="cb75-7" title="7"><span class="im">from</span> .. <span class="im">import</span> sub_pkg1</a>
<a class="sourceLine" id="cb75-8" title="8"><span class="bu">print</span>(sub_pkg1)</a>
<a class="sourceLine" id="cb75-9" title="9"></a>
<a class="sourceLine" id="cb75-10" title="10"><span class="im">from</span> ..sub_pkg1.mod1 <span class="im">import</span> foo</a>
<a class="sourceLine" id="cb75-11" title="11">foo()</a></code></pre>
    </div>
    <p>&gt;&gt;&gt;</p>
    <div class="sourceCode" id="cb76">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb76-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="im">from</span> pkg.sub_pkg2 <span class="im">import</span> mod3</a>
<a class="sourceLine" id="cb76-2" title="2"><span class="op">&lt;</span>module <span class="st">&#39;pkg.sub_pkg1&#39;</span> (namespace)<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb76-3" title="3">[mod1] foo()</a></code></pre>
    </div>
    <h3 id="conclusion">Conclusion</h3>
    <p>In this tutorial, you covered the following topics:</p>
    <ul>
      <li>How to create a Python <strong>module</strong></li>
      <li>Locations where the Python interpreter searches for a module</li>
      <li>
        How to obtain access to the objects defined in a module with the
        <code>import</code> statement
      </li>
      <li>How to create a module that is executable as a standalone script</li>
      <li>
        How to organize modules into <strong>packages</strong> and
        <strong>subpackages</strong>
      </li>
      <li>How to control package initialization</li>
    </ul>
    <p>
      <strong>Free PDF Download:</strong>
      <a href="https://realpython.com/bonus/python-cheat-sheet-short/"
        >Python 3 Cheat Sheet</a
      >
    </p>
    <p>
      This will hopefully allow you to better understand how to gain access to
      the functionality available in the many third-party and built-in modules
      available in Python.
    </p>
    <p>
      Additionally, if you are developing your own application, creating your
      own <strong>modules</strong> and <strong>packages</strong> will help you
      organize and modularize your code, which makes coding, maintenance, and
      debugging easier.
    </p>
    <p>
      If you want to learn more, check out the following documentation at
      <strong>Python.org</strong>:
    </p>
    <h2 id="main__-top-level-script-environment">
      <a href="https://docs.python.org/3/library/__main__.html#module-__main__"
        ><code>__main__</code></a
      >
      — Top-level script environment
    </h2>
    <p>
      <code>'__main__'</code> is the name of the scope in which top-level code
      executes. A module’s __name__ is set equal to <code>'__main__'</code> when
      read from standard input, a script, or from an interactive prompt.
    </p>
    <p>
      A module can discover whether or not it is running in the main scope by
      checking its own <code>__name__</code>, which allows a common idiom for
      conditionally executing code in a module when it is run as a script or
      with <code>python -m</code> but not when it is imported:
    </p>
    <div class="sourceCode" id="cb77">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb77-1" title="1"><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</a>
<a class="sourceLine" id="cb77-2" title="2">    <span class="co"># execute only if run as a script</span></a>
<a class="sourceLine" id="cb77-3" title="3">    main()</a></code></pre>
    </div>
    <p>
      For a package, the same effect can be achieved by including a
      <code>__main__.py</code> module, the contents of which will be executed
      when the module is run
    </p>
    <h2 id="the-import-system">. The import system</h2>
    <p>
      Python code in one
      <a href="https://docs.python.org/3/glossary.html#term-module">module</a>
      gains access to the code in another module by the process of
      <a href="https://docs.python.org/3/glossary.html#term-importing"
        >importing</a
      >
      it. The
      <a href="https://docs.python.org/3/reference/simple_stmts.html#import"
        ><code>import</code></a
      >
      statement is the most common way of invoking the import machinery, but it
      is not the only way. Functions such as
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.import_module"
        ><code>importlib.import_module()</code></a
      >
      and built-in
      <a href="https://docs.python.org/3/library/functions.html#__import__"
        ><code>__import__()</code></a
      >
      can also be used to invoke the import machinery.
    </p>
    <p>
      The
      <a href="https://docs.python.org/3/reference/simple_stmts.html#import"
        ><code>import</code></a
      >
      statement combines two operations; it searches for the named module, then
      it binds the results of that search to a name in the local scope. The
      search operation of the <code>import</code> statement is defined as a call
      to the
      <a href="https://docs.python.org/3/library/functions.html#__import__"
        ><code>__import__()</code></a
      >
      function, with the appropriate arguments. The return value of
      <a href="https://docs.python.org/3/library/functions.html#__import__"
        ><code>__import__()</code></a
      >
      is used to perform the name binding operation of the
      <code>import</code> statement. See the <code>import</code> statement for
      the exact details of that name binding operation.
    </p>
    <p>
      A direct call to
      <a href="https://docs.python.org/3/library/functions.html#__import__"
        ><code>__import__()</code></a
      >
      performs only the module search and, if found, the module creation
      operation. While certain side-effects may occur, such as the importing of
      parent packages, and the updating of various caches (including
      <a href="https://docs.python.org/3/library/sys.html#sys.modules"
        ><code>sys.modules</code></a
      >), only the
      <a href="https://docs.python.org/3/reference/simple_stmts.html#import"
        ><code>import</code></a
      >
      statement performs a name binding operation.
    </p>
    <p>
      When an
      <a href="https://docs.python.org/3/reference/simple_stmts.html#import"
        ><code>import</code></a
      >
      statement is executed, the standard builtin
      <a href="https://docs.python.org/3/library/functions.html#__import__"
        ><code>__import__()</code></a
      >
      function is called. Other mechanisms for invoking the import system (such
      as
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.import_module"
        ><code>importlib.import_module()</code></a
      >) may choose to bypass
      <a href="https://docs.python.org/3/library/functions.html#__import__"
        ><code>__import__()</code></a
      >
      and use their own solutions to implement import semantics.
    </p>
    <p>
      When a module is first imported, Python searches for the module and if
      found, it creates a module object
      <a href="https://docs.python.org/3/reference/import.html#fnmo">1</a>,
      initializing it. If the named module cannot be found, a
      <a
        href="https://docs.python.org/3/library/exceptions.html#ModuleNotFoundError"
        ><code>ModuleNotFoundError</code></a
      >
      is raised. Python implements various strategies to search for the named
      module when the import machinery is invoked. These strategies can be
      modified and extended by using various hooks described in the sections
      below.
    </p>
    <p>
      Changed in version 3.3: The import system has been updated to fully
      implement the second phase of
      <a href="https://www.python.org/dev/peps/pep-0302"
        ><strong>PEP 302</strong></a
      >. There is no longer any implicit import machinery - the full import
      system is exposed through
      <a href="https://docs.python.org/3/library/sys.html#sys.meta_path"
        ><code>sys.meta_path</code></a
      >. In addition, native namespace package support has been implemented (see
      <a href="https://www.python.org/dev/peps/pep-0420"
        ><strong>PEP 420</strong></a
      >).
    </p>
    <h3 id="importlib">
      5.1.
      <a
        href="https://docs.python.org/3/library/importlib.html#module-importlib"
        ><code>importlib</code></a
      >
    </h3>
    <p>
      The
      <a
        href="https://docs.python.org/3/library/importlib.html#module-importlib"
        ><code>importlib</code></a
      >
      module provides a rich API for interacting with the import system. For
      example
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.import_module"
        ><code>importlib.import_module()</code></a
      >
      provides a recommended, simpler API than built-in
      <a href="https://docs.python.org/3/library/functions.html#__import__"
        ><code>__import__()</code></a
      >
      for invoking the import machinery. Refer to the
      <a
        href="https://docs.python.org/3/library/importlib.html#module-importlib"
        ><code>importlib</code></a
      >
      library documentation for additional detail.
    </p>
    <h3 id="packages">5.2. Packages</h3>
    <p>
      Python has only one type of module object, and all modules are of this
      type, regardless of whether the module is implemented in Python, C, or
      something else. To help organize modules and provide a naming hierarchy,
      Python has a concept of
      <a href="https://docs.python.org/3/glossary.html#term-package">packages</a
      >.
    </p>
    <p>
      You can think of packages as the directories on a file system and modules
      as files within directories, but don’t take this analogy too literally
      since packages and modules need not originate from the file system. For
      the purposes of this documentation, we’ll use this convenient analogy of
      directories and files. Like file system directories, packages are
      organized hierarchically, and packages may themselves contain subpackages,
      as well as regular modules.
    </p>
    <p>
      It’s important to keep in mind that all packages are modules, but not all
      modules are packages. Or put another way, packages are just a special kind
      of module. Specifically, any module that contains a
      <code>__path__</code> attribute is considered a package.
    </p>
    <p>
      All modules have a name. Subpackage names are separated from their parent
      package name by a dot, akin to Python’s standard attribute access syntax.
      Thus you might have a module called
      <a href="https://docs.python.org/3/library/sys.html#module-sys"
        ><code>sys</code></a
      >
      and a package called
      <a href="https://docs.python.org/3/library/email.html#module-email"
        ><code>email</code></a
      >, which in turn has a subpackage called
      <a
        href="https://docs.python.org/3/library/email.mime.html#module-email.mime"
        ><code>email.mime</code></a
      >
      and a module within that subpackage called <code>email.mime.text</code>.
    </p>
    <h4 id="regular-packages">5.2.1. Regular packages</h4>
    <p>
      Python defines two types of packages,
      <a href="https://docs.python.org/3/glossary.html#term-regular-package"
        >regular packages</a
      >
      and
      <a href="https://docs.python.org/3/glossary.html#term-namespace-package"
        >namespace packages</a
      >. Regular packages are traditional packages as they existed in Python 3.2
      and earlier. A regular package is typically implemented as a directory
      containing an <code>__init__.py</code> file. When a regular package is
      imported, this <code>__init__.py</code> file is implicitly executed, and
      the objects it defines are bound to names in the package’s namespace. The
      <code>__init__.py</code> file can contain the same Python code that any
      other module can contain, and Python will add some additional attributes
      to the module when it is imported.
    </p>
    <p>
      For example, the following file system layout defines a top level
      <code>parent</code> package with three subpackages:
    </p>
    <div class="sourceCode" id="cb78">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb78-1" title="1">parent<span class="op">/</span></a>
<a class="sourceLine" id="cb78-2" title="2">    <span class="fu">__init__</span>.py</a>
<a class="sourceLine" id="cb78-3" title="3">    one<span class="op">/</span></a>
<a class="sourceLine" id="cb78-4" title="4">        <span class="fu">__init__</span>.py</a>
<a class="sourceLine" id="cb78-5" title="5">    two<span class="op">/</span></a>
<a class="sourceLine" id="cb78-6" title="6">        <span class="fu">__init__</span>.py</a>
<a class="sourceLine" id="cb78-7" title="7">    three<span class="op">/</span></a>
<a class="sourceLine" id="cb78-8" title="8">        <span class="fu">__init__</span>.py</a></code></pre>
    </div>
    <p>
      Importing <code>parent.one</code> will implicitly execute
      <code>parent/__init__.py</code> and <code>parent/one/__init__.py</code>.
      Subsequent imports of <code>parent.two</code> or
      <code>parent.three</code> will execute
      <code>parent/two/__init__.py</code> and
      <code>parent/three/__init__.py</code> respectively.
    </p>
    <h4 id="namespace-packages">5.2.2. Namespace packages</h4>
    <p>
      A namespace package is a composite of various
      <a href="https://docs.python.org/3/glossary.html#term-portion">portions</a
      >, where each portion contributes a subpackage to the parent package.
      Portions may reside in different locations on the file system. Portions
      may also be found in zip files, on the network, or anywhere else that
      Python searches during import. Namespace packages may or may not
      correspond directly to objects on the file system; they may be virtual
      modules that have no concrete representation.
    </p>
    <p>
      Namespace packages do not use an ordinary list for their
      <code>__path__</code> attribute. They instead use a custom iterable type
      which will automatically perform a new search for package portions on the
      next import attempt within that package if the path of their parent
      package (or
      <a href="https://docs.python.org/3/library/sys.html#sys.path"
        ><code>sys.path</code></a
      >
      for a top level package) changes.
    </p>
    <p>
      With namespace packages, there is no <code>parent/__init__.py</code> file.
      In fact, there may be multiple <code>parent</code> directories found
      during import search, where each one is provided by a different portion.
      Thus <code>parent/one</code> may not be physically located next to
      <code>parent/two</code>. In this case, Python will create a namespace
      package for the top-level <code>parent</code> package whenever it or one
      of its subpackages is imported.
    </p>
    <p>
      See also
      <a href="https://www.python.org/dev/peps/pep-0420"
        ><strong>PEP 420</strong></a
      >
      for the namespace package specification.
    </p>
    <h3 id="searching">5.3. Searching</h3>
    <p>
      To begin the search, Python needs the
      <a href="https://docs.python.org/3/glossary.html#term-qualified-name"
        >fully qualified</a
      >
      name of the module (or package, but for the purposes of this discussion,
      the difference is immaterial) being imported. This name may come from
      various arguments to the
      <a href="https://docs.python.org/3/reference/simple_stmts.html#import"
        ><code>import</code></a
      >
      statement, or from the parameters to the
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.import_module"
        ><code>importlib.import_module()</code></a
      >
      or
      <a href="https://docs.python.org/3/library/functions.html#__import__"
        ><code>__import__()</code></a
      >
      functions.
    </p>
    <p>
      This name will be used in various phases of the import search, and it may
      be the dotted path to a submodule, e.g. <code>foo.bar.baz</code>. In this
      case, Python first tries to import <code>foo</code>, then
      <code>foo.bar</code>, and finally <code>foo.bar.baz</code>. If any of the
      intermediate imports fail, a
      <a
        href="https://docs.python.org/3/library/exceptions.html#ModuleNotFoundError"
        ><code>ModuleNotFoundError</code></a
      >
      is raised.
    </p>
    <h4 id="the-module-cache">5.3.1. The module cache</h4>
    <p>
      The first place checked during import search is
      <a href="https://docs.python.org/3/library/sys.html#sys.modules"
        ><code>sys.modules</code></a
      >. This mapping serves as a cache of all modules that have been previously
      imported, including the intermediate paths. So if
      <code>foo.bar.baz</code> was previously imported,
      <a href="https://docs.python.org/3/library/sys.html#sys.modules"
        ><code>sys.modules</code></a
      >
      will contain entries for <code>foo</code>, <code>foo.bar</code>, and
      <code>foo.bar.baz</code>. Each key will have as its value the
      corresponding module object.
    </p>
    <p>
      During import, the module name is looked up in
      <a href="https://docs.python.org/3/library/sys.html#sys.modules"
        ><code>sys.modules</code></a
      >
      and if present, the associated value is the module satisfying the import,
      and the process completes. However, if the value is <code>None</code>,
      then a
      <a
        href="https://docs.python.org/3/library/exceptions.html#ModuleNotFoundError"
        ><code>ModuleNotFoundError</code></a
      >
      is raised. If the module name is missing, Python will continue searching
      for the module.
    </p>
    <p>
      <a href="https://docs.python.org/3/library/sys.html#sys.modules"
        ><code>sys.modules</code></a
      >
      is writable. Deleting a key may not destroy the associated module (as
      other modules may hold references to it), but it will invalidate the cache
      entry for the named module, causing Python to search anew for the named
      module upon its next import. The key can also be assigned to
      <code>None</code>, forcing the next import of the module to result in a
      <a
        href="https://docs.python.org/3/library/exceptions.html#ModuleNotFoundError"
        ><code>ModuleNotFoundError</code></a
      >.
    </p>
    <p>
      Beware though, as if you keep a reference to the module object, invalidate
      its cache entry in
      <a href="https://docs.python.org/3/library/sys.html#sys.modules"
        ><code>sys.modules</code></a
      >, and then re-import the named module, the two module objects will
      <em>not</em> be the same. By contrast,
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.reload"
        ><code>importlib.reload()</code></a
      >
      will reuse the <em>same</em> module object, and simply reinitialise the
      module contents by rerunning the module’s code.
    </p>
    <h4 id="finders-and-loaders">5.3.2. Finders and loaders</h4>
    <p>
      If the named module is not found in
      <a href="https://docs.python.org/3/library/sys.html#sys.modules"
        ><code>sys.modules</code></a
      >, then Python’s import protocol is invoked to find and load the module.
      This protocol consists of two conceptual objects,
      <a href="https://docs.python.org/3/glossary.html#term-finder">finders</a>
      and
      <a href="https://docs.python.org/3/glossary.html#term-loader">loaders</a>.
      A finder’s job is to determine whether it can find the named module using
      whatever strategy it knows about. Objects that implement both of these
      interfaces are referred to as
      <a href="https://docs.python.org/3/glossary.html#term-importer"
        >importers</a
      >
      - they return themselves when they find that they can load the requested
      module.
    </p>
    <p>
      Python includes a number of default finders and importers. The first one
      knows how to locate built-in modules, and the second knows how to locate
      frozen modules. A third default finder searches an
      <a href="https://docs.python.org/3/glossary.html#term-import-path"
        >import path</a
      >
      for modules. The
      <a href="https://docs.python.org/3/glossary.html#term-import-path"
        >import path</a
      >
      is a list of locations that may name file system paths or zip files. It
      can also be extended to search for any locatable resource, such as those
      identified by URLs.
    </p>
    <p>
      The import machinery is extensible, so new finders can be added to extend
      the range and scope of module searching.
    </p>
    <p>
      Finders do not actually load modules. If they can find the named module,
      they return a <em>module spec</em>, an encapsulation of the module’s
      import-related information, which the import machinery then uses when
      loading the module.
    </p>
    <p>
      The following sections describe the protocol for finders and loaders in
      more detail, including how you can create and register new ones to extend
      the import machinery.
    </p>
    <p>
      Changed in version 3.4: In previous versions of Python, finders returned
      <a href="https://docs.python.org/3/glossary.html#term-loader">loaders</a>
      directly, whereas now they return module specs which
      <em>contain</em> loaders. Loaders are still used during import but have
      fewer responsibilities.
    </p>
    <h4 id="import-hooks">5.3.3. Import hooks</h4>
    <p>
      The import machinery is designed to be extensible; the primary mechanism
      for this are the <em>import hooks</em>. There are two types of import
      hooks: <em>meta hooks</em> and <em>import path hooks</em>.
    </p>
    <p>
      Meta hooks are called at the start of import processing, before any other
      import processing has occurred, other than
      <a href="https://docs.python.org/3/library/sys.html#sys.modules"
        ><code>sys.modules</code></a
      >
      cache look up. This allows meta hooks to override
      <a href="https://docs.python.org/3/library/sys.html#sys.path"
        ><code>sys.path</code></a
      >
      processing, frozen modules, or even built-in modules. Meta hooks are
      registered by adding new finder objects to
      <a href="https://docs.python.org/3/library/sys.html#sys.meta_path"
        ><code>sys.meta_path</code></a
      >, as described below.
    </p>
    <p>
      Import path hooks are called as part of
      <a href="https://docs.python.org/3/library/sys.html#sys.path"
        ><code>sys.path</code></a
      >
      (or <code>package.__path__</code>) processing, at the point where their
      associated path item is encountered. Import path hooks are registered by
      adding new callables to
      <a href="https://docs.python.org/3/library/sys.html#sys.path_hooks"
        ><code>sys.path_hooks</code></a
      >
      as described below.
    </p>
    <h4 id="the-meta-path">5.3.4. The meta path</h4>
    <p>
      When the named module is not found in
      <a href="https://docs.python.org/3/library/sys.html#sys.modules"
        ><code>sys.modules</code></a
      >, Python next searches
      <a href="https://docs.python.org/3/library/sys.html#sys.meta_path"
        ><code>sys.meta_path</code></a
      >, which contains a list of meta path finder objects. These finders are
      queried in order to see if they know how to handle the named module. Meta
      path finders must implement a method called
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.abc.MetaPathFinder.find_spec"
        ><code>find_spec()</code></a
      >
      which takes three arguments: a name, an import path, and (optionally) a
      target module. The meta path finder can use any strategy it wants to
      determine whether it can handle the named module or not.
    </p>
    <p>
      If the meta path finder knows how to handle the named module, it returns a
      spec object. If it cannot handle the named module, it returns
      <code>None</code>. If
      <a href="https://docs.python.org/3/library/sys.html#sys.meta_path"
        ><code>sys.meta_path</code></a
      >
      processing reaches the end of its list without returning a spec, then a
      <a
        href="https://docs.python.org/3/library/exceptions.html#ModuleNotFoundError"
        ><code>ModuleNotFoundError</code></a
      >
      is raised. Any other exceptions raised are simply propagated up, aborting
      the import process.
    </p>
    <p>
      The
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.abc.MetaPathFinder.find_spec"
        ><code>find_spec()</code></a
      >
      method of meta path finders is called with two or three arguments. The
      first is the fully qualified name of the module being imported, for
      example <code>foo.bar.baz</code>. The second argument is the path entries
      to use for the module search. For top-level modules, the second argument
      is <code>None</code>, but for submodules or subpackages, the second
      argument is the value of the parent package’s
      <code>__path__</code> attribute. If the appropriate
      <code>__path__</code> attribute cannot be accessed, a
      <a
        href="https://docs.python.org/3/library/exceptions.html#ModuleNotFoundError"
        ><code>ModuleNotFoundError</code></a
      >
      is raised. The third argument is an existing module object that will be
      the target of loading later. The import system passes in a target module
      only during reload.
    </p>
    <p>
      The meta path may be traversed multiple times for a single import request.
      For example, assuming none of the modules involved has already been
      cached, importing <code>foo.bar.baz</code> will first perform a top level
      import, calling <code>mpf.find_spec("foo", None, None)</code> on each meta
      path finder (<code>mpf</code>). After <code>foo</code> has been imported,
      <code>foo.bar</code> will be imported by traversing the meta path a second
      time, calling <code>mpf.find_spec("foo.bar", foo.__path__, None)</code>.
      Once <code>foo.bar</code> has been imported, the final traversal will call
      <code>mpf.find_spec("foo.bar.baz", foo.bar.__path__, None)</code>.
    </p>
    <p>
      Some meta path finders only support top level imports. These importers
      will always return <code>None</code> when anything other than
      <code>None</code> is passed as the second argument.
    </p>
    <p>
      Python’s default
      <a href="https://docs.python.org/3/library/sys.html#sys.meta_path"
        ><code>sys.meta_path</code></a
      >
      has three meta path finders, one that knows how to import built-in
      modules, one that knows how to import frozen modules, and one that knows
      how to import modules from an
      <a href="https://docs.python.org/3/glossary.html#term-import-path"
        >import path</a
      >
      (i.e. the
      <a href="https://docs.python.org/3/glossary.html#term-path-based-finder"
        >path based finder</a
      >).
    </p>
    <p>
      Changed in version 3.4: The
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.abc.MetaPathFinder.find_spec"
        ><code>find_spec()</code></a
      >
      method of meta path finders replaced
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.abc.MetaPathFinder.find_module"
        ><code>find_module()</code></a
      >, which is now deprecated. While it will continue to work without change,
      the import machinery will try it only if the finder does not implement
      <code>find_spec()</code>.
    </p>
    <h3 id="loading">5.4. Loading</h3>
    <p>
      If and when a module spec is found, the import machinery will use it (and
      the loader it contains) when loading the module. Here is an approximation
      of what happens during the loading portion of import:
    </p>
    <div class="sourceCode" id="cb79">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb79-1" title="1">module <span class="op">=</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb79-2" title="2"><span class="cf">if</span> spec.loader <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="kw">and</span> <span class="bu">hasattr</span>(spec.loader, <span class="st">&#39;create_module&#39;</span>):</a>
<a class="sourceLine" id="cb79-3" title="3">    <span class="co"># It is assumed &#39;exec_module&#39; will also be defined on the loader.</span></a>
<a class="sourceLine" id="cb79-4" title="4">    module <span class="op">=</span> spec.loader.create_module(spec)</a>
<a class="sourceLine" id="cb79-5" title="5"><span class="cf">if</span> module <span class="kw">is</span> <span class="va">None</span>:</a>
<a class="sourceLine" id="cb79-6" title="6">    module <span class="op">=</span> ModuleType(spec.name)</a>
<a class="sourceLine" id="cb79-7" title="7"><span class="co"># The import-related module attributes get set here:</span></a>
<a class="sourceLine" id="cb79-8" title="8">_init_module_attrs(spec, module)</a>
<a class="sourceLine" id="cb79-9" title="9"></a>
<a class="sourceLine" id="cb79-10" title="10"><span class="cf">if</span> spec.loader <span class="kw">is</span> <span class="va">None</span>:</a>
<a class="sourceLine" id="cb79-11" title="11">    <span class="co"># unsupported</span></a>
<a class="sourceLine" id="cb79-12" title="12">    <span class="cf">raise</span> <span class="pp">ImportError</span></a>
<a class="sourceLine" id="cb79-13" title="13"><span class="cf">if</span> spec.origin <span class="kw">is</span> <span class="va">None</span> <span class="kw">and</span> spec.submodule_search_locations <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</a>
<a class="sourceLine" id="cb79-14" title="14">    <span class="co"># namespace package</span></a>
<a class="sourceLine" id="cb79-15" title="15">    sys.modules[spec.name] <span class="op">=</span> module</a>
<a class="sourceLine" id="cb79-16" title="16"><span class="cf">elif</span> <span class="kw">not</span> <span class="bu">hasattr</span>(spec.loader, <span class="st">&#39;exec_module&#39;</span>):</a>
<a class="sourceLine" id="cb79-17" title="17">    module <span class="op">=</span> spec.loader.load_module(spec.name)</a>
<a class="sourceLine" id="cb79-18" title="18">    <span class="co"># Set __loader__ and __package__ if missing.</span></a>
<a class="sourceLine" id="cb79-19" title="19"><span class="cf">else</span>:</a>
<a class="sourceLine" id="cb79-20" title="20">    sys.modules[spec.name] <span class="op">=</span> module</a>
<a class="sourceLine" id="cb79-21" title="21">    <span class="cf">try</span>:</a>
<a class="sourceLine" id="cb79-22" title="22">        spec.loader.exec_module(module)</a>
<a class="sourceLine" id="cb79-23" title="23">    <span class="cf">except</span> <span class="pp">BaseException</span>:</a>
<a class="sourceLine" id="cb79-24" title="24">        <span class="cf">try</span>:</a>
<a class="sourceLine" id="cb79-25" title="25">            <span class="kw">del</span> sys.modules[spec.name]</a>
<a class="sourceLine" id="cb79-26" title="26">        <span class="cf">except</span> <span class="pp">KeyError</span>:</a>
<a class="sourceLine" id="cb79-27" title="27">            <span class="cf">pass</span></a>
<a class="sourceLine" id="cb79-28" title="28">        <span class="cf">raise</span></a>
<a class="sourceLine" id="cb79-29" title="29"><span class="cf">return</span> sys.modules[spec.name]</a></code></pre>
    </div>
    <p>Note the following details:</p>
    <blockquote>
      <ul>
        <li>
          If there is an existing module object with the given name in
          <a href="https://docs.python.org/3/library/sys.html#sys.modules"
            ><code>sys.modules</code></a
          >, import will have already returned it.
        </li>
        <li>
          The module will exist in
          <a href="https://docs.python.org/3/library/sys.html#sys.modules"
            ><code>sys.modules</code></a
          >
          before the loader executes the module code. This is crucial because
          the module code may (directly or indirectly) import itself; adding it
          to
          <a href="https://docs.python.org/3/library/sys.html#sys.modules"
            ><code>sys.modules</code></a
          >
          beforehand prevents unbounded recursion in the worst case and multiple
          loading in the best.
        </li>
        <li>
          If loading fails, the failing module – and only the failing module –
          gets removed from
          <a href="https://docs.python.org/3/library/sys.html#sys.modules"
            ><code>sys.modules</code></a
          >. Any module already in the
          <a href="https://docs.python.org/3/library/sys.html#sys.modules"
            ><code>sys.modules</code></a
          >
          cache, and any module that was successfully loaded as a side-effect,
          must remain in the cache. This contrasts with reloading where even the
          failing module is left in
          <a href="https://docs.python.org/3/library/sys.html#sys.modules"
            ><code>sys.modules</code></a
          >.
        </li>
        <li>
          After the module is created but before execution, the import machinery
          sets the import-related module attributes (“_init_module_attrs” in the
          pseudo-code example above), as summarized in a
          <a
            href="https://docs.python.org/3/reference/import.html#import-mod-attrs"
            >later section</a
          >.
        </li>
        <li>
          Module execution is the key moment of loading in which the module’s
          namespace gets populated. Execution is entirely delegated to the
          loader, which gets to decide what gets populated and how.
        </li>
        <li>
          The module created during loading and passed to exec_module() may not
          be the one returned at the end of import
          <a href="https://docs.python.org/3/reference/import.html#fnlo">2</a>.
        </li>
      </ul>
    </blockquote>
    <p>
      Changed in version 3.4: The import system has taken over the boilerplate
      responsibilities of loaders. These were previously performed by the
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.abc.Loader.load_module"
        ><code>importlib.abc.Loader.load_module()</code></a
      >
      method.
    </p>
    <h4 id="loaders">5.4.1. Loaders</h4>
    <p>
      Module loaders provide the critical function of loading: module execution.
      The import machinery calls the
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.abc.Loader.exec_module"
        ><code>importlib.abc.Loader.exec_module()</code></a
      >
      method with a single argument, the module object to execute. Any value
      returned from
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.abc.Loader.exec_module"
        ><code>exec_module()</code></a
      >
      is ignored.
    </p>
    <p>Loaders must satisfy the following requirements:</p>
    <blockquote>
      <ul>
        <li>
          If the module is a Python module (as opposed to a built-in module or a
          dynamically loaded extension), the loader should execute the module’s
          code in the module’s global name space (<code>module.__dict__</code>).
        </li>
        <li>
          If the loader cannot execute the module, it should raise an
          <a
            href="https://docs.python.org/3/library/exceptions.html#ImportError"
            ><code>ImportError</code></a
          >, although any other exception raised during
          <a
            href="https://docs.python.org/3/library/importlib.html#importlib.abc.Loader.exec_module"
            ><code>exec_module()</code></a
          >
          will be propagated.
        </li>
      </ul>
    </blockquote>
    <p>
      In many cases, the finder and loader can be the same object; in such cases
      the
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.abc.MetaPathFinder.find_spec"
        ><code>find_spec()</code></a
      >
      method would just return a spec with the loader set to <code>self</code>.
    </p>
    <p>
      Module loaders may opt in to creating the module object during loading by
      implementing a
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.abc.Loader.create_module"
        ><code>create_module()</code></a
      >
      method. It takes one argument, the module spec, and returns the new module
      object to use during loading. <code>create_module()</code> does not need
      to set any attributes on the module object. If the method returns
      <code>None</code>, the import machinery will create the new module itself.
    </p>
    <p>
      New in version 3.4: The
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.abc.Loader.create_module"
        ><code>create_module()</code></a
      >
      method of loaders.
    </p>
    <p>
      Changed in version 3.4: The
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.abc.Loader.load_module"
        ><code>load_module()</code></a
      >
      method was replaced by
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.abc.Loader.exec_module"
        ><code>exec_module()</code></a
      >
      and the import machinery assumed all the boilerplate responsibilities of
      loading.
    </p>
    <p>
      For compatibility with existing loaders, the import machinery will use the
      <code>load_module()</code> method of loaders if it exists and the loader
      does not also implement <code>exec_module()</code>. However,
      <code>load_module()</code> has been deprecated and loaders should
      implement <code>exec_module()</code> instead.
    </p>
    <p>
      The <code>load_module()</code> method must implement all the boilerplate
      loading functionality described above in addition to executing the module.
      All the same constraints apply, with some additional clarification:
    </p>
    <blockquote>
      <ul>
        <li>
          If there is an existing module object with the given name in
          <a href="https://docs.python.org/3/library/sys.html#sys.modules"
            ><code>sys.modules</code></a
          >, the loader must use that existing module. (Otherwise,
          <a
            href="https://docs.python.org/3/library/importlib.html#importlib.reload"
            ><code>importlib.reload()</code></a
          >
          will not work correctly.) If the named module does not exist in
          <a href="https://docs.python.org/3/library/sys.html#sys.modules"
            ><code>sys.modules</code></a
          >, the loader must create a new module object and add it to
          <a href="https://docs.python.org/3/library/sys.html#sys.modules"
            ><code>sys.modules</code></a
          >.
        </li>
        <li>
          The module <em>must</em> exist in
          <a href="https://docs.python.org/3/library/sys.html#sys.modules"
            ><code>sys.modules</code></a
          >
          before the loader executes the module code, to prevent unbounded
          recursion or multiple loading.
        </li>
        <li>
          If loading fails, the loader must remove any modules it has inserted
          into
          <a href="https://docs.python.org/3/library/sys.html#sys.modules"
            ><code>sys.modules</code></a
          >, but it must remove <strong>only</strong> the failing module(s), and
          only if the loader itself has loaded the module(s) explicitly.
        </li>
      </ul>
    </blockquote>
    <p>
      Changed in version 3.5: A
      <a
        href="https://docs.python.org/3/library/exceptions.html#DeprecationWarning"
        ><code>DeprecationWarning</code></a
      >
      is raised when <code>exec_module()</code> is defined but
      <code>create_module()</code> is not.
    </p>
    <p>
      Changed in version 3.6: An
      <a href="https://docs.python.org/3/library/exceptions.html#ImportError"
        ><code>ImportError</code></a
      >
      is raised when <code>exec_module()</code> is defined but
      <code>create_module()</code> is not.
    </p>
    <h4 id="submodules">5.4.2. Submodules</h4>
    <p>
      When a submodule is loaded using any mechanism (e.g. <code
        >importlib</code
      >
      APIs, the <code>import</code> or <code>import-from</code> statements, or
      built-in <code>__import__()</code>) a binding is placed in the parent
      module’s namespace to the submodule object. For example, if package
      <code>spam</code> has a submodule <code>foo</code>, after importing
      <code>spam.foo</code>, <code>spam</code> will have an attribute
      <code>foo</code> which is bound to the submodule. Let’s say you have the
      following directory structure:
    </p>
    <div class="sourceCode" id="cb80">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb80-1" title="1">spam<span class="op">/</span></a>
<a class="sourceLine" id="cb80-2" title="2">    <span class="fu">__init__</span>.py</a>
<a class="sourceLine" id="cb80-3" title="3">    foo.py</a>
<a class="sourceLine" id="cb80-4" title="4">    bar.py</a></code></pre>
    </div>
    <p>and <code>spam/__init__.py</code> has the following lines in it:</p>
    <div class="sourceCode" id="cb81">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb81-1" title="1"><span class="im">from</span> .foo <span class="im">import</span> Foo</a>
<a class="sourceLine" id="cb81-2" title="2"><span class="im">from</span> .bar <span class="im">import</span> Bar</a></code></pre>
    </div>
    <p>
      then executing the following puts a name binding to <code>foo</code> and
      <code>bar</code> in the <code>spam</code> module:&gt;&gt;&gt;
    </p>
    <div class="sourceCode" id="cb82">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb82-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> spam</a>
<a class="sourceLine" id="cb82-2" title="2"><span class="op">&gt;&gt;&gt;</span> spam.foo</a>
<a class="sourceLine" id="cb82-3" title="3"><span class="op">&lt;</span>module <span class="st">&#39;spam.foo&#39;</span> <span class="im">from</span> <span class="st">&#39;/tmp/imports/spam/foo.py&#39;</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb82-4" title="4"><span class="op">&gt;&gt;&gt;</span> spam.bar</a>
<a class="sourceLine" id="cb82-5" title="5"><span class="op">&lt;</span>module <span class="st">&#39;spam.bar&#39;</span> <span class="im">from</span> <span class="st">&#39;/tmp/imports/spam/bar.py&#39;</span><span class="op">&gt;</span></a></code></pre>
    </div>
    <p>
      Given Python’s familiar name binding rules this might seem surprising, but
      it’s actually a fundamental feature of the import system. The invariant
      holding is that if you have <code>sys.modules['spam']</code> and
      <code>sys.modules['spam.foo']</code> (as you would after the above
      import), the latter must appear as the <code>foo</code> attribute of the
      former.
    </p>
    <h4 id="module-spec">5.4.3. Module spec</h4>
    <p>
      The import machinery uses a variety of information about each module
      during import, especially before loading. Most of the information is
      common to all modules. The purpose of a module’s spec is to encapsulate
      this import-related information on a per-module basis.
    </p>
    <p>
      Using a spec during import allows state to be transferred between import
      system components, e.g. between the finder that creates the module spec
      and the loader that executes it. Most importantly, it allows the import
      machinery to perform the boilerplate operations of loading, whereas
      without a module spec the loader had that responsibility.
    </p>
    <p>
      The module’s spec is exposed as the <code>__spec__</code> attribute on a
      module object. See
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.machinery.ModuleSpec"
        ><code>ModuleSpec</code></a
      >
      for details on the contents of the module spec.
    </p>
    <p>New in version 3.4.</p>
    <h4 id="import-related-module-attributes">
      5.4.4. Import-related module attributes
    </h4>
    <p>
      The import machinery fills in these attributes on each module object
      during loading, based on the module’s spec, before the loader executes the
      module.<code>__name__</code>
    </p>
    <p>
      The <code>__name__</code> attribute must be set to the fully-qualified
      name of the module. This name is used to uniquely identify the module in
      the import system.<code>__loader__</code>
    </p>
    <p>
      The <code>__loader__</code> attribute must be set to the loader object
      that the import machinery used when loading the module. This is mostly for
      introspection, but can be used for additional loader-specific
      functionality, for example getting data associated with a loader.<code
        >__package__</code
      >
    </p>
    <p>
      The module’s <code>__package__</code> attribute must be set. Its value
      must be a string, but it can be the same value as its
      <code>__name__</code>. When the module is a package, its
      <code>__package__</code> value should be set to its <code>__name__</code>.
      When the module is not a package, <code>__package__</code> should be set
      to the empty string for top-level modules, or for submodules, to the
      parent package’s name. See
      <a href="https://www.python.org/dev/peps/pep-0366"
        ><strong>PEP 366</strong></a
      >
      for further details.
    </p>
    <p>
      This attribute is used instead of <code>__name__</code> to calculate
      explicit relative imports for main modules, as defined in
      <a href="https://www.python.org/dev/peps/pep-0366"
        ><strong>PEP 366</strong></a
      >. It is expected to have the same value as <code>__spec__.parent</code>.
    </p>
    <p>
      Changed in version 3.6: The value of <code>__package__</code> is expected
      to be the same as <code>__spec__.parent</code>.<code>__spec__</code>
    </p>
    <p>
      The <code>__spec__</code> attribute must be set to the module spec that
      was used when importing the module. Setting
      <code>__spec__</code> appropriately applies equally to
      <a
        href="https://docs.python.org/3/reference/toplevel_components.html#programs"
        >modules initialized during interpreter startup</a
      >. The one exception is <code>__main__</code>, where
      <code>__spec__</code> is
      <a href="https://docs.python.org/3/reference/import.html#main-spec"
        >set to None in some cases</a
      >.
    </p>
    <p>
      When <code>__package__</code> is not defined,
      <code>__spec__.parent</code> is used as a fallback.
    </p>
    <p>New in version 3.4.</p>
    <p>
      Changed in version 3.6: <code>__spec__.parent</code> is used as a fallback
      when <code>__package__</code> is not defined.<code>__path__</code>
    </p>
    <p>
      If the module is a package (either regular or namespace), the module
      object’s <code>__path__</code> attribute must be set. The value must be
      iterable, but may be empty if <code>__path__</code> has no further
      significance. If <code>__path__</code> is not empty, it must produce
      strings when iterated over. More details on the semantics of
      <code>__path__</code> are given
      <a
        href="https://docs.python.org/3/reference/import.html#package-path-rules"
        >below</a
      >.
    </p>
    <p>
      Non-package modules should not have a
      <code>__path__</code> attribute.<code>__file____cached__</code>
    </p>
    <p>
      <code>__file__</code> is optional. If set, this attribute’s value must be
      a string. The import system may opt to leave <code>__file__</code> unset
      if it has no semantic meaning (e.g. a module loaded from a database).
    </p>
    <p>
      If <code>__file__</code> is set, it may also be appropriate to set the
      <code>__cached__</code> attribute which is the path to any compiled
      version of the code (e.g. byte-compiled file). The file does not need to
      exist to set this attribute; the path can simply point to where the
      compiled file would exist (see
      <a href="https://www.python.org/dev/peps/pep-3147"
        ><strong>PEP 3147</strong></a
      >).
    </p>
    <p>
      It is also appropriate to set <code>__cached__</code> when
      <code>__file__</code> is not set. However, that scenario is quite
      atypical. Ultimately, the loader is what makes use of
      <code>__file__</code> and/or <code>__cached__</code>. So if a loader can
      load from a cached module but otherwise does not load from a file, that
      atypical scenario may be appropriate.
    </p>
    <h4 id="module.__path__">5.4.5. module.__path__</h4>
    <p>
      By definition, if a module has a <code>__path__</code> attribute, it is a
      package.
    </p>
    <p>
      A package’s <code>__path__</code> attribute is used during imports of its
      subpackages. Within the import machinery, it functions much the same as
      <a href="https://docs.python.org/3/library/sys.html#sys.path"
        ><code>sys.path</code></a
      >, i.e. providing a list of locations to search for modules during import.
      However, <code>__path__</code> is typically much more constrained than
      <a href="https://docs.python.org/3/library/sys.html#sys.path"
        ><code>sys.path</code></a
      >.
    </p>
    <p>
      <code>__path__</code> must be an iterable of strings, but it may be empty.
      The same rules used for
      <a href="https://docs.python.org/3/library/sys.html#sys.path"
        ><code>sys.path</code></a
      >
      also apply to a package’s <code>__path__</code>, and
      <a href="https://docs.python.org/3/library/sys.html#sys.path_hooks"
        ><code>sys.path_hooks</code></a
      >
      (described below) are consulted when traversing a package’s
      <code>__path__</code>.
    </p>
    <p>
      A package’s <code>__init__.py</code> file may set or alter the package’s
      <code>__path__</code> attribute, and this was typically the way namespace
      packages were implemented prior to
      <a href="https://www.python.org/dev/peps/pep-0420"
        ><strong>PEP 420</strong></a
      >. With the adoption of
      <a href="https://www.python.org/dev/peps/pep-0420"
        ><strong>PEP 420</strong></a
      >, namespace packages no longer need to supply
      <code>__init__.py</code> files containing only
      <code>__path__</code> manipulation code; the import machinery
      automatically sets <code>__path__</code> correctly for the namespace
      package.
    </p>
    <h4 id="module-reprs">5.4.6. Module reprs</h4>
    <p>
      By default, all modules have a usable repr, however depending on the
      attributes set above, and in the module’s spec, you can more explicitly
      control the repr of module objects.
    </p>
    <p>
      If the module has a spec (<code>__spec__</code>), the import machinery
      will try to generate a repr from it. If that fails or there is no spec,
      the import system will craft a default repr using whatever information is
      available on the module. It will try to use the
      <code>module.__name__</code>, <code>module.__file__</code>, and
      <code>module.__loader__</code> as input into the repr, with defaults for
      whatever information is missing.
    </p>
    <p>Here are the exact rules used:</p>
    <blockquote>
      <ul>
        <li>
          If the module has a <code>__spec__</code> attribute, the information
          in the spec is used to generate the repr. The “name”, “loader”,
          “origin”, and “has_location” attributes are consulted.
        </li>
        <li>
          If the module has a <code>__file__</code> attribute, this is used as
          part of the module’s repr.
        </li>
        <li>
          If the module has no <code>__file__</code> but does have a
          <code>__loader__</code> that is not <code>None</code>, then the
          loader’s repr is used as part of the module’s repr.
        </li>
        <li>
          Otherwise, just use the module’s <code>__name__</code> in the repr.
        </li>
      </ul>
    </blockquote>
    <p>
      Changed in version 3.4: Use of
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.abc.Loader.module_repr"
        ><code>loader.module_repr()</code></a
      >
      has been deprecated and the module spec is now used by the import
      machinery to generate a module repr.
    </p>
    <p>
      For backward compatibility with Python 3.3, the module repr will be
      generated by calling the loader’s
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.abc.Loader.module_repr"
        ><code>module_repr()</code></a
      >
      method, if defined, before trying either approach described above.
      However, the method is deprecated.
    </p>
    <h4 id="cached-bytecode-invalidation">
      5.4.7. Cached bytecode invalidation
    </h4>
    <p>
      Before Python loads cached bytecode from a <code>.pyc</code> file, it
      checks whether the cache is up-to-date with the source
      <code>.py</code> file. By default, Python does this by storing the
      source’s last-modified timestamp and size in the cache file when writing
      it. At runtime, the import system then validates the cache file by
      checking the stored metadata in the cache file against the source’s
      metadata.
    </p>
    <p>
      Python also supports “hash-based” cache files, which store a hash of the
      source file’s contents rather than its metadata. There are two variants of
      hash-based <code>.pyc</code> files: checked and unchecked. For checked
      hash-based <code>.pyc</code> files, Python validates the cache file by
      hashing the source file and comparing the resulting hash with the hash in
      the cache file. If a checked hash-based cache file is found to be invalid,
      Python regenerates it and writes a new checked hash-based cache file. For
      unchecked hash-based <code>.pyc</code> files, Python simply assumes the
      cache file is valid if it exists. Hash-based <code>.pyc</code> files
      validation behavior may be overridden with the
      <a
        href="https://docs.python.org/3/using/cmdline.html#cmdoption-check-hash-based-pycs"
        ><code>--check-hash-based-pycs</code></a
      >
      flag.
    </p>
    <p>
      Changed in version 3.7: Added hash-based <code>.pyc</code> files.
      Previously, Python only supported timestamp-based invalidation of bytecode
      caches.
    </p>
    <h3 id="the-path-based-finder">5.5. The Path Based Finder</h3>
    <p>
      As mentioned previously, Python comes with several default meta path
      finders. One of these, called the
      <a href="https://docs.python.org/3/glossary.html#term-path-based-finder"
        >path based finder</a
      >
      (<a
        href="https://docs.python.org/3/library/importlib.html#importlib.machinery.PathFinder"
        ><code>PathFinder</code></a
      >), searches an
      <a href="https://docs.python.org/3/glossary.html#term-import-path"
        >import path</a
      >, which contains a list of
      <a href="https://docs.python.org/3/glossary.html#term-path-entry"
        >path entries</a
      >. Each path entry names a location to search for modules.
    </p>
    <p>
      The path based finder itself doesn’t know how to import anything. Instead,
      it traverses the individual path entries, associating each of them with a
      path entry finder that knows how to handle that particular kind of path.
    </p>
    <p>
      The default set of path entry finders implement all the semantics for
      finding modules on the file system, handling special file types such as
      Python source code (<code>.py</code> files), Python byte code (<code
        >.pyc</code
      >
      files) and shared libraries (e.g. <code>.so</code> files). When supported
      by the
      <a
        href="https://docs.python.org/3/library/zipimport.html#module-zipimport"
        ><code>zipimport</code></a
      >
      module in the standard library, the default path entry finders also handle
      loading all of these file types (other than shared libraries) from
      zipfiles.
    </p>
    <p>
      Path entries need not be limited to file system locations. They can refer
      to URLs, database queries, or any other location that can be specified as
      a string.
    </p>
    <p>
      The path based finder provides additional hooks and protocols so that you
      can extend and customize the types of searchable path entries. For
      example, if you wanted to support path entries as network URLs, you could
      write a hook that implements HTTP semantics to find modules on the web.
      This hook (a callable) would return a
      <a href="https://docs.python.org/3/glossary.html#term-path-entry-finder"
        >path entry finder</a
      >
      supporting the protocol described below, which was then used to get a
      loader for the module from the web.
    </p>
    <p>
      A word of warning: this section and the previous both use the term
      <em>finder</em>, distinguishing between them by using the terms
      <a href="https://docs.python.org/3/glossary.html#term-meta-path-finder"
        >meta path finder</a
      >
      and
      <a href="https://docs.python.org/3/glossary.html#term-path-entry-finder"
        >path entry finder</a
      >. These two types of finders are very similar, support similar protocols,
      and function in similar ways during the import process, but it’s important
      to keep in mind that they are subtly different. In particular, meta path
      finders operate at the beginning of the import process, as keyed off the
      <a href="https://docs.python.org/3/library/sys.html#sys.meta_path"
        ><code>sys.meta_path</code></a
      >
      traversal.
    </p>
    <p>
      By contrast, path entry finders are in a sense an implementation detail of
      the path based finder, and in fact, if the path based finder were to be
      removed from
      <a href="https://docs.python.org/3/library/sys.html#sys.meta_path"
        ><code>sys.meta_path</code></a
      >, none of the path entry finder semantics would be invoked.
    </p>
    <h4 id="path-entry-finders">5.5.1. Path entry finders</h4>
    <p>
      The
      <a href="https://docs.python.org/3/glossary.html#term-path-based-finder"
        >path based finder</a
      >
      is responsible for finding and loading Python modules and packages whose
      location is specified with a string
      <a href="https://docs.python.org/3/glossary.html#term-path-entry"
        >path entry</a
      >. Most path entries name locations in the file system, but they need not
      be limited to this.
    </p>
    <p>
      As a meta path finder, the
      <a href="https://docs.python.org/3/glossary.html#term-path-based-finder"
        >path based finder</a
      >
      implements the
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.abc.MetaPathFinder.find_spec"
        ><code>find_spec()</code></a
      >
      protocol previously described, however it exposes additional hooks that
      can be used to customize how modules are found and loaded from the
      <a href="https://docs.python.org/3/glossary.html#term-import-path"
        >import path</a
      >.
    </p>
    <p>
      Three variables are used by the
      <a href="https://docs.python.org/3/glossary.html#term-path-based-finder"
        >path based finder</a
      >,
      <a href="https://docs.python.org/3/library/sys.html#sys.path"
        ><code>sys.path</code></a
      >,
      <a href="https://docs.python.org/3/library/sys.html#sys.path_hooks"
        ><code>sys.path_hooks</code></a
      >
      and
      <a
        href="https://docs.python.org/3/library/sys.html#sys.path_importer_cache"
        ><code>sys.path_importer_cache</code></a
      >. The <code>__path__</code> attributes on package objects are also used.
      These provide additional ways that the import machinery can be customized.
    </p>
    <p>
      <a href="https://docs.python.org/3/library/sys.html#sys.path"
        ><code>sys.path</code></a
      >
      contains a list of strings providing search locations for modules and
      packages. It is initialized from the <code>PYTHONPATH</code> environment
      variable and various other installation- and implementation-specific
      defaults. Entries in
      <a href="https://docs.python.org/3/library/sys.html#sys.path"
        ><code>sys.path</code></a
      >
      can name directories on the file system, zip files, and potentially other
      “locations” (see the
      <a href="https://docs.python.org/3/library/site.html#module-site"
        ><code>site</code></a
      >
      module) that should be searched for modules, such as URLs, or database
      queries. Only strings and bytes should be present on
      <a href="https://docs.python.org/3/library/sys.html#sys.path"
        ><code>sys.path</code></a
      >; all other data types are ignored. The encoding of bytes entries is
      determined by the individual
      <a href="https://docs.python.org/3/glossary.html#term-path-entry-finder"
        >path entry finders</a
      >.
    </p>
    <p>
      The
      <a href="https://docs.python.org/3/glossary.html#term-path-based-finder"
        >path based finder</a
      >
      is a
      <a href="https://docs.python.org/3/glossary.html#term-meta-path-finder"
        >meta path finder</a
      >, so the import machinery begins the
      <a href="https://docs.python.org/3/glossary.html#term-import-path"
        >import path</a
      >
      search by calling the path based finder’s
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.machinery.PathFinder.find_spec"
        ><code>find_spec()</code></a
      >
      method as described previously. When the <code>path</code> argument to
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.machinery.PathFinder.find_spec"
        ><code>find_spec()</code></a
      >
      is given, it will be a list of string paths to traverse - typically a
      package’s <code>__path__</code> attribute for an import within that
      package. If the <code>path</code> argument is <code>None</code>, this
      indicates a top level import and
      <a href="https://docs.python.org/3/library/sys.html#sys.path"
        ><code>sys.path</code></a
      >
      is used.
    </p>
    <p>
      The path based finder iterates over every entry in the search path, and
      for each of these, looks for an appropriate
      <a href="https://docs.python.org/3/glossary.html#term-path-entry-finder"
        >path entry finder</a
      >
      (<a
        href="https://docs.python.org/3/library/importlib.html#importlib.abc.PathEntryFinder"
        ><code>PathEntryFinder</code></a
      >) for the path entry. Because this can be an expensive operation
      (e.g. there may be stat() call overheads for this search), the path based
      finder maintains a cache mapping path entries to path entry finders. This
      cache is maintained in
      <a
        href="https://docs.python.org/3/library/sys.html#sys.path_importer_cache"
        ><code>sys.path_importer_cache</code></a
      >
      (despite the name, this cache actually stores finder objects rather than
      being limited to
      <a href="https://docs.python.org/3/glossary.html#term-importer"
        >importer</a
      >
      objects). In this way, the expensive search for a particular
      <a href="https://docs.python.org/3/glossary.html#term-path-entry"
        >path entry</a
      >
      location’s
      <a href="https://docs.python.org/3/glossary.html#term-path-entry-finder"
        >path entry finder</a
      >
      need only be done once. User code is free to remove cache entries from
      <a
        href="https://docs.python.org/3/library/sys.html#sys.path_importer_cache"
        ><code>sys.path_importer_cache</code></a
      >
      forcing the path based finder to perform the path entry search again
      <a href="https://docs.python.org/3/reference/import.html#fnpic">3</a>.
    </p>
    <p>
      If the path entry is not present in the cache, the path based finder
      iterates over every callable in
      <a href="https://docs.python.org/3/library/sys.html#sys.path_hooks"
        ><code>sys.path_hooks</code></a
      >. Each of the
      <a href="https://docs.python.org/3/glossary.html#term-path-entry-hook"
        >path entry hooks</a
      >
      in this list is called with a single argument, the path entry to be
      searched. This callable may either return a
      <a href="https://docs.python.org/3/glossary.html#term-path-entry-finder"
        >path entry finder</a
      >
      that can handle the path entry, or it may raise
      <a href="https://docs.python.org/3/library/exceptions.html#ImportError"
        ><code>ImportError</code></a
      >. An
      <a href="https://docs.python.org/3/library/exceptions.html#ImportError"
        ><code>ImportError</code></a
      >
      is used by the path based finder to signal that the hook cannot find a
      <a href="https://docs.python.org/3/glossary.html#term-path-entry-finder"
        >path entry finder</a
      >
      for that
      <a href="https://docs.python.org/3/glossary.html#term-path-entry"
        >path entry</a
      >. The exception is ignored and
      <a href="https://docs.python.org/3/glossary.html#term-import-path"
        >import path</a
      >
      iteration continues. The hook should expect either a string or bytes
      object; the encoding of bytes objects is up to the hook (e.g. it may be a
      file system encoding, UTF-8, or something else), and if the hook cannot
      decode the argument, it should raise
      <a href="https://docs.python.org/3/library/exceptions.html#ImportError"
        ><code>ImportError</code></a
      >.
    </p>
    <p>
      If
      <a href="https://docs.python.org/3/library/sys.html#sys.path_hooks"
        ><code>sys.path_hooks</code></a
      >
      iteration ends with no
      <a href="https://docs.python.org/3/glossary.html#term-path-entry-finder"
        >path entry finder</a
      >
      being returned, then the path based finder’s
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.machinery.PathFinder.find_spec"
        ><code>find_spec()</code></a
      >
      method will store <code>None</code> in
      <a
        href="https://docs.python.org/3/library/sys.html#sys.path_importer_cache"
        ><code>sys.path_importer_cache</code></a
      >
      (to indicate that there is no finder for this path entry) and return
      <code>None</code>, indicating that this
      <a href="https://docs.python.org/3/glossary.html#term-meta-path-finder"
        >meta path finder</a
      >
      could not find the module.
    </p>
    <p>
      If a
      <a href="https://docs.python.org/3/glossary.html#term-path-entry-finder"
        >path entry finder</a
      >
      <em>is</em> returned by one of the
      <a href="https://docs.python.org/3/glossary.html#term-path-entry-hook"
        >path entry hook</a
      >
      callables on
      <a href="https://docs.python.org/3/library/sys.html#sys.path_hooks"
        ><code>sys.path_hooks</code></a
      >, then the following protocol is used to ask the finder for a module
      spec, which is then used when loading the module.
    </p>
    <p>
      The current working directory – denoted by an empty string – is handled
      slightly differently from other entries on
      <a href="https://docs.python.org/3/library/sys.html#sys.path"
        ><code>sys.path</code></a
      >. First, if the current working directory is found to not exist, no value
      is stored in
      <a
        href="https://docs.python.org/3/library/sys.html#sys.path_importer_cache"
        ><code>sys.path_importer_cache</code></a
      >. Second, the value for the current working directory is looked up fresh
      for each module lookup. Third, the path used for
      <a
        href="https://docs.python.org/3/library/sys.html#sys.path_importer_cache"
        ><code>sys.path_importer_cache</code></a
      >
      and returned by
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.machinery.PathFinder.find_spec"
        ><code>importlib.machinery.PathFinder.find_spec()</code></a
      >
      will be the actual current working directory and not the empty string.
    </p>
    <h4 id="path-entry-finder-protocol">5.5.2. Path entry finder protocol</h4>
    <p>
      In order to support imports of modules and initialized packages and also
      to contribute portions to namespace packages, path entry finders must
      implement the
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.abc.PathEntryFinder.find_spec"
        ><code>find_spec()</code></a
      >
      method.
    </p>
    <p>
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.abc.PathEntryFinder.find_spec"
        ><code>find_spec()</code></a
      >
      takes two arguments: the fully qualified name of the module being
      imported, and the (optional) target module.
      <code>find_spec()</code> returns a fully populated spec for the module.
      This spec will always have “loader” set (with one exception).
    </p>
    <p>
      To indicate to the import machinery that the spec represents a namespace
      <a href="https://docs.python.org/3/glossary.html#term-portion">portion</a
      >, the path entry finder sets “submodule_search_locations” to a list
      containing the portion.
    </p>
    <p>
      Changed in version 3.4:
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.abc.PathEntryFinder.find_spec"
        ><code>find_spec()</code></a
      >
      replaced
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.abc.PathEntryFinder.find_loader"
        ><code>find_loader()</code></a
      >
      and
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.abc.PathEntryFinder.find_module"
        ><code>find_module()</code></a
      >, both of which are now deprecated, but will be used if
      <code>find_spec()</code> is not defined.
    </p>
    <p>
      Older path entry finders may implement one of these two deprecated methods
      instead of <code>find_spec()</code>. The methods are still respected for
      the sake of backward compatibility. However, if
      <code>find_spec()</code> is implemented on the path entry finder, the
      legacy methods are ignored.
    </p>
    <p>
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.abc.PathEntryFinder.find_loader"
        ><code>find_loader()</code></a
      >
      takes one argument, the fully qualified name of the module being imported.
      <code>find_loader()</code> returns a 2-tuple where the first item is the
      loader and the second item is a namespace
      <a href="https://docs.python.org/3/glossary.html#term-portion">portion</a
      >.
    </p>
    <p>
      For backwards compatibility with other implementations of the import
      protocol, many path entry finders also support the same, traditional
      <code>find_module()</code> method that meta path finders support. However
      path entry finder <code>find_module()</code> methods are never called with
      a <code>path</code> argument (they are expected to record the appropriate
      path information from the initial call to the path hook).
    </p>
    <p>
      The <code>find_module()</code> method on path entry finders is deprecated,
      as it does not allow the path entry finder to contribute portions to
      namespace packages. If both <code>find_loader()</code> and
      <code>find_module()</code> exist on a path entry finder, the import system
      will always call <code>find_loader()</code> in preference to
      <code>find_module()</code>.
    </p>
    <h3 id="replacing-the-standard-import-system">
      5.6. Replacing the standard import system
    </h3>
    <p>
      The most reliable mechanism for replacing the entire import system is to
      delete the default contents of
      <a href="https://docs.python.org/3/library/sys.html#sys.meta_path"
        ><code>sys.meta_path</code></a
      >, replacing them entirely with a custom meta path hook.
    </p>
    <p>
      If it is acceptable to only alter the behaviour of import statements
      without affecting other APIs that access the import system, then replacing
      the builtin
      <a href="https://docs.python.org/3/library/functions.html#__import__"
        ><code>__import__()</code></a
      >
      function may be sufficient. This technique may also be employed at the
      module level to only alter the behaviour of import statements within that
      module.
    </p>
    <p>
      To selectively prevent the import of some modules from a hook early on the
      meta path (rather than disabling the standard import system entirely), it
      is sufficient to raise
      <a
        href="https://docs.python.org/3/library/exceptions.html#ModuleNotFoundError"
        ><code>ModuleNotFoundError</code></a
      >
      directly from
      <a
        href="https://docs.python.org/3/library/importlib.html#importlib.abc.MetaPathFinder.find_spec"
        ><code>find_spec()</code></a
      >
      instead of returning <code>None</code>. The latter indicates that the meta
      path search should continue, while raising an exception terminates it
      immediately.
    </p>
    <h3 id="package-relative-imports">5.7. Package Relative Imports</h3>
    <p>
      Relative imports use leading dots. A single leading dot indicates a
      relative import, starting with the current package. Two or more leading
      dots indicate a relative import to the parent(s) of the current package,
      one level per dot after the first. For example, given the following
      package layout:
    </p>
    <div class="sourceCode" id="cb83">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb83-1" title="1">package<span class="op">/</span></a>
<a class="sourceLine" id="cb83-2" title="2">    <span class="fu">__init__</span>.py</a>
<a class="sourceLine" id="cb83-3" title="3">    subpackage1<span class="op">/</span></a>
<a class="sourceLine" id="cb83-4" title="4">        <span class="fu">__init__</span>.py</a>
<a class="sourceLine" id="cb83-5" title="5">        moduleX.py</a>
<a class="sourceLine" id="cb83-6" title="6">        moduleY.py</a>
<a class="sourceLine" id="cb83-7" title="7">    subpackage2<span class="op">/</span></a>
<a class="sourceLine" id="cb83-8" title="8">        <span class="fu">__init__</span>.py</a>
<a class="sourceLine" id="cb83-9" title="9">        moduleZ.py</a>
<a class="sourceLine" id="cb83-10" title="10">    moduleA.py</a></code></pre>
    </div>
    <p>
      In either <code>subpackage1/moduleX.py</code> or
      <code>subpackage1/__init__.py</code>, the following are valid relative
      imports:
    </p>
    <div class="sourceCode" id="cb84">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb84-1" title="1"><span class="im">from</span> .moduleY <span class="im">import</span> spam</a>
<a class="sourceLine" id="cb84-2" title="2"><span class="im">from</span> .moduleY <span class="im">import</span> spam <span class="im">as</span> ham</a>
<a class="sourceLine" id="cb84-3" title="3"><span class="im">from</span> . <span class="im">import</span> moduleY</a>
<a class="sourceLine" id="cb84-4" title="4"><span class="im">from</span> ..subpackage1 <span class="im">import</span> moduleY</a>
<a class="sourceLine" id="cb84-5" title="5"><span class="im">from</span> ..subpackage2.moduleZ <span class="im">import</span> eggs</a>
<a class="sourceLine" id="cb84-6" title="6"><span class="im">from</span> ..moduleA <span class="im">import</span> foo</a></code></pre>
    </div>
    <p>
      Absolute imports may use either the <code>import &lt;&gt;</code> or
      <code>from &lt;&gt; import &lt;&gt;</code> syntax, but relative imports
      may only use the second form; the reason for this is that:
    </p>
    <div class="sourceCode" id="cb85">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb85-1" title="1"><span class="im">import</span> XXX.YYY.ZZZ</a></code></pre>
    </div>
    <p>
      should expose <code>XXX.YYY.ZZZ</code> as a usable expression, but
      .moduleY is not a valid expression.
    </p>
    <h3 id="special-considerations-for-__main__">
      5.8. Special considerations for __main__
    </h3>
    <p>
      The
      <a href="https://docs.python.org/3/library/__main__.html#module-__main__"
        ><code>__main__</code></a
      >
      module is a special case relative to Python’s import system. As noted
      <a
        href="https://docs.python.org/3/reference/toplevel_components.html#programs"
        >elsewhere</a
      >, the <code>__main__</code> module is directly initialized at interpreter
      startup, much like
      <a href="https://docs.python.org/3/library/sys.html#module-sys"
        ><code>sys</code></a
      >
      and
      <a href="https://docs.python.org/3/library/builtins.html#module-builtins"
        ><code>builtins</code></a
      >. However, unlike those two, it doesn’t strictly qualify as a built-in
      module. This is because the manner in which <code>__main__</code> is
      initialized depends on the flags and other options with which the
      interpreter is invoked.
    </p>
    <h4 id="main__.__spec__">5.8.1. __main__.__spec__</h4>
    <p>
      Depending on how
      <a href="https://docs.python.org/3/library/__main__.html#module-__main__"
        ><code>__main__</code></a
      >
      is initialized, <code>__main__.__spec__</code> gets set appropriately or
      to <code>None</code>.
    </p>
    <p>
      When Python is started with the
      <a href="https://docs.python.org/3/using/cmdline.html#cmdoption-m"
        ><code>-m</code></a
      >
      option, <code>__spec__</code> is set to the module spec of the
      corresponding module or package. <code>__spec__</code> is also populated
      when the <code>__main__</code> module is loaded as part of executing a
      directory, zipfile or other
      <a href="https://docs.python.org/3/library/sys.html#sys.path"
        ><code>sys.path</code></a
      >
      entry.
    </p>
    <p>
      In
      <a
        href="https://docs.python.org/3/using/cmdline.html#using-on-interface-options"
        >the remaining cases</a
      >
      <code>__main__.__spec__</code> is set to <code>None</code>, as the code
      used to populate the
      <a href="https://docs.python.org/3/library/__main__.html#module-__main__"
        ><code>__main__</code></a
      >
      does not correspond directly with an importable module:
    </p>
    <ul>
      <li>interactive prompt</li>
      <li>
        <a href="https://docs.python.org/3/using/cmdline.html#cmdoption-c"
          ><code>-c</code></a
        >
        option
      </li>
      <li>running from stdin</li>
      <li>running directly from a source or bytecode file</li>
    </ul>
    <p>
      Note that <code>__main__.__spec__</code> is always <code>None</code> in
      the last case, <em>even if</em> the file could technically be imported
      directly as a module instead. Use the
      <a href="https://docs.python.org/3/using/cmdline.html#cmdoption-m"
        ><code>-m</code></a
      >
      switch if valid module metadata is desired in
      <a href="https://docs.python.org/3/library/__main__.html#module-__main__"
        ><code>__main__</code></a
      >.
    </p>
    <p>
      Note also that even when <code>__main__</code> corresponds with an
      importable module and <code>__main__.__spec__</code> is set accordingly,
      they’re still considered <em>distinct</em> modules. This is due to the
      fact that blocks guarded by <code>if __name__ == "__main__":</code> checks
      only execute when the module is used to populate the
      <code>__main__</code> namespace, and not during normal import.
    </p>
  </body>
</html>
