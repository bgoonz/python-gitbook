import extract from '@emmetio/extract-abbreviation';
import {
    createSnippetsRegistry,
    expand,
    isStylesheet,
    parse
} from '@emmetio/expand-abbreviation';
import {
    convertToCSSSnippets
} from '@emmetio/css-snippets-resolver';
import parseHTML from '@emmetio/html-matcher';
import StreamReader from '@emmetio/stream-reader';

/**
 * Syntaxes known by Emmet. All other syntaxes shoud map to one of these
 * @type {Set}
 */
const knownSyntaxes = new Set([
    'html', 'xml', 'xsl', 'jsx', 'js', 'pug', 'slim', 'haml',
    'css', 'sass', 'scss', 'less', 'sss', 'stylus'
]);

/**
 * Common context checker for abbreviation auto-activation for
 * stylesheet syntaxes (CSS, SCSS, LESS etc.)
 * @param  {CodeMirror} editor
 * @return {Boolean}
 */
const stylesheetAutoActivationContext = (editor, pos) => {
    const tokenType = editor.getTokenTypeAt(pos || editor.getCursor());
    // NB may return `property` or `property error` type
    return tokenType && /^property\b/.test(tokenType);
};

const autoActivationContext = {
    html(editor, pos) {
        // Do not provide automatic abbreviation completion inside HTML tags,
        // e.g. work only inside plain text token
        return editor.getTokenTypeAt(pos || editor.getCursor()) === null;
    },

    css: stylesheetAutoActivationContext,
    less: stylesheetAutoActivationContext,
    sass: stylesheetAutoActivationContext,
    scss: stylesheetAutoActivationContext
};

/**
 * Detect Emmet syntax from given editor’s position.
 * @param {CodeMirror}     editor
 * @param {CodeMirror.Pos} [pos]
 * @return {String}        Returns `null` if Emmet syntax can’t be detected
 */
function detectSyntax(editor, pos) {
    const mode = editor.getModeAt(pos || editor.getCursor());
    const syntax = mode.name === 'xml' ? 'html' : mode.name;

    if (isSupported(syntax)) {
        return syntax;
    }

    // No supported syntax found, try from Emmet-specific options
    const emmetOpt = editor.getOption('emmet');
    if (emmetOpt && isSupported(emmetOpt.syntax)) {
        return emmetOpt.syntax;
    }

    return null;
}

/**
 * Check if given syntax is supported by Emmet
 * @param  {String}  syntax
 * @return {Boolean}
 */
function isSupported(syntax) {
    return knownSyntaxes.has(syntax);
}

/**
 * Check if current editor’s context (syntax, scope) allows automatic Emmet
 * abbreviation activation as user types text. If this function returns `false`,
 * it is recommended to not create any Emmet completions when user types text,
 * but insert them when user activated autocomplete popup manually
 * @param  {CodeMirror}  editor
 * @param  {CodeMirror.Pos} [pos]
 * @return {Boolean}
 */
function hasAutoActivateContext(editor, pos) {
    const syntax = detectSyntax(editor, pos);
    return syntax && (!autoActivationContext[syntax] || autoActivationContext[syntax](editor, pos));
}

/**
 * Returns token used for single indentation in given editor
 * @param  {CodeMirror} editor
 * @return {String}
 */
function getIndentation(editor) {
    if (!editor.getOption('indentWithTabs')) {
        return repeatString(' ', editor.getOption('indentUnit'));
    }

    return '\t';
}

/**
 * Normalizes text according to given CodeMirror instance indentation
 * preferences
 * @param  {String}     text
 * @param  {CodeMirror} editor
 * @param  {String}     [indentation] Applies `indentText()` with given argument,
 *                                    if provided
 * @return {String}
 */
function normalizeText(editor, text, indentation) {
    let lines = splitByLines(text);
    const indent = getIndentation(editor);

    if (indent !== '\t') {
        lines = lines.map(line => line.replace(/^\t+/,
            tabs => repeatString(indent, tabs.length)));
    }

    if (indentation) {
        lines = lines.map((line, i) => i ? indentation + line : line);
    }

    return lines.join('\n');
}

/**
 * Indents each line, except first one, in given text
 * @param  {String} text
 * @param  {String} indentation
 * @return {String}
 */


/**
 * Splits given text by lines
 * @param  {String} text
 * @return {String[]} Lines of text
 */
function splitByLines(text) {
    return Array.isArray(text) ? text : text.split(/\r\n|\r|\n/g);
}

function repeatString(str, count) {
    let result = '';
    while (0 < count--) {
        result += str;
    }

    return result;
}

/**
 * Quick and dirty way to remove fields from given string
 * @param  {String} str
 * @return {String}
 */
function removeFields(str) {
    return str.replace(/\$\{\d+(:[^\}]+)?\}/g, '');
}

/**
 * Check if given range contains point
 * @param  {CodeMirror.Range} range
 * @param  {CodeMirror.Pos} pos
 * @param  {Boolean} [exclude] Exclude range and and start
 * @return {Boolean}
 */
function containsPos(range, pos, exclude) {
    return exclude ?
        comparePos(pos, range.from) > 0 && comparePos(pos, range.to) < 0 :
        comparePos(pos, range.from) >= 0 && comparePos(pos, range.to) <= 0;
}

function comparePos(a, b) {
    return a.line - b.line || a.ch - b.ch;
}

const cursorMark = '[[::emmet-cursor::]]';

// NB CodeMirror doesn’t natively supports tabstops
const editorField = (index, placeholder = '') => placeholder;

/**
 * Expands given abbreviation for given editor.
 * The editor is used to detect abbreviation syntax and provide
 * tag context for markup abbreviations
 * @param  {String|Node} abbr
 * @param  {CodeMirror}  editor
 * @return {String}
 * @throws Error if abbreviation is invalid
 */
function expandAbbreviation(abbr, editor, options) {
    return expand(abbr, Object.assign({
        syntax: detectSyntax(editor),
        field: editorField
    }, getExpandOptions(editor), options));
}

/**
 * Parses abbreviation for given editor
 * @param  {String} abbr
 * @param  {CodeMirror} editor
 * @return {Node}
 * @throws Error if abbreviation is invalid
 */
function parseAbbreviation(abbr, editor) {
    return parse(abbr, Object.assign({
        syntax: detectSyntax(editor),
    }, getExpandOptions(editor)));
}

/**
 * Extracts abbreviation from given position of editor
 * @param  {CodeMirror}     editor
 * @param  {CodeMirror.Pos} [pos]
 * @return {Object}         Object with `{abbreviation, location}` properties or `null`
 */
function extractAbbreviation(editor, pos) {
    pos = pos || pos.getCursor();
    const line = editor.getLine(pos.line);

    return extract(line, pos.ch, true);
}

/**
 * Returns abbreviation model: object with `ast` and `snippet` properties
 * that contains parsed and expanded abbreviation respectively
 * @param  {String} abbreviation
 * @param  {CodeMirror} editor
 * @return {Object} Returns `null` if abbreviation cannot be parsed
 */
function createAbbreviationModel(abbreviation, editor) {
    try {
        const ast = parseAbbreviation(abbreviation, editor);
        return {
            ast,
            abbreviation,
            snippet: expandAbbreviation(abbreviation, editor)
        };
    } catch (err) {
        // console.warn('Unable to build Emmet abbreviation model', err);
        return null;
    }
}

/**
 * Expands given abbreviation and inserts expanded result into editor, maintaining
 * proper indentation and final cursor position
 * @param  {CodeMirror} editor CodeMirror editor instance
 * @param  {String|Object} abbr  Abbreviation to expand (string or parsed)
 * @param  {CodeMirror.Range} range Location of abbreviation in editor
 * @return {Boolean} Returns `true` if abbreviation was successfully expanded and inserted
 */
function expandAndInsert(editor, abbr, range) {
    let cursorMarked = false;
    let newSelectionSize = 0;
    let expanded;

    try {
        expanded = expandAbbreviation(abbr, editor, {
            // CodeMirror doesn’t support snippets with tab-stops natively so we have
            // to mark first output with a special token so we can find it later
            // to properly plant cursor into new position
            field(index, placeholder = '') {
                if (!cursorMarked) {
                    cursorMarked = true;
                    newSelectionSize = placeholder.length;
                    placeholder = cursorMark + placeholder;
                }

                return placeholder;
            }
        });
    } catch (err) {
        // Invalid abbreviation
        // console.warn(err);
        return false;
    }

    const line = editor.getLine(range.from.line);
    const matchIndent = line.match(/^\s+/);
    expanded = normalizeText(editor, expanded, matchIndent && matchIndent[0]);

    let newCursorPos = expanded.length;

    if (cursorMarked) {
        // Remove cursor stub and re-position cursor
        newCursorPos = expanded.indexOf(cursorMark);
        expanded = expanded.slice(0, newCursorPos) + expanded.slice(newCursorPos + cursorMark.length);
    }

    // Replace abbreviation with expanded result
    return editor.operation(() => {
        editor.replaceRange(expanded, range.from, range.to);

        // Position cursor
        const startIx = editor.indexFromPos(range.from);
        const newCursor = editor.posFromIndex(newCursorPos + startIx);
        if (newSelectionSize) {
            editor.setSelection(newCursor, {
                line: newCursor.line,
                ch: newCursor.ch + newSelectionSize
            });
        } else {
            editor.setCursor(newCursor);
        }

        return true;
    });
}

/**
 * Returns options object for syntax from given editor. In most cases, it detects
 * XML-style syntax (HTML, XML, XHTML) and returns options configured for proper
 * output
 * @param  {CodeMirror} editor
 * @param  {Point}      [pos]  Point in editor where syntax should be detected.
 *                             Uses `editor.getCursor()` in not given
 * @return {Object}
 */
function getExpandOptions(editor, pos) {
    const mode = editor.getModeAt(pos || editor.getCursor());
    const emmetOpt = editor.getOption('emmet');
    let profile = emmetOpt && emmetOpt.profile;

    if (mode.name === 'xml') {
        profile = Object.assign({
            selfClosingStyle: mode.configuration
        }, profile);
    }

    return Object.assign({
        profile,
        snippets: snippetsFromOptions(editor, detectSyntax(editor, pos))
    }, emmetOpt);
}

/**
 * Returns custom snippets from Emmet options of given editor
 * @param  {CodeMirror} editor
 * @param  {String} syntax
 * @return {Object}
 */
function snippetsFromOptions(editor, syntax) {
    const emmetOpt = editor.getOption('emmet');
    if (emmetOpt) {
        return isStylesheet(syntax) ?
            emmetOpt.stylesheetSnippets :
            emmetOpt.markupSnippets;
    }
}

const emmetMarkerClass = 'emmet-abbreviation';

/**
 * Editor’s `change` event handler that marks Emmet abbreviation when editor
 * content is updated
 * @param  {CodeMirror} editor
 */
function markOnEditorChange(editor) {
    const marker = findMarker(editor, editor.getCursor());
    if (marker && isValidMarker(editor, marker)) {
        return;
    }

    // No valid marker under caret, remove all registered markers
    // and create a new one
    clearMarkers(editor);
    if (hasAutoActivateContext(editor)) {
        markAbbreviation(editor, editor.getCursor());
    }
}

/**
 * Returns *valid* Emmet abbreviation marker (if any) for given position of editor
 * @param  {CodeMirror}     editor
 * @param  {CodeMirror.Pos} [pos]
 * @return {CodeMirror.TextMarker}
 */
function findMarker(editor, pos) {
    const markers = editor.findMarksAt(pos);
    for (let i = 0; i < markers.length; i++) {
        if (markers[i].className === emmetMarkerClass) {
            return markers[i];
        }
    }
}

/**
 * Marks Emmet abbreviation for given editor position, if possible
 * @param  {TextEditor} editor   Editor where abbreviation marker should be created
 * @param  {Point}      pos      Buffer position where abbreviation should be created.
 *                               Abbreviation will be automatically extracted from
 *                               given position
 * @param  {Boolean}    [forced] Indicates that user forcibly requested abbreviation
 *                               marker (e.g. was not activated automatically).
 *                               Affects abbreviation detection policy
 * @return {DisplayMarker} Returns `undefined` if no valid abbreviation under caret
 */
function markAbbreviation(editor, pos, forced) {
    const marker = findMarker(editor, pos);
    if (marker) {
        // there’s active marker with valid abbreviation
        return marker;
    }

    // No active marker: remove previous markers and create new one, if possible
    clearMarkers(editor);

    const extracted = extractAbbreviation(editor, pos);
    const model = extracted && createAbbreviationModel(extracted.abbreviation, editor);

    if (model && (forced || allowedForAutoActivation(model))) {
        const from = {
            line: pos.line,
            ch: extracted.location
        };
        const to = {
            line: pos.line,
            ch: extracted.location + extracted.abbreviation.length
        };

        const marker = editor.markText(from, to, {
            inclusiveRight: true,
            clearWhenEmpty: true,
            className: emmetMarkerClass
        });
        marker.model = model;
        return marker;
    }
}

/**
 * Removes Emmmet abbreviation markers from given editor
 * @param  {TextEditor} editor
 */
function clearMarkers(editor) {
    const markers = editor.getAllMarks();
    for (let i = 0; i < markers.length; i++) {
        if (markers[i].className === emmetMarkerClass) {
            markers[i].clear();
        }
    }
}

/**
 * Check if given abbreviation model is allowed for auto-activated abbreviation
 * marker. Used to reduce falsy activations
 * @param  {Object} model Parsed abbreviation model (see `createAbbreviationModel()`)
 * @return {Boolean}
 */
function allowedForAutoActivation(model) {
    const rootNode = model.ast.children[0];
    // The very first node should start with alpha character
    // Skips falsy activations for something like `$foo` etc.
    return rootNode && /^[a-z]/i.test(rootNode.name);
}

/**
 * Ensures that given editor Emmet abbreviation marker contains valid Emmet abbreviation
 * and updates abbreviation model if required
 * @param {CodeMirror} editor
 * @param {CodeMirror.TextMarket} marker
 * @return {Boolean} `true` if marker contains valid abbreviation
 */
function isValidMarker(editor, marker) {
    const range = marker.find();

    // No newlines inside abreviation
    if (range.from.line !== range.to.line) {
        return false;
    }

    // Make sure marker contains valid abbreviation
    const text = editor.getRange(range.from, range.to);
    if (!text || /^\s|\s$/g.test(text)) {
        return false;
    }

    if (!marker.model || marker.model.abbreviation !== text) {
        // marker contents was updated, re-parse abbreviation
        marker.model = createAbbreviationModel(text, editor);
    }

    return !!(marker.model && marker.model.snippet);
}

/**
 * Expand abbreviation command
 * @param  {CodeMirror} editor
 */
var emmetExpandAbbreviation = function(editor) {
    if (editor.somethingSelected()) {
        return editor.constructor.Pass;
    }

    const pos = editor.getCursor();
    const marker = findMarker(editor, pos);

    let result = false;

    // Handle two possible options: expand abbreviation from Emmet marker that
    // matches given location or extract & expand abbreviation from cursor
    // position. The last one may happen if either `markeEmmetAbbreviation`
    // option is turned off or user moved cursor away from Emmet marker and
    // tries to expand another abbreviation

    if (marker) {
        result = expandAndInsert(editor, marker.model.ast, marker.find());
    } else {
        const abbrData = extractAbbreviation(editor, pos);
        if (abbrData) {
            const range = {
                from: {
                    line: pos.line,
                    ch: abbrData.location
                },
                to: {
                    line: pos.line,
                    ch: abbrData.location + abbrData.abbreviation.length
                }
            };

            result = expandAndInsert(editor, abbrData.abbreviation, range);
        }
    }

    clearMarkers(editor);

    // If no abbreviation was expanded, allow editor to handle different
    // action for keyboard shortcut (Tab key mostly)
    return result || editor.constructor.Pass;
};

/**
 * Inserts formatted line tag between tags
 * @param  {CodeMirror} editor
 */
var emmetInsertLineBreak = function(editor) {
    const cursor = editor.getCursor();
    const mode = editor.getModeAt(cursor);

    if (mode.name === 'xml') {
        const next = Object.assign({}, cursor, {
            ch: cursor.ch + 1
        });
        const left = editor.getTokenAt(cursor);
        const right = editor.getTokenAt(Object.assign({}, cursor, {
            ch: cursor.ch + 1
        }));

        if (left.type === 'tag bracket' && left.string === '>' &&
            right.type === 'tag bracket' && right.string === '</') {
            const matchIndent = editor.getLine(cursor.line).match(/^\s+/);
            const curIndent = matchIndent ? matchIndent[0] : '';
            const indent = getIndentation(editor);

            // Insert formatted line break
            const before = `\n${curIndent}${indent}`;
            const after = `\n${curIndent}`;
            editor.replaceRange(before + after, cursor, cursor);

            // Position cursor
            const startIx = editor.indexFromPos(cursor);
            const newCursor = editor.posFromIndex(startIx + before.length);
            editor.setCursor(newCursor);

            return;
        }
    }

    return editor.constructor.Pass;
};

/**
 * Returns available completions from given editor
 * @param  {CodeMirror}      editor
 * @param  {String}          abbrModel   Parsed Emmet abbreviation model for which
 *                                       completions should be populated
 *                                       (see `createAbbreviationModel()`)
 * @param  {CodeMirror.Pos}  abbrPos     Abbreviation location in editor
 * @param  {CodeMirror.Pos}  [cursorPos] Cursor position in editor
 * @return {EmmetCompletion[]}
 */
var autocompleteProvider = function(editor, abbrModel, abbrPos, cursorPos) {
    cursorPos = cursorPos || editor.getCursor();
    const syntax = detectSyntax(editor, cursorPos);
    if (!syntax) {
        // Unsupported syntax
        return [];
    }

    return isStylesheet(syntax) ?
        getStylesheetCompletions(editor, abbrModel, abbrPos, cursorPos) :
        getMarkupCompletions(editor, abbrModel, abbrPos, cursorPos);
};

/**
 * Returns completions for markup syntaxes (HTML, Slim, Pug etc.)
 * @param  {CodeMirror}      editor
 * @param  {Object}          abbrModel   Parsed Emmet abbreviation model for which
 *                                       completions should be populated
 *                                       (see `createAbbreviationModel()`)
 * @param  {CodeMirror.Pos}  abbrPos     Abbreviation location in editor
 * @param  {CodeMirror.Pos}  [cursorPos] Cursor position in editor
 * @return {EmmetCompletion[]}
 */
function getMarkupCompletions(editor, abbrModel, abbrPos, cursorPos) {
    let result = [];
    cursorPos = cursorPos || editor.getCursor();

    const abbrRange = {
        from: abbrPos,
        to: {
            line: abbrPos.line,
            ch: abbrPos.ch + abbrModel.abbreviation.length
        }
    };

    result.push(new EmmetCompletion('expanded-abbreviation', editor, abbrRange, 'Expand abbreviation',
        abbrModel.snippet, () => expandAndInsert(editor, abbrModel.abbreviation, abbrRange)));

    // Make sure that current position precedes element name (e.g. not attribute,
    // class, id etc.)
    const prefix = getMarkupPrefix(abbrModel.abbreviation, cursorPos.ch - abbrPos.ch);
    if (prefix !== null) {
        const prefixRange = {
            from: {
                line: cursorPos.line,
                ch: cursorPos.ch - prefix.length
            },
            to: cursorPos
        };

        const completions = getSnippetCompletions(editor, cursorPos)
            .filter(snippet => snippet.key !== prefix && snippet.key.indexOf(prefix) === 0)
            .map(snippet => new EmmetCompletion('snippet', editor, prefixRange, snippet.key,
                snippet.preview, snippet.key));

        result = result.concat(completions);
    }

    return result;
}

/**
 * Returns completions for stylesheet syntaxes
 * @param  {CodeMirror} editor
 * @param  {Object} abbrModel
 * @param  {CodeMirror.Pos} abbrPos
 * @param  {CodeMirror.Pos} cursorPos
 * @return {EmmetCompletion[]}
 */
function getStylesheetCompletions(editor, abbrModel, abbrPos, cursorPos) {
    let result = [];
    cursorPos = cursorPos || editor.getCursor();

    const abbrRange = {
        from: abbrPos,
        to: {
            line: abbrPos.line,
            ch: abbrPos.ch + abbrModel.abbreviation.length
        }
    };

    result.push(new EmmetCompletion('expanded-abbreviation', editor, abbrRange, 'Expand abbreviation',
        abbrModel.snippet, () => expandAndInsert(editor, abbrModel.abbreviation, abbrRange)));

    // Make sure that current position precedes element name (e.g. not attribute,
    // class, id etc.)
    const prefix = getStylesheetPrefix(abbrModel.abbreviation, cursorPos.ch - abbrPos.ch);
    if (prefix !== null) {
        const prefixRange = {
            from: {
                line: cursorPos.line,
                ch: cursorPos.ch - prefix.length
            },
            to: cursorPos
        };

        const completions = getSnippetCompletions(editor, cursorPos)
            .filter(snippet => snippet.key !== prefix && snippet.key.indexOf(prefix) === 0)
            .map(snippet => new EmmetCompletion('snippet', editor, prefixRange,
                snippet.key, snippet.preview, snippet.key));

        result = result.concat(completions);
    }

    return result;
}

/**
 * Returns all possible snippets completions for given editor context.
 * Completions are cached in editor for for re-use
 * @param  {CodeMirror} editor
 * @param  {CodeMirror.Pos} pos
 * @return {Array}
 */
function getSnippetCompletions(editor, pos) {
    const syntax = detectSyntax(editor, pos);

    if (!editor.state.emmetCompletions) {
        editor.state.emmetCompletions = {};
    }

    const cache = editor.state.emmetCompletions;

    if (!(syntax in cache)) {
        const registry = createSnippetsRegistry(syntax, snippetsFromOptions(editor, syntax));

        if (isStylesheet(syntax)) {
            // Collect snippets for stylesheet context: just a plain list of
            // snippets, converted specifically for CSS context
            cache[syntax] = convertToCSSSnippets(registry).map(snippet => {
                let preview = snippet.property;
                const keywords = snippet.keywords();
                if (keywords.length) {
                    preview += `: ${removeFields(keywords.join(' | '))}`;
                }

                return {
                    key: snippet.key,
                    value: snippet.value,
                    keywords,
                    preview
                };
            });
        } else {
            // Collect snippets for markup syntaxes: HTML, XML, Slim, Pug etc.
            // Not just a plain snippets list but thier expanded result as well
            const field = (index, placeholder) => placeholder || '';
            const expandOpt = {
                syntax,
                field
            };

            cache[syntax] = registry.all({
                type: 'string'
            }).map(snippet => ({
                key: snippet.key,
                value: snippet.value,
                preview: expandAbbreviation(snippet.value, editor, expandOpt)
            }));
        }
    }

    return cache[syntax];
}

/**
 * Returns node element prefix, if applicable, for given `pos` in abbreviation
 * for markup syntaxes completions
 * @param  {String} abbr
 * @param  {Number} pos
 * @return {String} Returns `null` if not in element name context
 */
function getMarkupPrefix(abbr, pos) {
    return getPrefix(abbr, pos, /[\w:\-\$@]+$/);
}

/**
 * Returns node element prefix, if applicable, for given `pos` in abbreviation
 * for stylesheet syntaxes completions
 * @param  {String} abbr
 * @param  {Number} pos
 * @return {String} Returns `null` if not in element name context
 */
function getStylesheetPrefix(abbr, pos) {
    return getPrefix(abbr, pos, /[\w-@$]+$/);
}

/**
 * Get snippet completion prefix that matches given `match` regexp from `pos`
 * character pasition of given `abbr` abbreviation
 * @param  {String} abbr
 * @param  {Number} pos
 * @param  {RegExp} match
 * @return {String}
 */
function getPrefix(abbr, pos, match) {
    if (pos === 0) {
        // Word prefix is at the beginning of abbreviation: it’s an element
        // context for sure
        return '';
    }

    const m = abbr.slice(0, pos).match(match);
    const prefix = m && m[0] || '';

    // Check if matched prefix is either at the beginning of abbreviation or
    // at the element bound, e.g. right after operator
    if (prefix && (prefix === abbr || /[>\^\+\(\)]/.test(abbr[pos - prefix.length - 1]))) {
        return prefix;
    }

    return null;
}

class EmmetCompletion {
    constructor(type, editor, range, label, preview, snippet) {
        this.type = type;
        this.editor = editor;
        this.range = range;
        this.label = label;
        this.preview = preview;
        this.snippet = snippet;

        this._inserted = false;
    }

    insert() {
        if (!this._inserted) {
            this._inserted = true;
            if (typeof this.snippet === 'function') {
                this.snippet(this.editor, this.range);
            } else {
                this.editor.replaceRange(this.snippet, this.range.from, this.range.to);

                // Position cursor
                const startIx = this.editor.indexFromPos(this.range.from);
                const newCursor = this.editor.posFromIndex(startIx + this.snippet.length);
                this.editor.setCursor(newCursor);
            }
        }
    }
}

/**
 * A syntax-specific model container, used to get unified access to underlying
 * parsed document
 */
class SyntaxModel {
    /**
     * @param  {Object} dom      Parsed document tree
     * @param  {String} type     Type of document (html, stylesheet, etc.)
     * @param  {String} [syntax] Optional document syntax like html, xhtml or xml
     */
    constructor(dom, type, syntax) {
        this.dom = dom;
        this.type = type;
        this.syntax = syntax;
    }

    /**
     * Returns best matching node for given point
     * @param  {CodeMirror.Pos}   pos
     * @param  {Boolean} [exclude] Exclude node’s start and end positions from
     *                             search
     * @return {Node}
     */
    nodeForPoint(pos, exclude) {
        let ctx = this.dom.firstChild;
        let found = null;

        while (ctx) {
            if (containsPos(range(ctx), pos, exclude)) {
                // Found matching tag. Try to find deeper, more accurate match
                found = ctx;
                ctx = ctx.firstChild;
            } else {
                ctx = ctx.nextSibling;
            }
        }

        return found;
    }
}

function range(node) {
    return {
        from: node.start,
        to: node.end
    };
}

const LINE_END = 10; // \n

/**
 * A stream reader for CodeMirror editor
 */
class CodeMirrorStreamReader extends StreamReader {
    /**
     * @param  {CodeMirror}       editor
     * @param  {CodeMirror.Pos}   [pos]
     * @param  {CodeMirror.Range} [limit]
     */
    constructor(editor, pos, limit) {
        super();
        const CodeMirror = editor.constructor;
        this.editor = editor;
        this.start = this.pos = pos || CodeMirror.Pos(0, 0);

        const lastLine = editor.lastLine();
        this._eof = limit ? limit.to : CodeMirror.Pos(lastLine, this._lineLength(lastLine));
        this._sof = limit ? limit.from : CodeMirror.Pos(0, 0);
    }

    /**
     * Returns true only if the stream is at the beginning of the file.
     * @returns {Boolean}
     */
    sof() {
        return comparePos(this.pos, this._sof) <= 0;
    }

    /**
     * Returns true only if the stream is at the end of the file.
     * @returns {Boolean}
     */
    eof() {
        return comparePos(this.pos, this._eof) >= 0;
    }

    /**
     * Creates a new stream instance which is limited to given `start` and `end`
     * points for underlying buffer
     * @param  {CodeMirror.Pos} start
     * @param  {CodeMirror.Pos} end
     * @return {CodeMirrorStreamReader}
     */
    limit(from, to) {
        return new this.constructor(this.editor, from, {
            from,
            to
        });
    }

    /**
     * Returns the next character code in the stream without advancing it.
     * Will return NaN at the end of the file.
     * @returns {Number}
     */
    peek() {
        const {
            line,
            ch
        } = this.pos;
        const lineStr = this.editor.getLine(this.pos.line);
        return ch < lineStr.length ? lineStr.charCodeAt(ch) : LINE_END;
    }

    /**
     * Returns the next character in the stream and advances it.
     * Also returns NaN when no more characters are available.
     * @returns {Number}
     */
    next() {
        if (!this.eof()) {
            const code = this.peek();
            this.pos = Object.assign({}, this.pos, {
                ch: this.pos.ch + 1
            });

            if (this.pos.ch >= this._lineLength(this.pos.line)) {
                this.pos.line++;
                this.pos.ch = 0;
            }

            if (this.eof()) {
                // handle edge case where position can move on next line
                // after EOF
                this.pos = Object.assign({}, this._eof);
            }

            return code;
        }

        return NaN;
    }

    /**
     * Backs up the stream n characters. Backing it up further than the
     * start of the current token will cause things to break, so be careful.
     * @param {Number} n
     */
    backUp(n) {
        const CodeMirror = this.editor.constructor;

        let {
            line,
            ch
        } = this.pos;
        ch -= (n || 1);

        while (line >= 0 && ch < 0) {
            line--;
            ch += this._lineLength(line);
        }

        this.pos = line < 0 || ch < 0 ?
            CodeMirror.Pos(0, 0) :
            CodeMirror.Pos(line, ch);

        return this.peek();
    }

    /**
     * Get the string between the start of the current token and the
     * current stream position.
     * @returns {String}
     */
    current() {
        return this.substring(this.start, this.pos);
    }

    /**
     * Returns contents for given range
     * @param  {Point} from
     * @param  {Point} to
     * @return {String}
     */
    substring(from, to) {
        return this.editor.getRange(from, to);
    }

    /**
     * Creates error object with current stream state
     * @param {String} message
     * @return {Error}
     */
    error(message) {
        const err = new Error(`${message} at line ${this.pos.line}, column ${this.pos.ch}`);
        err.originalMessage = message;
        err.pos = this.pos;
        err.string = this.string;
        return err;
    }

    /**
     * Returns length of given line, including line ending
     * @param  {Number} line
     * @return {Number}
     */
    _lineLength(line) {
        const isLast = line === this.editor.lastLine();
        return this.editor.getLine(line).length + (isLast ? 0 : 1);
    }
}

/**
 * Creates DOM-like model for given text editor
 * @param  {CodeMirror} editor
 * @param  {String}     syntax
 * @return {Node}
 */
function create(editor, syntax) {
    const stream = new CodeMirrorStreamReader(editor);
    const xml = syntax === 'xml';

    try {
        return new SyntaxModel(parseHTML(stream, {
            xml
        }), 'html', syntax || 'html');
    } catch (err) {
        console.warn(err);
    }
}

function getModel(editor) {
    const syntax = getSyntax(editor);
    return create(editor, syntax);
}

function getCachedModel(editor) {
    if (!editor.state._emmetModel) {
        editor.state._emmetModel = getModel(editor);
    }

    return editor.state._emmetModel;
}

function resetCachedModel(editor) {
    editor.state._emmetModel = null;
}

/**
 * Returns parser-supported syntax of given editor (like 'html', 'css' etc.).
 * Returns `null` if editor’s syntax is unsupported
 * @param  {CodeMirror} editor
 * @return {String}
 */
function getSyntax(editor) {
    const mode = editor.getMode();

    if (mode.name === 'htmlmixed') {
        return 'html';
    }

    return mode.name === 'xml' ? mode.configuration : mode.name;
}

const openTagMark = 'emmet-open-tag';
const closeTagMark = 'emmet-close-tag';

/**
 * Finds matching tag pair for given position in editor
 * @param  {CodeMirror} editor
 * @param  {CodeMirror.Pos} pos
 * @return {Object}
 */
function matchTag(editor, pos) {
    pos = pos || editor.getCursor();

    // First, check if there are tag markers in editor
    const marked = getMarkedTag(editor);

    // If marks found, validate them: make sure cursor is either in open
    // or close tag
    if (marked) {
        if (containsPos(marked.open.find(), pos)) {
            // Point is inside open tag, make sure if there’s a closing tag,
            // it matches open tag content
            if (!marked.close || text(editor, marked.open) === text(editor, marked.close)) {
                return marked;
            }
        } else if (marked.close) {
            // There’s a close tag, make sure pointer is inside it and it matches
            // open tag
            if (containsPos(marked.close.find(), pos) && text(editor, marked.open) === text(editor, marked.close)) {
                return marked;
            }
        }
    }

    // Markers are not valid anymore, remove them
    clearTagMatch(editor);

    // Find new tag pair from parsed HTML model and mark them
    const node = findTagPair(editor, pos);
    if (node && node.type === 'tag') {
        return {
            open: createTagMark(editor, node.open.name, openTagMark),
            close: node.close && createTagMark(editor, node.close.name, closeTagMark)
        };
    }
}

function getMarkedTag(editor) {
    let open, close;
    editor.getAllMarks().forEach(mark => {
        if (mark.className === openTagMark) {
            open = mark;
        } else if (mark.className === closeTagMark) {
            close = mark;
        }
    });

    return open ? {
        open,
        close
    } : null;
}

/**
 * Removes all matched tag pair markers from editor
 * @param  {CodeMirror} editor
 */
function clearTagMatch(editor) {
    editor.getAllMarks().forEach(mark => {
        if (mark.className === openTagMark || mark.className === closeTagMark) {
            mark.clear();
        }
    });
}

/**
 * Finds tag pair (open and close, if any) form parsed HTML model of given editor
 * @param  {CodeMirror} editor
 * @param  {CodeMirror.Pos} pos
 * @return {Object}
 */
function findTagPair(editor, pos) {
    const model = editor.getEmmetDocumentModel();
    return model && model.nodeForPoint(pos || editor.getCursor());
}

function createTagMark(editor, tag, className) {
    return editor.markText(tag.start, tag.end, {
        className,
        inclusiveLeft: true,
        inclusiveRight: true,
        clearWhenEmpty: false
    });
}

function text(editor, mark) {
    const range = mark.find();
    return range ? editor.getRange(range.from, range.to) : '';
}

function renameTag(editor, obj) {
    const tag = getMarkedTag(editor);
    const pos = obj.from;

    if (!tag) {
        return;
    }

    if (containsPos(tag.open.find(), pos) && tag.close) {
        // Update happened inside open tag, update close tag as well
        updateTag(editor, tag.open, tag.close);
    } else if (tag.close && containsPos(tag.close.find(), pos)) {
        // Update happened inside close tag, update open tag as well
        updateTag(editor, tag.close, tag.open);
    }
}

function updateTag(editor, source, dest) {
    const name = text$1(editor, source);
    const range = dest.find();
    const m = name.match(/[\w:\-]+/);
    const newName = !name ? '' : (m && m[0]);

    if (newName != null) {
        if (editor.getRange(range.from, range.to) !== newName) {
            editor.replaceRange(newName, range.from, range.to);
        }
    } else {
        // User entered something that wasn’t a valid tag name.
        clearTagMatch(editor);
    }
}

function text$1(editor, mark) {
    const range = mark.find();
    return range ? editor.getRange(range.from, range.to) : '';
}

const commands = {
    emmetExpandAbbreviation,
    emmetInsertLineBreak
};

/**
 * Registers Emmet extension on given CodeMirror constructor.
 * This file is designed to be imported somehow into the app (CommonJS, ES6,
 * Rollup/Webpack/whatever). If you simply want to add a <script> into your page
 * that registers Emmet extension on global CodeMirror constructor, use
 * `browser.js` instead
 */
function registerEmmetExtension(CodeMirror) {
    // Register Emmet commands
    Object.assign(CodeMirror.commands, commands);

    // Defines options that allows abbreviation marking in text editor
    CodeMirror.defineOption('markEmmetAbbreviation', true, (editor, value) => {
        if (value) {
            editor.on('change', markOnEditorChange);
        } else {
            editor.off('change', markOnEditorChange);
            clearMarkers(editor);
        }
    });

    CodeMirror.defineOption('autoRenameTags', true, (editor, value) => {
        value ? editor.on('change', renameTag) : editor.off('change', renameTag);
    });

    CodeMirror.defineOption('markTagPairs', false, (editor, value) => {
        if (value) {
            editor.on('cursorActivity', matchTag);
            editor.on('change', resetCachedModel);
        } else {
            editor.off('cursorActivity', matchTag);
            editor.off('change', resetCachedModel);
            resetCachedModel(editor);
            clearTagMatch(editor);
        }
    });

    // Additional options for Emmet, for Expand Abbreviation action mostly:
    // https://github.com/emmetio/expand-abbreviation/blob/master/index.js#L26
    CodeMirror.defineOption('emmet', {});

    /**
     * Returns Emmet completions for context from `pos` position.
     * Abbreviations are calculated for marked abbreviation at given position.
     * If no parsed abbreviation marker is available and `force` argument is
     * given, tries to mark abbreviation and populate completions list again.
     * @param  {CodeMirror.Pos} [pos]
     * @param  {Boolean}        [force]
     * @return {EmmetCompletion[]}
     */
    CodeMirror.defineExtension('getEmmetCompletions', function(pos, force) {
        const editor = this;
        if (typeof pos === 'boolean') {
            force = pos;
            pos = null;
        }

        let abbrRange, list;

        pos = pos || editor.getCursor();
        if (editor.getOption('markEmmetAbbreviation')) {
            // Get completions from auto-inserted marker
            const marker = findMarker(editor, pos) || (force && markAbbreviation(editor, pos, true));
            if (marker) {
                abbrRange = marker.find();
                list = autocompleteProvider(editor, marker.model, abbrRange.from, pos);
            }
        } else {
            // No abbreviation auto-marker, try to extract abbreviation from given
            // cursor location
            const extracted = extractAbbreviation(editor, pos);
            if (extracted) {
                const model = createAbbreviationModel(extracted.abbreviation, editor);
                if (model) {
                    abbrRange = {
                        from: {
                            line: pos.line,
                            ch: extracted.location
                        },
                        to: {
                            line: pos.line,
                            ch: extracted.location + extracted.abbreviation.length
                        }
                    };
                    list = autocompleteProvider(editor, model, abbrRange.from, pos);
                }
            }
        }

        if (list && list.length) {
            return {
                from: abbrRange.from,
                to: abbrRange.to,
                list
            };
        }
    });

    /**
     * Returns valid Emmet abbreviation and its location in editor from given
     * position
     * @param  {CodeMirror.Pos} [pos] Position from which abbreviation should be
     *                                extracted. If not given, current cursor
     *                                position is used
     * @return {Object} Object with `abbreviation` and `location` properties
     * or `null` if there’s no valid abbreviation
     */
    CodeMirror.defineExtension('getEmmetAbbreviation', function(pos) {
        const editor = this;
        pos = pos || editor.getCursor();
        const marker = findMarker(editor, pos);

        if (marker) {
            return {
                abbreviation: marker.model.abbreviation,
                ast: marker.model.ast,
                location: marker.find().from,
                fromMarker: true
            };
        }

        const extracted = extractAbbreviation(editor, pos);
        if (extracted) {
            try {
                return {
                    abbreviation: extracted.abbreviation,
                    ast: parseAbbreviation(extracted.abbreviation, editor),
                    location: {
                        line: pos.line,
                        ch: extracted.location
                    },
                    fromMarker: false
                };
            } catch (err) {
                // Will throw if abbreviation is invalid
            }
        }

        return null;
    });

    CodeMirror.defineExtension('findEmmetMarker', function(pos) {
        return findMarker(this, pos || this.getCursor());
    });

    CodeMirror.defineExtension('getEmmetDocumentModel', function() {
        const editor = this;
        return editor.getOption('markTagPairs') ?
            getCachedModel(editor) :
            getModel(editor);
    });
}

export default registerEmmetExtension;